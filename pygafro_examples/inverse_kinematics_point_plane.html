<!--
    SPDX-FileCopyrightText: Copyright Â© 2025 Idiap Research Institute <contact@idiap.ch>

    SPDX-FileContributor: Philip Abbet <philip.abbet@idiap.ch>

    SPDX-License-Identifier: MPL-2.0
-->

<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0">

        <link rel="stylesheet" href="https://pyscript.net/releases/2024.8.2/core.css">
        <script type="module" src="https://pyscript.net/releases/2024.8.2/core.js"></script>

        <link rel="stylesheet" href="../css/loader.css"/>

        <py-config type="toml">
            packages = [
                'numpy',
                'matplotlib',
                
            ]
        </py-config>

        <style>
            table {
                border-collapse: collapse;
                margin-bottom: 20px;
            }

            th {
                background-color: rgb(50, 50, 50);
                color: white;
            }

            td, th {
                border: 1px solid rgb(50, 50, 50);
                padding-right: 10px;
                padding-left: 10px;
                padding-top: 4px;
                padding-bottom: 4px;
            }

            td:first-child {
                background-color: lightgray;
            }
        </style>
    </head>

    <body style="font-family: monospace;">
        <h2>Inverse kinematics: Point to Plane</h2>
        <p>Robot: Franka Emika Panda</p>

        <table id="results" style="display: none;">
            <thead>
                <tr>
                    <th>Value</th>
                    <th>Multivector</th>
                    <th>Position (x, y, z)</th>
                    <th>Normal (x, y, z)</th>
                    <th>Distance</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Start Point</td>
                    <td id="start_mv"></td>
                    <td id="start_pos"></td>
                    <td>-</td>
                    <td>-</td>
                </tr>
                <tr>
                    <td>Target Plane</td>
                    <td id="target_mv"></td>
                    <td>-</td>
                    <td id="target_normal"></td>
                    <td id="target_dist"></td>
                </tr>
                <tr>
                    <td>Solution Point</td>
                    <td id="solution_mv"></td>
                    <td id="solution_pos"></td>
                    <td>-</td>
                    <td>-</td>
                </tr>
            </tbody>
        </table>

        <div id="loader-container">
            <span class="loader"></span>
        </div>

        <py-script>
            # Download the pygafro wheel
            import micropip
            from pyscript import document
            parts = document.location.pathname.split('/')
            url = document.location.origin + '/'.join(parts[:-2]) + '/wasm/pygafro-1.3.0-cp312-cp312-pyodide_2024_0_wasm32.whl'
            await micropip.install(url)
            
            from pyscript import display
            import numpy as np
            import matplotlib.pyplot as plt
            from matplotlib.ticker import MaxNLocator
            from mpl_toolkits.mplot3d.art3d import Poly3DCollection
            from js import document

            from pygafro import FrankaEmikaRobot
            from pygafro import Plane
            from pygafro import Point
            from pygafro import SingleManipulatorTarget


            # Display a point in a row of the table
            def displayPoint(point, prefix):
                p = point.getEuclideanPoint()
                document.getElementById(f'{prefix}_mv').textContent = str(point)
                document.getElementById(f'{prefix}_pos').textContent = f'{p[0]:.3}, {p[1]:.3}, {p[2]:.3}'


            # Display a plane in a row of the table
            def displayPlane(plane, prefix):
                dual = plane.dual()

                n = np.array([dual['e1'], dual['e2'], dual['e3']])
                l = np.linalg.norm(n)

                n = n / l
                dist = dual['ei'] / l

                document.getElementById(f'{prefix}_mv').textContent = str(plane)
                document.getElementById(f'{prefix}_normal').textContent = f'{n[0]:.3}, {n[1]:.3}, {n[2]:.3}'
                document.getElementById(f'{prefix}_dist').textContent = f'{dist:.3}'


            # Display a point in the 3D plot
            def drawPoint(ax, point, s=20, facecolors=None, edgecolors=None, color=None, label=None):
                p = point.getEuclideanPoint()
                ax.scatter(p[0], p[1], p[2], s=s, facecolors=facecolors, edgecolors=edgecolors, color=color, label=label)


            # Display a plane in the 3D plot
            def drawPlane(ax, plane, color=None, label=None):
                dual = plane.dual()

                n = np.array([dual['e1'], dual['e2'], dual['e3']])
                l = np.linalg.norm(n)

                n = n / l
                dist = dual['ei'] / l

                v = np.array([1, 0, 0])
                if np.linalg.norm(n - v) < 1e-6:
                    v = np.array([0, 1, 0])

                v1 = np.cross(n, v)
                v2 = np.cross(n, v1)

                points = [ p[0] * v1 + p[1] * v2 + dist * n for p in [(-1, -1), (-1, 1), (1, 1), (1, -1), (-1, -1)] ]
                points = [ [min(0.5, max(-0.5, x)), min(1.0, max(0.0, y)), min(1.0, max(0.0, z))] for x, y, z in points ]

                points = np.array([points])
                poly = Poly3DCollection(points, alpha=.3, color=color)
                ax.add_collection3d(poly)


            # Create the robot
            panda = FrankaEmikaRobot()

            # Initial robot state
            x = [0.5, -0.3, 0.0, -1.8, 0.0, 1.5, 1.0]
            start_point = panda.getEEMotor(x).apply(Point())

            # Target plane
            target_plane = Plane.YZ(-0.2)

            # Create the cost function
            cost_function = SingleManipulatorTarget(panda, Point(), target_plane)

            # To store the values displayed in the plots
            costs = []
            update_norms = []
            positions = [start_point.getEuclideanPoint()]

            # Gauss-Newton algorithm to find the inverse kinematics
            cost = np.linalg.norm(cost_function.getError(x))

            for i in range(100):
                gradient, hessian = cost_function.getGradientAndHessian(x)

                update = -(np.linalg.inv(hessian + 1e-5 * np.eye(7)) @ gradient)

                # line search
                iter = 1
                c = cost
                alpha = 2.0

                while (c >= cost) and (iter < 20):
                    alpha *= 0.5
                    xk = x + alpha * update
                    c = np.linalg.norm(cost_function.getError(xk))
                    iter += 1

                update = alpha * update

                if (np.linalg.norm(update) < 1e-10) or np.isnan(update).any():
                    break

                x = x + update

                if np.isnan(x).any():
                    break

                cost = np.linalg.norm(cost_function.getError(x))

                print(f"iteration: {i} -> cost: {cost}, update norm: {np.linalg.norm(update)}")

                costs.append(cost)
                update_norms.append(np.linalg.norm(update))
                positions.append(panda.getEEMotor(x).apply(Point()).getEuclideanPoint())

                if cost < 1e-10:
                    break


            # Display the results
            displayPoint(start_point, 'start')
            displayPlane(target_plane, 'target')
            displayPoint(panda.getEEMotor(x).apply(Point()), 'solution')

            document.getElementById('results').style.display = 'block'
            document.getElementById('loader-container').style.display = 'none';


            # Display the trajectory of the end-effector
            fig = plt.figure(layout='constrained', figsize=(12, 6))
            subfigs = fig.subfigures(1, 2, wspace=0.07)

            ax = subfigs[0].add_subplot(111, projection='3d')

            ax.plot([0, 1], [0, 0], [0, 0], color='r', alpha=0.5)
            ax.plot([0, 0], [0, 1], [0, 0], color='g', alpha=0.5)
            ax.plot([0, 0], [0, 0], [0, 1], color='b', alpha=0.5)

            drawPoint(ax, start_point, label='Start Point')
            drawPlane(ax, target_plane, color='g', label='Target Line')
            drawPoint(ax, panda.getEEMotor(x).apply(Point()), label='Solution Point')

            positions = np.array(positions)
            ax.plot(positions[:, 0], positions[:, 1], positions[:, 2], color='darkturquoise', label='Trajectory')

            ax.set_xlim(-0.5, 0.5)
            ax.set_ylim(0, 1)
            ax.set_zlim(0, 1)
            ax.set_xlabel('X')
            ax.set_ylabel('Y')
            ax.set_zlabel('Z')

            ax.legend()

            ax.view_init(elev=30., azim=60)


            # Display the evolution of the cost and the update norm
            axes = subfigs[1].subplots(2, 1)

            axes[0].set_title('Cost')
            axes[0].set_xlabel('Iteration')
            axes[0].set_yscale('log')
            axes[0].set_xmargin(0)
            axes[0].xaxis.set_major_locator(MaxNLocator(integer=True))
            axes[0].grid(True)
            axes[0].plot(list(range(len(costs))), costs)

            axes[1].set_title('Update norm')
            axes[1].set_xlabel('Iteration')
            axes[1].set_yscale('log')
            axes[1].set_xmargin(0)
            axes[1].xaxis.set_major_locator(MaxNLocator(integer=True))
            axes[1].grid(True)
            axes[1].plot(list(range(len(update_norms))), update_norms)

            display(fig)
        </py-script>
    </body>
</html>
