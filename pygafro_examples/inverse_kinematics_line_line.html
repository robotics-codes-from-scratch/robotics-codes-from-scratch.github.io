<!--
    SPDX-FileCopyrightText: Copyright Â© 2025 Idiap Research Institute <contact@idiap.ch>

    SPDX-FileContributor: Philip Abbet <philip.abbet@idiap.ch>

    SPDX-License-Identifier: MPL-2.0
-->

<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0">

        <link rel="stylesheet" href="https://pyscript.net/releases/2024.8.2/core.css">
        <script type="module" src="https://pyscript.net/releases/2024.8.2/core.js"></script>

        <link rel="stylesheet" href="../css/loader.css"/>

        <py-config type="toml">
            packages = [
                'numpy',
                'matplotlib',
                
            ]
        </py-config>

        <style>
            table {
                border-collapse: collapse;
                margin-bottom: 20px;
            }

            th {
                background-color: rgb(50, 50, 50);
                color: white;
            }

            td, th {
                border: 1px solid rgb(50, 50, 50);
                padding-right: 10px;
                padding-left: 10px;
                padding-top: 4px;
                padding-bottom: 4px;
            }

            td:first-child {
                background-color: lightgray;
            }
        </style>
    </head>

    <body style="font-family: monospace;">
        <h2>Inverse kinematics: Line to Line</h2>
        <p>Robot: Franka Emika Panda</p>

        <table id="results" style="display: none;">
            <thead>
                <tr>
                    <th>Value</th>
                    <th>Multivector</th>
                    <th>Origin (x, y, z)</th>
                    <th>Direction (x, y, z)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Start Line</td>
                    <td id="start_mv"></td>
                    <td id="start_pos"></td>
                    <td id="start_dir"></td>
                </tr>
                <tr>
                    <td>Target Line</td>
                    <td id="target_mv"></td>
                    <td id="target_pos"></td>
                    <td id="target_dir"></td>
                </tr>
                <tr>
                    <td>Solution Line</td>
                    <td id="solution_mv"></td>
                    <td id="solution_pos"></td>
                    <td id="solution_dir"></td>
                </tr>
            </tbody>
        </table>

        <div id="loader-container">
            <span class="loader"></span>
        </div>

        <py-script>
            # Download the pygafro wheel
            import micropip
            from pyscript import document
            parts = document.location.pathname.split('/')
            url = document.location.origin + '/'.join(parts[:-2]) + '/wasm/pygafro-1.3.0-cp312-cp312-pyodide_2024_0_wasm32.whl'
            await micropip.install(url)
            
            from pyscript import display
            import numpy as np
            import matplotlib.pyplot as plt
            from matplotlib.ticker import MaxNLocator
            from js import document

            from pygafro import FrankaEmikaRobot
            from pygafro import Line
            from pygafro import Point
            from pygafro import SingleManipulatorDualTarget


            # Display a line in a row of the table
            def displayLine(line, prefix):
                d = np.array([line['e01i'], line['e02i'], line['e03i']])
                d = d / np.linalg.norm(d)

                m = [line['e23i'], -line['e13i'], line['e12i']]
                o = np.cross(d, m)

                document.getElementById(f'{prefix}_mv').textContent = str(line)
                document.getElementById(f'{prefix}_pos').textContent = f'{o[0]:.3}, {o[1]:.3}, {o[2]:.3}'
                document.getElementById(f'{prefix}_dir').textContent = f'{d[0]:.3}, {d[1]:.3}, {d[2]:.3}'


            # Display a point in the 3D plot
            def drawPoint(ax, point, s=20, facecolors=None, edgecolors=None, color=None, label=None):
                p = point.getEuclideanPoint()
                ax.scatter(p[0], p[1], p[2], s=s, facecolors=facecolors, edgecolors=edgecolors, color=color, label=label)


            # Display a line in the 3D plot
            def drawLine(ax, line, color=None, label=None):
                d = np.array([line['e01i'], line['e02i'], line['e03i']])
                d = d / np.linalg.norm(d)

                m = [line['e23i'], -line['e13i'], line['e12i']]
                o = np.cross(d, m)

                points = np.array([ o + t * d for t in np.linspace(-1.0, 1.0) ])
                ax.plot(points[:, 0], points[:, 1], points[:, 2], color=color, linestyle='dashed', label=label)


            # Create the robot
            panda = FrankaEmikaRobot()

            # Initial robot state
            x = [0.5, -0.3, 0.0, -1.8, 0.0, 1.5, 1.0]

            tool_line = Line(Point(), Point(0.0, 0.0, -1.0))

            start_point = panda.getEEMotor(x).apply(Point())
            start_line = panda.getEEMotor(x).apply(tool_line)

            # Target line
            target_point = Point(-0.2, 0.6, 0.65)
            target_dir = [0.0, 0.707, -0.707]

            ee_target_line = Line(
                target_point,
                Point(
                    target_point['e1'] + target_dir[0],
                    target_point['e2'] + target_dir[1],
                    target_point['e3'] + target_dir[2]
                )
            )

            # Create the cost function
            cost_function = SingleManipulatorDualTarget(panda, tool_line, ee_target_line)

            # To store the values displayed in the plots
            costs = []
            update_norms = []
            positions = [start_point.getEuclideanPoint()]

            # Gauss-Newton algorithm to find the inverse kinematics
            cost = np.linalg.norm(cost_function.getError(x))

            for i in range(100):
                gradient, hessian = cost_function.getGradientAndHessian(x)

                update = -(np.linalg.inv(hessian + 1e-5 * np.eye(7)) @ gradient)

                # line search
                iter = 1
                c = cost
                alpha = 2.0

                while (c >= cost) and (iter < 20):
                    alpha *= 0.5
                    xk = x + alpha * update
                    c = np.linalg.norm(cost_function.getError(xk))
                    iter += 1

                update = alpha * update

                if (np.linalg.norm(update) < 1e-10) or np.isnan(update).any():
                    break

                x = x + update

                if np.isnan(x).any():
                    break

                cost = np.linalg.norm(cost_function.getError(x))

                print(f"iteration: {i} -> cost: {cost}, update norm: {np.linalg.norm(update)}")

                costs.append(cost)
                update_norms.append(np.linalg.norm(update))
                positions.append(panda.getEEMotor(x).apply(Point()).getEuclideanPoint())

                if cost < 1e-10:
                    break


            # Display the results
            displayLine(start_line, 'start')
            displayLine(ee_target_line, 'target')
            displayLine(panda.getEEMotor(x).apply(tool_line), 'solution')

            document.getElementById('results').style.display = 'block'
            document.getElementById('loader-container').style.display = 'none';


            # Display the trajectory of the end-effector
            fig = plt.figure(layout='constrained', figsize=(12, 6))
            subfigs = fig.subfigures(1, 2, wspace=0.07)

            ax = subfigs[0].add_subplot(111, projection='3d')

            ax.plot([0, 1], [0, 0], [0, 0], color='r', alpha=0.5)
            ax.plot([0, 0], [0, 1], [0, 0], color='g', alpha=0.5)
            ax.plot([0, 0], [0, 0], [0, 1], color='b', alpha=0.5)

            drawPoint(ax, start_point, label='Start Point')
            drawLine(ax, start_line, label='Start Line')
            drawLine(ax, ee_target_line, color='g', label='Target Line')
            drawPoint(ax, panda.getEEMotor(x).apply(Point()), label='Solution Point')
            drawLine(ax, panda.getEEMotor(x).apply(tool_line), label='Solution Line')

            positions = np.array(positions)
            ax.plot(positions[:, 0], positions[:, 1], positions[:, 2], color='darkturquoise', label='Trajectory')

            ax.set_xlim(-0.5, 0.5)
            ax.set_ylim(0, 1)
            ax.set_zlim(0, 1)
            ax.set_xlabel('X')
            ax.set_ylabel('Y')
            ax.set_zlabel('Z')

            ax.legend()

            ax.view_init(elev=30., azim=60)


            # Display the evolution of the cost and the update norm
            axes = subfigs[1].subplots(2, 1)

            axes[0].set_title('Cost')
            axes[0].set_xlabel('Iteration')
            axes[0].set_yscale('log')
            axes[0].set_xmargin(0)
            axes[0].xaxis.set_major_locator(MaxNLocator(integer=True))
            axes[0].grid(True)
            axes[0].plot(list(range(len(costs))), costs)

            axes[1].set_title('Update norm')
            axes[1].set_xlabel('Iteration')
            axes[1].set_yscale('log')
            axes[1].set_xmargin(0)
            axes[1].xaxis.set_major_locator(MaxNLocator(integer=True))
            axes[1].grid(True)
            axes[1].plot(list(range(len(update_norms))), update_norms)

            display(fig)
        </py-script>
    </body>
</html>
