<!--
    SPDX-FileCopyrightText: Copyright Â© 2025 Idiap Research Institute <contact@idiap.ch>

    SPDX-FileContributor: Philip Abbet <philip.abbet@idiap.ch>

    SPDX-License-Identifier: MPL-2.0
-->

<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0">

        <link rel="stylesheet" href="https://pyscript.net/releases/2024.8.2/core.css">
        <script type="module" src="https://pyscript.net/releases/2024.8.2/core.js"></script>

        <link rel="stylesheet" href="../css/loader.css"/>

        <py-config type="toml">
            packages = [
                'numpy',
                'matplotlib',
                
            ]
        </py-config>

        <style>
            table {
                border-collapse: collapse;
                margin-bottom: 20px;
            }

            th {
                background-color: rgb(50, 50, 50);
                color: white;
            }

            td, th {
                border: 1px solid rgb(50, 50, 50);
                padding-right: 10px;
                padding-left: 10px;
                padding-top: 4px;
                padding-bottom: 4px;
            }

            td:first-child {
                background-color: lightgray;
            }
        </style>
    </head>

    <body style="font-family: monospace;">
        <h2>Inverse kinematics: Motor</h2>
        <p>Robot: Franka Emika Panda</p>

        <table id="results" style="display: none;">
            <thead>
                <tr>
                    <th>Value</th>
                    <th>Multivector</th>
                    <th>Position (x, y, z)</th>
                    <th>Quaternion (w, x, y, z)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Start Motor</td>
                    <td id="start_mv"></td>
                    <td id="start_pos"></td>
                    <td id="start_quat"></td>
                </tr>
                <tr>
                    <td>Target Motor</td>
                    <td id="target_mv"></td>
                    <td id="target_pos"></td>
                    <td id="target_quat"></td>
                </tr>
                <tr>
                    <td>Solution Motor</td>
                    <td id="solution_mv"></td>
                    <td id="solution_pos"></td>
                    <td id="solution_quat"></td>
                </tr>
            </tbody>
        </table>

        <div id="loader-container">
            <span class="loader"></span>
        </div>

        <py-script>
            # Download the pygafro wheel
            import micropip
            from pyscript import document
            parts = document.location.pathname.split('/')
            url = document.location.origin + '/'.join(parts[:-2]) + '/wasm/pygafro-1.3.0-cp312-cp312-pyodide_2024_0_wasm32.whl'
            await micropip.install(url)
            
            from pyscript import display
            import numpy as np
            import matplotlib.pyplot as plt
            from matplotlib.ticker import MaxNLocator
            from js import document

            from pygafro import FrankaEmikaRobot
            from pygafro import SingleManipulatorMotorCost
            from pygafro import Motor
            from pygafro import Translator
            from pygafro import TranslatorGenerator
            from pygafro import Rotor
            from pygafro import Point


            # Display a point in a row of the table
            def displayMotor(motor, prefix):
                p = motor.getTranslator().toTranslationVector()
                q = motor.getRotor().quaternion()
                document.getElementById(f'{prefix}_mv').textContent = str(motor)
                document.getElementById(f'{prefix}_pos').textContent = f'{p[0]:.3}, {p[1]:.3}, {p[2]:.3}'
                document.getElementById(f'{prefix}_quat').textContent = f'{q[0]:.3}, {q[1]:.3}, {q[2]:.3}, {q[3]:.3}'

            
            # Display a motor in the 3D plot
            def drawMotor(ax, motor, s=20, facecolors=None, edgecolors=None, label=None):
                p = motor.getTranslator().toTranslationVector()
                ax.scatter(p[0], p[1], p[2], s=s, facecolors=facecolors, edgecolors=edgecolors, label=label)

                rotor = motor.getRotor()

                px = rotor.apply(Point(0.1, 0.0, 0.0)).getEuclideanPoint()
                py = rotor.apply(Point(0.0, 0.1, 0.0)).getEuclideanPoint()
                pz = rotor.apply(Point(0.0, 0.0, 0.1)).getEuclideanPoint()

                ax.plot([p[0], p[0] + px[0]], [p[1], p[1] + px[1]], [p[2], p[2] + px[2]], color='r', alpha=0.5)
                ax.plot([p[0], p[0] + py[0]], [p[1], p[1] + py[1]], [p[2], p[2] + py[2]], color='g', alpha=0.5)
                ax.plot([p[0], p[0] + pz[0]], [p[1], p[1] + pz[1]], [p[2], p[2] + pz[2]], color='b', alpha=0.5)


            # Create the robot
            panda = FrankaEmikaRobot()

            # Initial robot state
            x = [0.5, -0.3, 0.0, -1.8, 0.0, 1.5, 1.0]
            start_motor = panda.getEEMotor(x)

            # Target motor
            ee_target_motor = Motor(
                Translator.exp(TranslatorGenerator([-0.2, 0.6, 0.65])),
                Rotor.fromQuaternion([-0.44217198, 0.51251752, 0.5728137, 0.4622707])
            )

            # Create the cost function
            cost_function = SingleManipulatorMotorCost(panda, ee_target_motor)

            # To store the values displayed in the plots
            costs = []
            update_norms = []
            motors = [start_motor]

            # Gauss-Newton algorithm to find the inverse kinematics
            cost = np.linalg.norm(cost_function.getError(x))

            for i in range(100):
                gradient, hessian = cost_function.getGradientAndHessian(x)

                update = -(np.linalg.inv(hessian + 1e-5 * np.eye(7)) @ gradient)

                # line search
                iter = 1
                c = cost
                alpha = 1.0

                while (c >= cost) and (iter < 20):
                    alpha *= 0.5
                    xk = x + alpha * update
                    c = np.linalg.norm(cost_function.getError(xk))
                    iter += 1

                update = alpha * update

                if (np.linalg.norm(update) < 1e-10) or np.isnan(update).any():
                    break

                x = x + update

                if np.isnan(x).any():
                    break

                cost = np.linalg.norm(cost_function.getError(x))

                print(f"iteration: {i} -> cost: {cost}, update norm: {np.linalg.norm(update)}")

                costs.append(cost)
                update_norms.append(np.linalg.norm(update))
                motors.append(panda.getEEMotor(x))

                if cost < 1e-10:
                    break


            # Display the results
            displayMotor(start_motor, 'start')
            displayMotor(ee_target_motor, 'target')
            displayMotor(panda.getEEMotor(x), 'solution')

            document.getElementById('results').style.display = 'block'
            document.getElementById('loader-container').style.display = 'none';


            # Display the trajectory of the end-effector
            fig = plt.figure(layout='constrained', figsize=(12, 6))
            subfigs = fig.subfigures(1, 2, wspace=0.07)

            ax = subfigs[0].add_subplot(111, projection='3d')

            ax.plot([0, 1], [0, 0], [0, 0], color='r', alpha=0.5)
            ax.plot([0, 0], [0, 1], [0, 0], color='g', alpha=0.5)
            ax.plot([0, 0], [0, 0], [0, 1], color='b', alpha=0.5)

            drawMotor(ax, start_motor, label='Start Motor')
            drawMotor(ax, ee_target_motor, s=50, facecolors='none', edgecolors='g', label='Target Motor')
            drawMotor(ax, panda.getEEMotor(x), label='Solution Motor')

            positions = np.array([ m.getTranslator().toTranslationVector() for m in motors ])
            ax.plot(positions[:, 0], positions[:, 1], positions[:, 2], color='darkturquoise', label='Trajectory')

            ax.set_xlim(-0.5, 0.5)
            ax.set_ylim(0, 1)
            ax.set_zlim(0, 1)
            ax.set_xlabel('X')
            ax.set_ylabel('Y')
            ax.set_zlabel('Z')

            ax.legend()

            ax.view_init(elev=30., azim=60)


            # Display the evolution of the cost and the update norm
            axes = subfigs[1].subplots(2, 1)

            axes[0].set_title('Cost')
            axes[0].set_xlabel('Iteration')
            axes[0].set_yscale('log')
            axes[0].set_xmargin(0)
            axes[0].xaxis.set_major_locator(MaxNLocator(integer=True))
            axes[0].grid(True)
            axes[0].plot(list(range(len(costs))), costs)

            axes[1].set_title('Update norm')
            axes[1].set_xlabel('Iteration')
            axes[1].set_yscale('log')
            axes[1].set_xmargin(0)
            axes[1].xaxis.set_major_locator(MaxNLocator(integer=True))
            axes[1].grid(True)
            axes[1].plot(list(range(len(update_norms))), update_norms)

            display(fig)
        </py-script>
    </body>
</html>
