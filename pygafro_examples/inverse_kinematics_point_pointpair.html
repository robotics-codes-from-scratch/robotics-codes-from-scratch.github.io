<!--
    SPDX-FileCopyrightText: Copyright Â© 2025 Idiap Research Institute <contact@idiap.ch>

    SPDX-FileContributor: Philip Abbet <philip.abbet@idiap.ch>

    SPDX-License-Identifier: MPL-2.0
-->

<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0">

        <link rel="stylesheet" href="https://pyscript.net/releases/2024.8.2/core.css">
        <script type="module" src="https://pyscript.net/releases/2024.8.2/core.js"></script>

        <link rel="stylesheet" href="../css/loader.css"/>

        <py-config type="toml">
            packages = [
                'numpy',
                'matplotlib',
                
            ]
        </py-config>

        <style>
            table {
                border-collapse: collapse;
                margin-bottom: 20px;
            }

            th {
                background-color: rgb(50, 50, 50);
                color: white;
            }

            td, th {
                border: 1px solid rgb(50, 50, 50);
                padding-right: 10px;
                padding-left: 10px;
                padding-top: 4px;
                padding-bottom: 4px;
            }

            td:first-child {
                background-color: lightgray;
            }
        </style>
    </head>

    <body style="font-family: monospace;">
        <h2>Inverse kinematics: Point to PointPair</h2>
        <p>Robot: Franka Emika Panda</p>

        <table id="results" style="display: none;">
            <thead>
                <tr>
                    <th>Value</th>
                    <th>Multivector</th>
                    <th>Position (x, y, z)</th>
                    <th>Position 2 (x, y, z)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Start Point</td>
                    <td id="start_mv"></td>
                    <td id="start_pos"></td>
                    <td>-</td>
                </tr>
                <tr>
                    <td>Target PointPair</td>
                    <td id="target_mv"></td>
                    <td id="target_pos"></td>
                    <td id="target_pos2"></td>
                </tr>
                <tr>
                    <td>Solution Point</td>
                    <td id="solution_mv"></td>
                    <td id="solution_pos"></td>
                    <td>-</td>
                </tr>
            </tbody>
        </table>

        <div id="loader-container">
            <span class="loader"></span>
        </div>

        <py-script>
            # Download the pygafro wheel
            import micropip
            from pyscript import document
            parts = document.location.pathname.split('/')
            url = document.location.origin + '/'.join(parts[:-2]) + '/wasm/pygafro-1.3.0-cp312-cp312-pyodide_2024_0_wasm32.whl'
            await micropip.install(url)
            
            from pyscript import display
            import numpy as np
            import matplotlib.pyplot as plt
            from matplotlib.ticker import MaxNLocator
            from js import document

            from pygafro import FrankaEmikaRobot
            from pygafro import Point
            from pygafro import PointPair
            from pygafro import SingleManipulatorTarget


            # Display a point in a row of the table
            def displayPoint(point, prefix):
                p = point.getEuclideanPoint()
                document.getElementById(f'{prefix}_mv').textContent = str(point)
                document.getElementById(f'{prefix}_pos').textContent = f'{p[0]:.3}, {p[1]:.3}, {p[2]:.3}'


            # Display a point pair in a row of the table
            def displayPointPair(pair, prefix):
                p1 = pair.getPoint1().getEuclideanPoint()
                p2 = pair.getPoint2().getEuclideanPoint()
                document.getElementById(f'{prefix}_mv').textContent = str(pair)
                document.getElementById(f'{prefix}_pos').textContent = f'{p1[0]:.3}, {p1[1]:.3}, {p1[2]:.3}'
                document.getElementById(f'{prefix}_pos2').textContent = f'{p2[0]:.3}, {p2[1]:.3}, {p2[2]:.3}'


            # Display a point in the 3D plot
            def drawPoint(ax, point, s=20, facecolors=None, edgecolors=None, marker=None, label=None):
                p = point.getEuclideanPoint()
                ax.scatter(p[0], p[1], p[2], s=s, facecolors=facecolors, edgecolors=edgecolors, marker=marker, label=label)


            # Display a point pair in the 3D plot
            def drawPointPair(ax, pair, s=20, facecolors=None, edgecolors=None, marker=None, label=None):
                drawPoint(ax, pair.getPoint1(), s=s, facecolors=facecolors, edgecolors=edgecolors, marker=marker, label=label)
                drawPoint(ax, pair.getPoint2(), s=s, facecolors=facecolors, edgecolors=edgecolors, marker=marker)


            # Create the robot
            panda = FrankaEmikaRobot()

            # Initial robot state
            x = [0.5, -0.3, 0.0, -1.8, 0.0, 1.5, 1.0]
            start_point = panda.getEEMotor(x).apply(Point())

            # Target point pair
            ee_target_pair = PointPair(
                Point(-0.2, 0.6, 0.65),
                Point(-0.2, 0.6, 0.55),
            )

            # Create the cost function
            cost_function = SingleManipulatorTarget(panda, Point(), ee_target_pair)

            # To store the values displayed in the plots
            costs = []
            update_norms = []
            positions = [start_point.getEuclideanPoint()]

            # Gauss-Newton algorithm to find the inverse kinematics
            cost = np.linalg.norm(cost_function.getError(x))

            for i in range(100):
                gradient, hessian = cost_function.getGradientAndHessian(x)

                update = -(np.linalg.inv(hessian + 1e-5 * np.eye(7)) @ gradient)

                # line search
                iter = 1
                c = cost
                alpha = 2.0

                while (c >= cost) and (iter < 20):
                    alpha *= 0.5
                    xk = x + alpha * update
                    c = np.linalg.norm(cost_function.getError(xk))
                    iter += 1

                update = alpha * update

                if (np.linalg.norm(update) < 1e-10) or np.isnan(update).any():
                    break

                x = x + update

                if np.isnan(x).any():
                    break

                cost = np.linalg.norm(cost_function.getError(x))

                print(f"iteration: {i} -> cost: {cost}, update norm: {np.linalg.norm(update)}")

                costs.append(cost)
                update_norms.append(np.linalg.norm(update))
                positions.append(panda.getEEMotor(x).apply(Point()).getEuclideanPoint())

                if cost < 1e-10:
                    break


            # Display the results
            displayPoint(start_point, 'start')
            displayPointPair(ee_target_pair, 'target')
            displayPoint(panda.getEEMotor(x).apply(Point()), 'solution')

            document.getElementById('results').style.display = 'block'
            document.getElementById('loader-container').style.display = 'none';


            # Display the trajectory of the end-effector
            fig = plt.figure(layout='constrained', figsize=(12, 6))
            subfigs = fig.subfigures(1, 2, wspace=0.07)

            ax = subfigs[0].add_subplot(111, projection='3d')

            ax.plot([0, 1], [0, 0], [0, 0], color='r', alpha=0.5)
            ax.plot([0, 0], [0, 1], [0, 0], color='g', alpha=0.5)
            ax.plot([0, 0], [0, 0], [0, 1], color='b', alpha=0.5)

            drawPoint(ax, start_point, label='Start Point')
            drawPointPair(ax, ee_target_pair, s=50, facecolors='none', edgecolors='g', label='Target PointPair')
            drawPoint(ax, panda.getEEMotor(x).apply(Point()), marker='x', label='Solution Point')

            positions = np.array(positions)
            ax.plot(positions[:, 0], positions[:, 1], positions[:, 2], color='darkturquoise', label='Trajectory')

            ax.set_xlim(-0.5, 0.5)
            ax.set_ylim(0, 1)
            ax.set_zlim(0, 1)
            ax.set_xlabel('X')
            ax.set_ylabel('Y')
            ax.set_zlabel('Z')

            ax.legend()

            ax.view_init(elev=30., azim=60)


            # Display the evolution of the cost and the update norm
            axes = subfigs[1].subplots(2, 1)

            axes[0].set_title('Cost')
            axes[0].set_xlabel('Iteration')
            axes[0].set_yscale('log')
            axes[0].set_xmargin(0)
            axes[0].xaxis.set_major_locator(MaxNLocator(integer=True))
            axes[0].grid(True)
            axes[0].plot(list(range(len(costs))), costs)

            axes[1].set_title('Update norm')
            axes[1].set_xlabel('Iteration')
            axes[1].set_yscale('log')
            axes[1].set_xmargin(0)
            axes[1].xaxis.set_major_locator(MaxNLocator(integer=True))
            axes[1].grid(True)
            axes[1].plot(list(range(len(update_norms))), update_norms)

            display(fig)
        </py-script>
    </body>
</html>
