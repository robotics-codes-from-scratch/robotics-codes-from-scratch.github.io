<div class="row">
    <div class="col-sm-1"></div>

    <div class="col-sm-5">
        <h3>Challenge: Move the cube</h3>

        <editor id="editor" src="user_code"></editor>

        <div style="float: right; padding-right: 0.5em; padding-left:0.5em;">
            <i id="btn-open" title="Load the previously saved code" class="bi bi-folder2-open" style="cursor: pointer; display: none;"></i>
            <i id="btn-save" title="Save the code" class="bi bi-floppy" style="cursor: pointer;"></i>
        </div>

        <div style="margin-bottom: 10px;">
            <button class="btn btn-light btn-sm" type="button" data-bs-toggle="collapse" data-bs-target="#instructions" aria-expanded="false" aria-controls="instructions">
                Instructions
            </button>
        </div>

        <div id="instructions" class="collapse instructions show">
            <div class="card card-body">
                <h5>Task</h5>
                <p>Grab the red cube on the orange box and move it on top of the green one. The cube must stay
                on the green box for 5 seconds to complete the challenge.</p>

                <p>
                    The starting position and orientation of the red cube are chosen at random each
                    time the green run button is clicked.
                </p>

                <h5>API</h5>
                <p>The following functions are available:</p>
                <ul>
                    <li><code>fkin(x)</code>: Forward kinematics</li>
                    <li><code>Jkin(x)</code>: Jacobian computation</li>
                    <li><code>logmap(f, f0)</code>: Logarithmic map for $\mathbb{R}^3 \times \mathcal{S}^3$ manifold (with $e$ in tangent space)</li>
                    <li><code>logmap_S3(f, f0)</code>: Logarithmic map for $\mathcal{S}^3$ manifold (with $e$ in tangent space)</li>
                    <li><code>openGripper()</code></li>
                    <li><code>closeGripper()</code></li>
                    <li><code>isGripperOpen()</code></li>
                    <li><code>isGripperClosed()</code></li>
                    <li><code>isGripperHoldingSomeObject()</code></li>
                </ul>

                <p>Additionally, some variables are available:</p>
                <ul>
                    <li><code>cube_start_position</code>: Position of the red cube at the beginning <code>[px, py, pz]</code></li>
                    <li>
                        <code>cube_start_angle</code>: Angle (in radians) of the cube relative to
                        the X-axis of the scene (as would be returned by a computer vision algorithm)
                    </li>
                    <li><code>target_position</code>: Position to put the cube at (slightly above the center of the top of the green box, <code>[px, py, pz]</code>)</li>
                </ul>

                <p>The following modules are already imported:</p>
                <ul>
                    <li><code>import numpy as np</code></li>
                    <li><code>from scipy.spatial.transform import Rotation as R</code> (to work with quaternions)</li>
                    <li><code>import math</code></li>
                </ul>

                <h5>Control</h5>
                <p>Click on the green run button to execute the code.</p>
                <p>To rotate the camera, press the left mouse button and drag the mouse. The right mouse button let you translate the camera. The mouse wheel let you zoom in/out.</p>
            </div>
        </div>

        <pre id="errors" class="py-error"></pre>
        <pre id="output" class="py-output"></pre>
    </div>

    <div class="col-sm-6">
        <div class="sticky-sm-top" style="padding-top: 2rem;">
            <div id="viewer3d" style="width: 100%; height: 400px;"></div>
            <div id="success" style="display:none; position: absolute; top: 6rem; text-align: center; width: 100%; color: limegreen; font-size: 100px; font-weight: bold;">
                &#x2714;
            </div>
            <div style="font-size: 0.8em;">
                <input type="checkbox" id="show_axes" name="show_axes" checked>
                <label for="show_axes">Show axes</label>
            </div>
        </div>
    </div>
</div>


<script id="user_code" type="python">
    # Simple example, in which we perform two steps:
    #  1) Rotate the robot until the Y component of the gripper position
    #     is below a certain value
    #  2) Open the gripper

    # Variable to keep track of the current step
    task_step = 1


    def controlCommand(x, dt):
        global task_step

        # Step 1: Rotate the robot
        if task_step == 1:
            f = fkin(x)
            if f[1] > -0.3:
                return np.array([-0.1, 0, 0, 0, 0, 0, 0]) / dt  # Velocity in rad/s
            else:
                task_step = 2  # Switch to the next step

        # Step 2: Open the gripper
        elif task_step == 2:
            openGripper()
            task_step = 3  # Switch to the next step

        # By default: no movement
        return np.zeros(x.shape)  # Velocity in rad/s
</script>


<script id="user_code_solution" type="python">
    # The steps we'll follow to grab the cube and place it on the target
    STEP_GO_ON_TOP_OF_CUBE = 0
    STEP_ROTATE_GRIPPER = 1
    STEP_OPEN_GRIPPER = 2
    STEP_GO_DOWN = 3
    STEP_CLOSE_GRIPPER = 4
    STEP_GO_UP = 5
    STEP_GO_ON_TOP_OF_TARGET = 6
    STEP_GO_DOWN_ON_TARGET = 7
    STEP_RELEASE_CUBE = 8
    STEP_GO_UP_FINAL = 9


    class IK:
        """An helper class to perform Inverse Kinematics to reach a
        specific destination (position + orientation)
        """

        def __init__(self, destination, weights=None):
            self.destination = destination
            self.weights = weights
            self.last_errors = []

        def process(self, x, dt):
            """Returns the control command to apply to the robot
            """
            J = Jkin(x)
            f = fkin(x)

            # Position & orientation tracking (with weights)
            if self.weights is not None:
                Q = np.diag(self.weights)
                u = np.linalg.pinv(J.T @ Q @ J) @ J.T @ Q @ logmap(self.destination, f)

            # Position & orientation tracking
            else:
                u = np.linalg.pinv(J) @ logmap(self.destination, f)

            return 0.5 * u / dt  # Velocity in rad/s

        def done(self, x):
            """Indicates if the destination is reached

            We'll consider that if the difference between the
            position/orientation of the gripper and the destination
            didn't diminish significantly over 5 updates, then
            the destination is reached
            """

            # Compute the difference (by applying weights if needed)
            f = fkin(x)
            diff = logmap(self.destination, f)

            if self.weights is not None:
                diff = diff @ self.weights

            error = np.linalg.norm(diff)

            # Memorize the 5 last differences
            self.last_errors.append(error)
            if len(self.last_errors) < 6:
                return False

            self.last_errors = self.last_errors[1:]

            # Use the variance to determine if the diminution is still
            # significant
            return np.var(self.last_errors) < 1e-8


    # The variables we need to keep track of the current step
    step = None
    ik = None


    def controlCommand(x, dt):
        global step, ik

        # If an IK-based movement is in progress, continue it until
        # the destination is reached
        if (ik is not None) and not(ik.done(x)):
            return ik.process(x, dt)

        ik = None

        # At startup: we want to go above the cube, with the gripper
        # pointing down (using weighted IK: we don't care about the
        # rotation around the Z axis here, so the robot don't end
        # up in a convoluted configuration)
        if step is None:
            step = STEP_GO_ON_TOP_OF_CUBE
            destination = np.concatenate((
                cube_start_position,
                [
                    math.sin(math.pi / 2.0),
                    0.0,
                    0.0,
                    math.cos(math.pi / 2.0)
                ]
            ))
            destination[2] += 0.1
            ik = IK(destination, [1, 1, 1, 1, 1, 0])
            return ik.process(x, dt)

        # We are above the cube, now rotate the gripper to match the
        # orientation of the cube
        elif step == STEP_GO_ON_TOP_OF_CUBE:
            step = STEP_ROTATE_GRIPPER
            gripper_pose = fkin(x)

            orientation = R.from_quat([
                math.sin(math.pi / 2.0),
                0.0,
                0.0,
                math.cos(math.pi / 2.0)
            ])
            orientation *= R.from_euler('Z', cube_start_angle)

            destination = np.concatenate((
                gripper_pose[:3],
                orientation.as_quat()
            ))

            ik = IK(destination)
            return ik.process(x, dt)

        # We are above the cube and correctly oriented, now open the
        # gripper
        elif step == STEP_ROTATE_GRIPPER:
            robot.openGripper()
            step = STEP_OPEN_GRIPPER

        # Wait until the gripper is fully open before going down
        elif step == STEP_OPEN_GRIPPER:
            if robot.isGripperOpen:
                step = STEP_GO_DOWN
                gripper_pose = fkin(x)
                destination = np.concatenate((cube_start_position, gripper_pose[3:]))
                ik = IK(destination)
                return ik.process(x, dt)

        # Once at the cube location, close the gripper
        elif step == STEP_GO_DOWN:
            robot.closeGripper()
            step = STEP_CLOSE_GRIPPER

        # Wait until the gripper is holding the cube and go up again
        elif step == STEP_CLOSE_GRIPPER:
            if robot.isGripperHoldingSomeObject:
                step = STEP_GO_UP
                destination = fkin(x)
                destination[2] += 0.15
                ik = IK(destination)
                return ik.process(x, dt)

        # Once we lifted the cube, move on top of the target
        # (again using weighted IK)
        elif step == STEP_GO_UP:
            step = STEP_GO_ON_TOP_OF_TARGET
            destination = fkin(x)
            destination[:3] = target_position
            destination[2] += 0.15
            ik = IK(destination, [1, 1, 1, 1, 1, 0])
            return ik.process(x, dt)

        # Once above the target, go down
        elif step == STEP_GO_ON_TOP_OF_TARGET:
            step = STEP_GO_DOWN_ON_TARGET
            destination = fkin(x)
            destination[:3] = target_position
            ik = IK(destination)
            return ik.process(x, dt)

        # Once at the target, open the gripper
        elif step == STEP_GO_DOWN_ON_TARGET:
            robot.openGripper()
            step = STEP_RELEASE_CUBE

        # Once the cube is released, go up one last time
        elif step == STEP_RELEASE_CUBE:
            step = STEP_GO_UP_FINAL
            destination = fkin(x)
            destination[2] += 0.15
            ik = IK(destination)
            return ik.process(x, dt)

        # By default: no movement
        return np.zeros(x.shape)
</script>


<script id="page_code" type="python">
    from viewer3d import Viewer3D, configs, logmap_S3, logmap, readFile, writeFile
    from js import document, three
    from pyodide.ffi import create_proxy
    from rcfs import configure, displayError, setAspectRatio
    import numpy as np
    from scipy.spatial.transform import Rotation as R
    import math


    # The elements in the scene
    robot = None
    cube = None
    source_base = None
    target_base = None

    # Initial state of the elements in the scene
    initial_robot_joint_positions = None
    initial_cube_position = None
    initial_cube_orientation = None
    initial_source_base_position = None
    initial_source_base_orientation = None
    initial_target_base_position = None
    initial_target_base_orientation = None

    # Internal state
    targetReached = False
    targetReachedStartTime = None
    resetting = False

    # Variables available to the user
    cube_start_position = None
    cube_start_angle = None
    target_position = None

    cube_start_ref = None
    cube_start_angle_ref = None
    target_position_ref = None


    # The function that will be called once per frame
    def callback(delta, time):
        global cube_start_position, cube_start_angle, target_position, targetReached, \
               targetReachedStartTime, resetting

        if resetting:
            if robot.isGripperClosed:
                resetting = False
            return

        cube_start_position = np.copy(cube_start_ref[:3])
        cube_start_angle = cube_start_angle_ref
        target_position = np.copy(target_position_ref)

        try:
            x = robot.jointPositions
            u = np.array(controlCommand(x, delta))
            x += u * delta
            robot.control = x
        except Exception as e:
            displayError(e)

        pos = cube.position
        #reached = False
        reached = robot.isGripperOpen and \
                  (pos[0] > target_position_ref[0] - 0.1) and (pos[0] < target_position_ref[0] + 0.1) and \
                  (pos[1] > target_position_ref[1] - 0.1) and (pos[1] < target_position_ref[1] + 0.1) and \
                  (pos[2] > target_position_ref[2] - 0.03) and (pos[2] < target_position_ref[2] + 0.02)

        if reached:
            if not targetReached:
                targetReached = True
                targetReachedStartTime = time
            elif time - targetReachedStartTime > 5.0:
                viewer3D.physicsSimulatorPaused = False
                viewer3D.setRenderingCallback(None)
                document.getElementById('success').style.display = 'block'
        else:
            targetReached = False
            targetReachedStartTime = None


    # Reset the scene to its initial state and randomly place the cube on its base
    def reset():
        global targetReached, targetReachedStartTime, cube_start_ref, cube_start_angle_ref, \
               target_position_ref, resetting

        targetReached = False
        targetReachedStartTime = None
        resetting = True

        # Reset all the elements to their initial state
        robot.jointPositions = initial_robot_joint_positions
        robot.control = initial_robot_joint_positions

        source_base.position = initial_source_base_position
        source_base.orientation = initial_source_base_orientation

        target_base.position = initial_target_base_position
        target_base.orientation = initial_target_base_orientation

        # Randomly place the cube on its base
        position = np.copy(initial_cube_position)

        offset = np.random.rand(2) * 0.16 - 0.08
        position[:2] += offset

        cube_start_angle_ref = np.random.random() * math.pi / 2 - math.pi / 4

        orientation = R.from_quat(initial_cube_orientation)
        orientation *= R.from_euler('Z', cube_start_angle_ref)

        cube.position = position
        cube.orientation = orientation.as_quat()

        # Store the values we want the user to have access to
        cube_start_ref = np.concatenate((position, orientation.as_quat()))
        target_position_ref = np.array(initial_target_base_position) + [0, 0, 0.22]

        # Hide the success indicator
        document.getElementById('success').style.display = 'none'

        # Close the gripper
        robot.closeGripper()

        # Starts the physics simulation
        viewer3D.physicsSimulatorPaused = False
        viewer3D.setRenderingCallback(callback)


    # Resize the container of the Viewer3D to have a 1:1 aspect ratio
    setAspectRatio('viewer3d', 1.0)

    # Create the Viewer3D
    viewer3D = Viewer3D(
        document.getElementById('viewer3d'),
        {
            'external_loop': True,
        }
    )

    # Load the scene
    viewer3D.loadScene('/scenes/01.xml')
    viewer3D.translateCamera([0.0, 0.0, 0.3])

    # Retrieve the robot and its initial joint position
    robot = viewer3D.createRobot('panda', configs.Panda.new())
    initial_robot_joint_positions = robot.jointPositions

    # Retrieve the cube and its initial transforms
    cube = viewer3D.getPhysicalBody('cube')
    initial_cube_position = cube.position
    initial_cube_orientation = cube.orientation

    # Retrieve the bases and their initial transforms
    source_base = viewer3D.getPhysicalBody('source_base')
    initial_source_base_position = source_base.position
    initial_source_base_orientation = source_base.orientation

    target_base = viewer3D.getPhysicalBody('target_base')
    initial_target_base_position = target_base.position
    initial_target_base_orientation = target_base.orientation

    # Add some axes
    ee_axes = viewer3D.addAxes('ee_axes')
    robot.toolControlPoint.add(ee_axes)

    cube_axes = viewer3D.addAxes('cube_axes')
    cube_axes.object.lines[1].scale.set(0, 0, 0)
    cube_axes.object.lines[2].scale.set(0, 0, 0)
    cube.add(cube_axes)

    scene_axes = viewer3D.addAxes('scene_axes', length=1.0)

    # Disable the manipulations
    viewer3D.controlsEnabled = False

    reset()


    # Show/hide the axes
    def onShowAxesCheckboxClicked(event):
        ee_axes.object.visible = event.target.checked
        cube_axes.object.visible = event.target.checked
        scene_axes.object.visible = event.target.checked

    document.getElementById('show_axes').addEventListener('change', create_proxy(onShowAxesCheckboxClicked))


    # Placeholder for the function to implement
    def controlCommand(x, dt):
        return np.zeros(x.shape)

    # Forward kinematics function (allows to not care about 'robot' in the user code)
    def fkin(x):
        return robot.fkin(x)

    # Jacobian function (allows to not care about 'robot' in the user code)
    def Jkin(x):
        return robot.Jkin(x)

    # Function to open the gripper (allows to not care about 'robot' in the user code)
    def openGripper():
        robot.openGripper()

    # Function to close the gripper (allows to not care about 'robot' in the user code)
    def closeGripper():
        robot.closeGripper()

    # Function that indicates if the gripper is fully open (allows to not care about 'robot' in the user code)
    def isGripperOpen():
        return robot.isGripperOpen

    # Function that indicates if the gripper is fully closed (allows to not care about 'robot' in the user code)
    def isGripperClosed():
        return robot.isGripperClosed

    # Function that indicates if the gripper is holding an object (allows to not care about 'robot' in the user code)
    def isGripperHoldingSomeObject():
        return robot.isGripperHoldingSomeObject


    async def run():
        try:
            reset()
        except Exception as e:
            displayError(e)


    async def loop(delta, time):
        viewer3D.render()


    configure({
        'loop': loop,
        'run': run,
        'output': 'output',
        'errors': 'errors',
    })
</script>
