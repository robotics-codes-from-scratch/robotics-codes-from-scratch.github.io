<div class="row"><div class="col-sm-7 offset-1"><div id="txt-col"><h1 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section"><span class="ltx_text">8</span> </span><span class="ltx_text">iLQR optimization</span>
</h1><div class="ltx_para" id="S8-para:p1">
<p class="ltx_p">Optimal control problems are defined by a cost function <span class="ltx_Math" id="p1.m1">\sum_{t=1}^{T}c(\bm{x}_{t},\bm{u}_{t})</span> to minimize and a dynamical system <span class="ltx_Math" id="p1.m2">\bm{x}_{t+1}=\bm{d}(\bm{x}_{t},\bm{u}_{t})</span> describing the evolution of a state <span class="ltx_Math" id="p1.m3">\bm{x}_{t}</span> driven by control commands <span class="ltx_Math" id="p1.m4">\bm{u}_{t}</span> during a time window of length <span class="ltx_Math" id="p1.m5">T</span>.</p>
</div><div class="ltx_para" id="S8-para:p2">
<p class="ltx_p">Iterative LQR (iLQR) <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="#bib-bib:bib8" title="Iterative linear quadratic regulator design for nonlinear biological movement systems">8</a>]</cite> solves such constrained nonlinear models by carrying out Taylor expansions on the cost and on the dynamical system so that a solution can be found iteratively by solving a LQR problem at each iteration, similarly to differential dynamic programming approaches <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="#bib-bib:bib9" title="A second-order gradient method for determining optimal trajectories of non-linear discrete-time systems">11</a>, <a class="ltx_ref" href="#bib-bib:bib10" title="Differential dynamic programming">17</a>]</cite>.</p>
</div><div class="ltx_para" id="S8-para:p3">
<p class="ltx_p">iLQR employs a first order Taylor expansion of the dynamical system <span class="ltx_Math" id="p3.m1">\bm{x}_{t+1}=\bm{d}(\bm{x}_{t},\bm{u}_{t})</span> around the point <span class="ltx_Math" id="p3.m2">(\bm{\hat{x}}_{t},\bm{\hat{u}}_{t})</span>, namely</p>
<table class="ltx_equationgroup ltx_eqn_align ltx_eqn_table" id="S8-eq:A5.EGx22">
<tbody id="S8-eq:Ex70"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="Ex70.m1">\displaystyle\bm{x}_{t+1}</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="Ex70.m2">\displaystyle\approx\bm{d}(\bm{\hat{x}}_{t},\bm{\hat{u}}_{t})+\frac{\partial\bm{d}}{\partial\bm{x}_{t}}(\bm{x}_{t}-\bm{\hat{x}}_{t})+\frac{\partial\bm{d}}{\partial\bm{u}_{t}}(\bm{u}_{t}-\bm{\hat{u}}_{t})</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
<tbody id="S8-eq:DS"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="E91.m1">\displaystyle\iff\Delta\bm{x}_{t+1}</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="E91.m2">\displaystyle\approx\bm{A}_{t}\Delta\bm{x}_{t}+\bm{B}_{t}\Delta\bm{u}_{t},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(91)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">with residual vectors</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex71">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex71.m1">\Delta\bm{x}_{t}\!=\!\bm{x}_{t}\!-\!\bm{\hat{x}}_{t},\quad\Delta\bm{u}_{t}\!=\!\bm{u}_{t}\!-\!\bm{\hat{u}}_{t},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">and Jacobian matrices</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex72">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex72.m1">\bm{A}_{t}=\frac{\partial\bm{d}}{\partial\bm{x}_{t}}\Big|_{\bm{\hat{x}}_{t},\bm{\hat{u}}_{t}},\quad\bm{B}_{t}=\frac{\partial\bm{d}}{\partial\bm{u}_{t}}\Big|_{\bm{\hat{x}}_{t},\bm{\hat{u}}_{t}}.</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div><div class="ltx_para" id="S8-para:p4">
<p class="ltx_p">The cost function <span class="ltx_Math" id="p4.m1">c(\bm{x}_{t},\bm{u}_{t})</span> for time step <span class="ltx_Math" id="p4.m2">t</span> can similarly be approximated by a second order Taylor expansion around the point <span class="ltx_Math" id="p4.m3">(\bm{\hat{x}}_{t},\bm{\hat{u}}_{t})</span>, namely</p>
<table class="ltx_equationgroup ltx_eqn_table" id="S8-eq:dc">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline" id="E92X">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="E92X.m2">\displaystyle c(\bm{x}_{t},\bm{u}_{t})</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="E92X.m3">\displaystyle\approx c(\bm{\hat{x}}_{t},\bm{\hat{u}}_{t})+\Delta\bm{x}_{t}^{\scriptscriptstyle\top}\frac{\partial c}{\partial\bm{x}_{t}}+\Delta\bm{u}_{t}^{\scriptscriptstyle\top}\frac{\partial c}{\partial\bm{u}_{t}}+\frac{1}{2}\Delta\bm{x}_{t}^{\scriptscriptstyle\top}\frac{\partial^{2}c}{\partial\bm{x}_{t}^{2}}\Delta\bm{x}_{t}+\Delta\bm{x}_{t}^{\scriptscriptstyle\top}\frac{\partial^{2}c}{\partial\bm{x}_{t}\bm{u}_{t}}\Delta\bm{u}_{t}+\frac{1}{2}\Delta\bm{u}_{t}^{\scriptscriptstyle\top}\frac{\partial^{2}c}{\partial\bm{u}_{t}^{2}}\Delta\bm{u}_{t},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="2"><span class="ltx_tag ltx_tag_equationgroup ltx_align_right">(92)</span></td>
</tr>
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline" id="E92Xa">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="E92Xa.m2">\displaystyle\iff c(\bm{x}_{t},\bm{u}_{t})</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="E92Xa.m3">\displaystyle\approx c(\bm{\hat{x}}_{t},\bm{\hat{u}}_{t})+\frac{1}{2}\begin{bmatrix}1\\
\Delta\bm{x}_{t}\\
\Delta\bm{u}_{t}\end{bmatrix}^{\!{\scriptscriptstyle\top}}\begin{bmatrix}0&amp;\bm{g}_{\bm{x},t}^{\scriptscriptstyle\top}&amp;\bm{g}_{\bm{u},t}^{\scriptscriptstyle\top}\\
\bm{g}_{\bm{x},t}&amp;\bm{H}_{\bm{x}\bm{x},t}&amp;\bm{H}_{\bm{u}\bm{x},t}^{\scriptscriptstyle\top}\\
\bm{g}_{\bm{u},t}&amp;\bm{H}_{\bm{u}\bm{x},t}&amp;\bm{H}_{\bm{u}\bm{u},t}\\
\end{bmatrix}\begin{bmatrix}1\\
\Delta\bm{x}_{t}\\
\Delta\bm{u}_{t}\end{bmatrix},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">with gradients</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex73">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex73.m1">\bm{g}_{\bm{x},t}=\frac{\partial c}{\partial\bm{x}_{t}}\Big|_{\bm{\hat{x}}_{t},\bm{\hat{u}}_{t}},\quad\bm{g}_{\bm{u},t}=\frac{\partial c}{\partial\bm{u}_{t}}\Big|_{\bm{\hat{x}}_{t},\bm{\hat{u}}_{t}},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">and Hessian matrices</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex74">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex74.m1">\bm{H}_{\bm{x}\bm{x},t}=\frac{\partial^{2}c}{\partial\bm{x}_{t}^{2}}\Big|_{\bm{\hat{x}}_{t},\bm{\hat{u}}_{t}},\quad\bm{H}_{\bm{u}\bm{u},t}=\frac{\partial^{2}c}{\partial\bm{u}_{t}^{2}}\Big|_{\bm{\hat{x}}_{t},\bm{\hat{u}}_{t}},\quad\bm{H}_{\bm{u}\bm{x},t}=\frac{\partial^{2}c}{\partial\bm{u}_{t}\partial\bm{x}_{t}}\Big|_{\bm{\hat{x}}_{t},\bm{\hat{u}}_{t}}.</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div><div class="ltx_subsection" id="S8-sec:iLQRbatch">
<h2 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span class="ltx_text">8.1</span> </span><span class="ltx_text">Batch formulation of iLQR</span>
</h2>
<div class="ltx_para" id="S8-para:SS1.p1">
<p class="ltx_p">A solution in batch form can be computed by minimizing over <span class="ltx_Math" id="SS1.p1.m1">\bm{u}\!=\!{\begin{bmatrix}\bm{u}_{1}^{\scriptscriptstyle\top},\bm{u}_{2}^{\scriptscriptstyle\top},\ldots,\bm{u}_{T-1}^{\scriptscriptstyle\top}\end{bmatrix}}^{\scriptscriptstyle\top}</span>, yielding a series of open loop control commands <span class="ltx_Math" id="SS1.p1.m2">\bm{u}_{t}</span>, corresponding to a Gauss–Newton iteration scheme, see Section <a class="ltx_ref" href="#S3-sec:GaussNewton" title="3.1 Gauss–Newton algorithm ‣ 3 Newton’s method for minimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">3.1</span></a>.</p>
</div>
<div class="ltx_para" id="S8-para:SS1.p2">
<p class="ltx_p">At a trajectory level, we denote <span class="ltx_Math" id="SS1.p2.m1">\bm{x}\!=\!{\begin{bmatrix}\bm{x}_{1}^{\scriptscriptstyle\top},\bm{x}_{2}^{\scriptscriptstyle\top},\ldots,\bm{x}_{T}^{\scriptscriptstyle\top}\end{bmatrix}}^{\scriptscriptstyle\top}</span> the evolution of the state and <span class="ltx_Math" id="SS1.p2.m2">\bm{u}\!=\!{\begin{bmatrix}\bm{u}_{1}^{\scriptscriptstyle\top},\bm{u}_{2}^{\scriptscriptstyle\top},\ldots,\bm{u}_{T-1}^{\scriptscriptstyle\top}\end{bmatrix}}^{\scriptscriptstyle\top}</span> the evolution of the control commands.
The evolution of the state in (<a class="ltx_ref" href="#S8-eq:DS" title="(91) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">91</span></a>) becomes <span class="ltx_Math" id="SS1.p2.m3">\Delta\bm{x}=\bm{S}_{\bm{u}}\Delta\bm{u}</span>, see Appendix <a class="ltx_ref" href="#A1" title="Appendix A System dynamics at trajectory level ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">A</span></a> for details.<span class="ltx_note ltx_role_footnote" id="footnote1"><sup class="ltx_note_mark">1</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">1</sup><span class="ltx_tag ltx_tag_note">1</span>Note that <span class="ltx_Math" id="footnote1.m1">\bm{S}_{\bm{x}}\Delta\bm{x}_{1}\!=\!\bm{0}</span> because <span class="ltx_Math" id="footnote1.m2">\Delta\bm{x}_{1}\!=\!\bm{0}</span> (as we want our motion to start from <span class="ltx_Math" id="footnote1.m3">\bm{x}_{1}</span>).</span></span></span></p>
</div>
<div class="ltx_para" id="S8-para:SS1.p3">
<p class="ltx_p">The minimization problem can then be rewritten in batch form as</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:dc_batch">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E93.m1">\min_{\Delta\bm{u}}\Delta c(\Delta\bm{x},\Delta\bm{u}),\quad\text{s.t.}\quad\Delta\bm{x}=\bm{S}_{\bm{u}}\Delta\bm{u},\quad\text{where}\quad\Delta c(\Delta\bm{x},\Delta\bm{u})=\frac{1}{2}\begin{bmatrix}1\\
\Delta\bm{x}\\
\Delta\bm{u}\end{bmatrix}^{\!{\scriptscriptstyle\top}}\begin{bmatrix}0&amp;\bm{g}_{\bm{x}}^{\scriptscriptstyle\top}&amp;\bm{g}_{\bm{u}}^{\scriptscriptstyle\top}\\
\bm{g}_{\bm{x}}&amp;\bm{H}_{\bm{x}\bm{x}}&amp;\bm{H}_{\bm{u}\bm{x}}^{\scriptscriptstyle\top}\\
\bm{g}_{\bm{u}}&amp;\bm{H}_{\bm{u}\bm{x}}&amp;\bm{H}_{\bm{u}\bm{u}}\\
\end{bmatrix}\begin{bmatrix}1\\
\Delta\bm{x}\\
\Delta\bm{u}\end{bmatrix}.</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(93)</span></td>
</tr>
</table>
</div>
<div class="ltx_para" id="S8-para:SS1.p4">
<p class="ltx_p">By inserting the constraint into the cost, we obtain the optimization problem</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:minu">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E94.m1">\min_{\Delta\bm{u}}\quad\Delta\bm{u}^{\scriptscriptstyle\top}\bm{S}_{\bm{u}}^{\scriptscriptstyle\top}\bm{g}_{\bm{x}}+\Delta\bm{u}^{\scriptscriptstyle\top}\bm{g}_{\bm{u}}+\frac{1}{2}\Delta\bm{u}^{\scriptscriptstyle\top}\bm{S}_{\bm{u}}^{\scriptscriptstyle\top}\bm{H}_{\bm{x}\bm{x}}\bm{S}_{\bm{u}}\Delta\bm{u}+\Delta\bm{u}^{\scriptscriptstyle\top}\bm{S}_{\bm{u}}^{\scriptscriptstyle\top}\bm{H}_{\bm{u}\bm{x}}^{\scriptscriptstyle\top}\Delta\bm{u}+\frac{1}{2}\Delta\bm{u}^{\scriptscriptstyle\top}\bm{H}_{\bm{u}\bm{u}}\Delta\bm{u},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(94)</span></td>
</tr>
</table>
<p class="ltx_p">which can be solved analytically by differentiating with respect to <span class="ltx_Math" id="SS1.p4.m1">\Delta\bm{u}</span> and equating to zero, namely,</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:E95">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E95.m1">\bm{S}_{\bm{u}}^{\scriptscriptstyle\top}\bm{g}_{\bm{x}}+\bm{g}_{\bm{u}}+\\
\bm{S}_{\bm{u}}^{\scriptscriptstyle\top}\bm{H}_{\bm{x}\bm{x}}\bm{S}_{\bm{u}}\Delta\bm{u}+2\bm{S}_{\bm{u}}^{\scriptscriptstyle\top}\bm{H}_{\bm{u}\bm{x}}^{\scriptscriptstyle\top}\Delta\bm{u}+\bm{H}_{\bm{u}\bm{u}}\Delta\bm{u}=0,</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(95)</span></td>
</tr>
</table>
<p class="ltx_p">providing the least squares solution</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:du_general">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E96.m1">\Delta\bm{\hat{u}}={\left(\bm{S}_{\bm{u}}^{\scriptscriptstyle\top}\bm{H}_{\bm{x}\bm{x}}\bm{S}_{\bm{u}}+2\bm{S}_{\bm{u}}^{\scriptscriptstyle\top}\bm{H}_{\bm{u}\bm{x}}^{\scriptscriptstyle\top}+\bm{H}_{\bm{u}\bm{u}}\right)}^{-1}\left(-\bm{S}_{\bm{u}}^{\scriptscriptstyle\top}\bm{g}_{\bm{x}}-\bm{g}_{\bm{u}}\right),</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(96)</span></td>
</tr>
</table>
<p class="ltx_p">which can be used to update the control commands estimate at each iteration step of the iLQR algorithm.</p>
</div>
<div class="ltx_para" id="S8-para:SS1.p5">
<p class="ltx_p">The complete iLQR procedure is described in Algorithm <a class="ltx_ref" href="#S8-alg:iLQRbatch" title="Algorithm 4 ‣ 8.4 Updates by considering step sizes ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">4</span></a> (including backtracking line search). Figure <a class="ltx_ref" href="#S8-fig:iLQR_summary" title="Figure 17 ‣ 8.1 Batch formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">17</span></a> also presents an illustrative summary of the iLQR optimization procedure in batch form.</p>
</div>
</div><div class="ltx_subsection" id="S8-sec:iLQRrecursive">
<h2 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span class="ltx_text">8.2</span> </span><span class="ltx_text">Recursive formulation of iLQR</span>
</h2>
<div class="ltx_para" id="S8-para:SS2.p1">
<p class="ltx_p">A solution can alternatively be computed in a recursive form to provide a controller with feedback gains. Section <a class="ltx_ref" href="#S7-sec:LQRrecursive" title="7.4 LQR with a recursive formulation ‣ 7 Linear quadratic tracking (LQT) ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">7.4</span></a> presented the dynamic programming principle in the context of linear quadratic regulation problems, which allowed us to reduce the minimization over an entire sequence of control commands to a sequence of minimization problems over control commands at a single time step, by proceeding backwards in time. In this section, the approach is extended to iLQR.</p>
</div>
<div class="ltx_para" id="S8-para:SS2.p2">
<p class="ltx_p">Similarly to (<a class="ltx_ref" href="#S7-eq:qtLQR" title="(79) ‣ 7.4 LQR with a recursive formulation ‣ 7 Linear quadratic tracking (LQT) ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">79</span></a>), we have here</p>
<table class="ltx_equationgroup ltx_eqn_align ltx_eqn_table" id="S8-eq:A5.EGx23">
<tbody id="S8-eq:qtiLQR"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="E97.m1">\displaystyle\hat{v}_{t}(\Delta\bm{x}_{t})</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="E97.m2">\displaystyle=\min_{\Delta\bm{u}_{t}}\,\underbrace{c_{t}(\Delta\bm{x}_{t},\Delta\bm{u}_{t})+\hat{v}_{t+1}(\Delta\bm{x}_{t+1})}_{q_{t}(\Delta\bm{x}_{t},\Delta\bm{u}_{t})},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(97)</span></td>
</tr></tbody>
</table>
</div>
<div class="ltx_para" id="S8-para:SS2.p3">
<p class="ltx_p">Similarly to LQR, by starting from the last time step <span class="ltx_Math" id="SS2.p3.m1">T</span>, <span class="ltx_Math" id="SS2.p3.m2">\hat{v}_{T}(\Delta\bm{x}_{T})</span> is independent of the control commands. By relabeling <span class="ltx_Math" id="SS2.p3.m3">\bm{g}_{\bm{x},T}</span> and <span class="ltx_Math" id="SS2.p3.m4">\bm{H}_{\bm{x}\bm{x},T}</span> as <span class="ltx_Math" id="SS2.p3.m5">\bm{v}_{\bm{x},T}</span> and <span class="ltx_Math" id="SS2.p3.m6">\bm{V}_{\bm{x}\bm{x},T}</span>, we can show that <span class="ltx_Math" id="SS2.p3.m7">\hat{v}_{T-1}</span> has the same quadratic form as <span class="ltx_Math" id="SS2.p3.m8">\hat{v}_{T}</span>, enabling the backward recursive computation of <span class="ltx_Math" id="SS2.p3.m9">\hat{v}_{t}</span> from <span class="ltx_Math" id="SS2.p3.m10">t=T-1</span> to <span class="ltx_Math" id="SS2.p3.m11">t=1</span>.</p>
</div>
<div class="ltx_para" id="S8-para:SS2.p4">
<p class="ltx_p">This dynamic programming recursion takes the form</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:vhatTiLQR">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E98.m1">\hat{v}_{t+1}=\begin{bmatrix}1\\
\Delta\bm{x}_{t+1}\end{bmatrix}^{\!{\scriptscriptstyle\top}}\begin{bmatrix}0&amp;\bm{v}_{\bm{x},{t+1}}^{\scriptscriptstyle\top}\\
\bm{v}_{\bm{x},{t+1}}&amp;\bm{V}_{\bm{x}\bm{x},{t+1}}\end{bmatrix}\begin{bmatrix}1\\
\Delta\bm{x}_{t+1}\end{bmatrix},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(98)</span></td>
</tr>
</table>
<p class="ltx_p">and we then have with (<a class="ltx_ref" href="#S8-eq:qtiLQR" title="(97) ‣ 8.2 Recursive formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">97</span></a>) that</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:ct0iLQR">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E99.m1">\hat{v}_{t}=\min_{\Delta\bm{u}_{t}}\begin{bmatrix}1\\
\Delta\bm{x}_{t}\\
\Delta\bm{u}_{t}\end{bmatrix}^{\!{\scriptscriptstyle\top}}\begin{bmatrix}0&amp;\bm{g}_{\bm{x},{t}}^{\scriptscriptstyle\top}&amp;\bm{g}_{\bm{u},{t}}^{\scriptscriptstyle\top}\\
\bm{g}_{\bm{x},{t}}&amp;\bm{H}_{\bm{x}\bm{x},{t}}&amp;\bm{H}_{\bm{u}\bm{x},{t}}^{\scriptscriptstyle\top}\\
\bm{g}_{\bm{u},{t}}&amp;\bm{H}_{\bm{u}\bm{x},{t}}&amp;\bm{H}_{\bm{u}\bm{u},{t}}\\
\end{bmatrix}\begin{bmatrix}1\\
\Delta\bm{x}_{t}\\
\Delta\bm{u}_{t}\end{bmatrix}+\begin{bmatrix}1\\
\Delta\bm{x}_{t+1}\end{bmatrix}^{\!{\scriptscriptstyle\top}}\begin{bmatrix}0&amp;\bm{v}_{\bm{x},{t+1}}^{\scriptscriptstyle\top}\\
\bm{v}_{\bm{x},{t+1}}&amp;\bm{V}_{\bm{x}\bm{x},{t+1}}\end{bmatrix}\begin{bmatrix}1\\
\Delta\bm{x}_{t+1}\end{bmatrix}.</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(99)</span></td>
</tr>
</table>
</div>
<div class="ltx_para" id="S8-para:SS2.p5">
<p class="ltx_p">By substituting <span class="ltx_Math" id="SS2.p5.m1">\Delta\bm{x}_{t+1}=\bm{A}_{t}\Delta\bm{x}_{t}+\bm{B}_{t}\Delta\bm{u}_{t}</span> into (<a class="ltx_ref" href="#S8-eq:ct0iLQR" title="(99) ‣ 8.2 Recursive formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">99</span></a>), <span class="ltx_Math" id="SS2.p5.m2">\hat{v}_{t}</span> can be rewritten as</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:qt">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E100.m1">\hat{v}_{t}=\min_{\Delta\bm{u}_{t}}\begin{bmatrix}1\\
\Delta\bm{x}_{t}\\
\Delta\bm{u}_{t}\end{bmatrix}^{\!\!{\scriptscriptstyle\top}}\!\!\begin{bmatrix}0&amp;\bm{q}_{\bm{x},t}^{\scriptscriptstyle\top}&amp;\bm{q}_{\bm{u},t}^{\scriptscriptstyle\top}\\
\bm{q}_{\bm{x},t}&amp;\bm{Q}_{\bm{x}\bm{x},t}&amp;\bm{Q}_{\bm{u}\bm{x},t}^{\scriptscriptstyle\top}\\
\bm{q}_{\bm{u},t}&amp;\bm{Q}_{\bm{u}\bm{x},t}&amp;\bm{Q}_{\bm{u}\bm{u},t}\\
\end{bmatrix}\!\!\begin{bmatrix}1\\
\Delta\bm{x}_{t}\\
\Delta\bm{u}_{t}\end{bmatrix},\quad\text{where}\quad\left\{\begin{aligned} \bm{q}_{\bm{x},t}&amp;=\bm{g}_{\bm{x},t}+\bm{A}_{t}^{\scriptscriptstyle\top}\bm{v}_{\bm{x},t+1},\\
\bm{q}_{\bm{u},t}&amp;=\bm{g}_{\bm{u},t}+\bm{B}_{t}^{\scriptscriptstyle\top}\,\bm{v}_{\bm{x},t+1},\\
\bm{Q}_{\bm{x}\bm{x},t}&amp;\approx\bm{H}_{\bm{x}\bm{x},t}+\bm{A}_{t}^{\scriptscriptstyle\top}\,\bm{V}_{\bm{x}\bm{x},t+1}\,\bm{A}_{t},\\
\bm{Q}_{\bm{u}\bm{u},t}&amp;\approx\bm{H}_{\bm{u}\bm{u},t}+\bm{B}_{t}^{\scriptscriptstyle\top}\,\bm{V}_{\bm{x}\bm{x},t+1}\,\bm{B}_{t},\\
\bm{Q}_{\bm{u}\bm{x},t}&amp;\approx\bm{H}_{\bm{u}\bm{x},t}+\bm{B}_{t}^{\scriptscriptstyle\top}\,\bm{V}_{\bm{x}\bm{x},t+1}\,\bm{A}_{t},\end{aligned}\right.</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(100)</span></td>
</tr>
</table>
<p class="ltx_p">with gradients</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex75">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex75.m1">\bm{g}_{\bm{x},t}=\frac{\partial c}{\partial\bm{x}_{t}}\Big|_{\bm{\hat{x}}_{t},\bm{\hat{u}}_{t}},\quad\bm{g}_{\bm{u},t}=\frac{\partial c}{\partial\bm{u}_{t}}\Big|_{\bm{\hat{x}}_{t},\bm{\hat{u}}_{t}},\quad\bm{v}_{\bm{x},t}=\frac{\partial\hat{v}}{\partial\bm{x}_{t}}\Big|_{\bm{\hat{x}}_{t},\bm{\hat{u}}_{t}},\quad\bm{q}_{\bm{x},t}=\frac{\partial q}{\partial\bm{x}_{t}}\Big|_{\bm{\hat{x}}_{t},\bm{\hat{u}}_{t}},\quad\bm{q}_{\bm{u},t}=\frac{\partial q}{\partial\bm{u}_{t}}\Big|_{\bm{\hat{x}}_{t},\bm{\hat{u}}_{t}},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">Jacobian matrices</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex76">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex76.m1">\bm{A}_{t}=\frac{\partial\bm{d}}{\partial\bm{x}_{t}}\Big|_{\bm{\hat{x}}_{t},\bm{\hat{u}}_{t}},\quad\bm{B}_{t}=\frac{\partial\bm{d}}{\partial\bm{u}_{t}}\Big|_{\bm{\hat{x}}_{t},\bm{\hat{u}}_{t}},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">and Hessian matrices</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex77">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex77.m1">\bm{H}_{\bm{x}\bm{x},t}\!=\!\frac{\partial^{2}c}{\partial\bm{x}_{t}^{2}}\Big|_{\bm{\hat{x}}_{t},\bm{\hat{u}}_{t}},\quad\bm{H}_{\bm{u}\bm{u},t}\!=\!\frac{\partial^{2}c}{\partial\bm{u}_{t}^{2}}\Big|_{\bm{\hat{x}}_{t},\bm{\hat{u}}_{t}},\quad\bm{H}_{\bm{u}\bm{x},t}\!=\!\frac{\partial^{2}c}{\partial\bm{u}_{t}\partial\bm{x}_{t}}\Big|_{\bm{\hat{x}}_{t},\bm{\hat{u}}_{t}},\quad\bm{V}_{\bm{x}\bm{x},t}\!=\!\frac{\partial^{2}\hat{v}}{\partial\bm{x}_{t}^{2}}\Big|_{\bm{\hat{x}}_{t},\bm{\hat{u}}_{t}},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex78">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex78.m1">\bm{Q}_{\bm{x}\bm{x},t}=\frac{\partial^{2}q}{\partial\bm{x}_{t}^{2}}\Big|_{\bm{\hat{x}}_{t},\bm{\hat{u}}_{t}},\quad\bm{Q}_{\bm{u}\bm{u},t}=\frac{\partial^{2}q}{\partial\bm{u}_{t}^{2}}\Big|_{\bm{\hat{x}}_{t},\bm{\hat{u}}_{t}},\quad\bm{Q}_{\bm{u}\bm{x},t}=\frac{\partial^{2}q}{\partial\bm{u}_{t}\partial\bm{x}_{t}}\Big|_{\bm{\hat{x}}_{t},\bm{\hat{u}}_{t}}.</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div class="ltx_para" id="S8-para:SS2.p6">
<p class="ltx_p">Minimizing (<a class="ltx_ref" href="#S8-eq:qt" title="(100) ‣ 8.2 Recursive formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">100</span></a>) w.r.t. <span class="ltx_Math" id="SS2.p6.m1">\Delta\bm{u}_{t}</span> can be achieved by differentiating the equation and equating to zero, yielding the controller</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:duhat">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E101.m1">\Delta\bm{\hat{u}}_{t}=\bm{k}_{t}+\bm{K}_{t}\,\Delta\bm{x}_{t},\;\text{with}\quad\left\{\begin{aligned} \bm{k}_{t}&amp;=-\bm{Q}_{\bm{u}\bm{u},t}^{-1}\,\bm{q}_{\bm{u},t},\\
\bm{K}_{t}&amp;=-\bm{Q}_{\bm{u}\bm{u},t}^{-1}\,\bm{Q}_{\bm{u}\bm{x},t},\end{aligned}\right.</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(101)</span></td>
</tr>
</table>
<p class="ltx_p">where <span class="ltx_Math" id="SS2.p6.m2">\bm{k}_{t}</span> is a feedforward command and <span class="ltx_Math" id="SS2.p6.m3">\bm{K}_{t}</span> is a feedback gain matrix.</p>
</div>
<div class="ltx_para" id="S8-para:SS2.p7">
<p class="ltx_p">By inserting (<a class="ltx_ref" href="#S8-eq:duhat" title="(101) ‣ 8.2 Recursive formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">101</span></a>) into (<a class="ltx_ref" href="#S8-eq:qt" title="(100) ‣ 8.2 Recursive formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">100</span></a>), we get the recursive updates</p>
<table class="ltx_equationgroup ltx_eqn_table" id="S8-eq:vV">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline" id="E102X">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="E102X.m2">\displaystyle\bm{v}_{\bm{x},t}</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="E102X.m3">\displaystyle=\bm{q}_{\bm{x},t}-\bm{Q}_{\bm{u}\bm{x},t}^{\scriptscriptstyle\top}\,\bm{Q}_{\bm{u}\bm{u},t}^{-1}\,\bm{q}_{\bm{u},t},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="2"><span class="ltx_tag ltx_tag_equationgroup ltx_align_right">(102)</span></td>
</tr>
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline" id="E102Xa">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="E102Xa.m2">\displaystyle\bm{V}_{\bm{x}\bm{x},t}</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="E102Xa.m3">\displaystyle=\bm{Q}_{\bm{x}\bm{x},t}-\bm{Q}_{\bm{u}\bm{x},t}^{\scriptscriptstyle\top}\,\bm{Q}_{\bm{u}\bm{u},t}^{-1}\,\bm{Q}_{\bm{u}\bm{x},t}.</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div class="ltx_para" id="S8-para:SS2.p8">
<p class="ltx_p">In this recursive iLQR formulation, at each iteration step of the optimization algorithm, the nominal trajectories <span class="ltx_Math" id="SS2.p8.m1">(\bm{\hat{x}}_{t},\bm{\hat{u}}_{t})</span> are refined, together with feedback matrices <span class="ltx_Math" id="SS2.p8.m2">\bm{K}_{t}</span>. Thus, at each iteration step of the optimization algorithm, a backward and forward recursion is performed to evaluate these vectors and matrices. There is thus two types of iterations: one for the optimization algorithm, and one for the dynamic programming recursion performed at each given iteration.</p>
</div>
<div class="ltx_para" id="S8-para:SS2.p9">
<p class="ltx_p">After convergence, by using (<a class="ltx_ref" href="#S8-eq:duhat" title="(101) ‣ 8.2 Recursive formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">101</span></a>) and the nominal trajectories in the state and control spaces <span class="ltx_Math" id="SS2.p9.m1">(\bm{\hat{x}}_{t},\bm{\hat{u}}_{t})</span>, the resulting controller at each time step <span class="ltx_Math" id="SS2.p9.m2">t</span> is</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:iLQRrecursiveController">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E103.m1">\bm{u}_{t}=\bm{\hat{u}}_{t}+\bm{K}_{t}\,(\bm{\hat{x}}_{t}-\bm{x}_{t}),</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(103)</span></td>
</tr>
</table>
<p class="ltx_p">where the evolution of the state is described by <span class="ltx_Math" id="SS2.p9.m3">\bm{x}_{t+1}=\bm{d}(\bm{x}_{t},\bm{u}_{t})</span>.</p>
</div>
<div class="ltx_para" id="S8-para:SS2.p10">
<p class="ltx_p">The complete iLQR procedure is described in Algorithm <a class="ltx_ref" href="#S8-alg:iLQRrecursive" title="Algorithm 5 ‣ 8.4 Updates by considering step sizes ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">5</span></a> (including backtracking line search).</p>
</div>
</div><div class="ltx_subsection" id="S8-sec:iLQRLS">
<h2 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span class="ltx_text">8.3</span> </span><span class="ltx_text">Least squares formulation of recursive iLQR</span>
</h2>
<div class="ltx_para" id="S8-para:SS3.p1">
<p class="ltx_p">First, note that (<a class="ltx_ref" href="#S8-eq:duhat" title="(101) ‣ 8.2 Recursive formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">101</span></a>) can be rewritten as</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:duhat2">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E104.m1">\Delta\bm{\hat{u}}_{t}=\bm{\tilde{K}}_{t}\,\begin{bmatrix}\Delta\bm{x}_{t}\\
1\end{bmatrix},\;\text{with}\quad\bm{\tilde{K}}_{t}=-\bm{Q}_{\bm{u}\bm{u},t}^{-1}\Big[\bm{Q}_{\bm{u}\bm{x},t},\;\bm{q}_{\bm{u},t}\Big].</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(104)</span></td>
</tr>
</table>
</div>
<div class="ltx_para" id="S8-para:SS3.p2">
<p class="ltx_p">Also, (<a class="ltx_ref" href="#S8-eq:minu" title="(94) ‣ 8.1 Batch formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">94</span></a>) can be rewritten as</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex79">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex79.m1">\min_{\Delta\bm{u}}\quad\underbrace{\frac{1}{2}\begin{bmatrix}\Delta\bm{u}\\
1\end{bmatrix}^{\scriptscriptstyle\top}\begin{bmatrix}\bm{C}&amp;\bm{c}\\
\bm{c}^{\scriptscriptstyle\top}&amp;0\end{bmatrix}\begin{bmatrix}\Delta\bm{u}\\
1\end{bmatrix}}_{\frac{1}{2}\Delta\bm{u}^{\scriptscriptstyle\top}\bm{C}\Delta\bm{u}+\Delta\bm{u}^{\scriptscriptstyle\top}\bm{c}},\quad\text{where}\quad\left\{\begin{aligned} \bm{c}&amp;=\bm{S}_{\bm{u}}^{\scriptscriptstyle\top}\bm{g}_{\bm{x}}+\bm{g}_{\bm{u}},\\
\bm{C}&amp;=\bm{S}_{\bm{u}}^{\scriptscriptstyle\top}\bm{H}_{\bm{x}\bm{x}}\bm{S}_{\bm{u}}+2\bm{S}_{\bm{u}}^{\scriptscriptstyle\top}\bm{H}_{\bm{u}\bm{x}}^{\scriptscriptstyle\top}+\bm{H}_{\bm{u}\bm{u}}.\end{aligned}\right.</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div class="ltx_para" id="S8-para:SS3.p3">
<p class="ltx_p">Similarly to Section <a class="ltx_ref" href="#S7-sec:LQRLS" title="7.6 Least squares formulation of recursive LQR ‣ 7 Linear quadratic tracking (LQT) ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">7.6</span></a>, we set</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:E105">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E105.m1">\Delta\bm{u}=-\bm{F}\begin{bmatrix}\Delta\bm{x}_{1}\\
1\end{bmatrix}=-\bm{F}\begin{bmatrix}\bm{0}\\
1\end{bmatrix}=-\bm{F}\Delta\bm{\tilde{x}}_{1},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(105)</span></td>
</tr>
</table>
<p class="ltx_p">and redefine the optimization problem as</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:E106">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E106.m1">\min_{\bm{F}}\quad\frac{1}{2}\Delta\bm{\tilde{x}}_{1}^{\scriptscriptstyle\top}\bm{F}^{\scriptscriptstyle\top}\bm{C}\bm{F}\Delta\bm{\tilde{x}}_{1}-\Delta\bm{\tilde{x}}_{1}^{\scriptscriptstyle\top}\bm{F}^{\scriptscriptstyle\top}\bm{c}.</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(106)</span></td>
</tr>
</table>
</div>
<div class="ltx_para" id="S8-para:SS3.p4">
<p class="ltx_p">By differentiating w.r.t. <span class="ltx_Math" id="SS3.p4.m1">\bm{F}</span> and equating to zero, we get</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:E107">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E107.m1">\bm{F}\Delta\bm{\tilde{x}}_{1}=\bm{C}^{-1}\bm{c}.</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(107)</span></td>
</tr>
</table>
</div>
<div class="ltx_para" id="S8-para:SS3.p5">
<p class="ltx_p">Similarly to Section <a class="ltx_ref" href="#S7-sec:LQRLS" title="7.6 Least squares formulation of recursive LQR ‣ 7 Linear quadratic tracking (LQT) ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">7.6</span></a>, we decompose <span class="ltx_Math" id="SS3.p5.m1">\bm{F}</span> as block matrices <span class="ltx_Math" id="SS3.p5.m2">\bm{F}_{t}</span> with <span class="ltx_Math" id="SS3.p5.m3">t\in\{1,\ldots,T-1\}</span>. <span class="ltx_Math" id="SS3.p5.m4">\bm{F}</span> can then be used to iteratively reconstruct regulation gains <span class="ltx_Math" id="SS3.p5.m5">\bm{K}_{t}</span>, by starting from <span class="ltx_Math" id="SS3.p5.m6">\bm{K}_{1}=\bm{F}_{1}</span>, <span class="ltx_Math" id="SS3.p5.m7">\bm{P}_{1}=\bm{I}</span>, and by computing with forward recursion</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:E108">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E108.m1">\bm{P}_{t}=\bm{P}_{t-1}{(\bm{A}_{t-1}-\bm{B}_{t-1}\bm{K}_{t-1})}^{-1},\quad\bm{K}_{t}=\bm{F}_{t}\;\bm{P}_{t},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(108)</span></td>
</tr>
</table>
<p class="ltx_p">from <span class="ltx_Math" id="SS3.p5.m8">t=2</span> to <span class="ltx_Math" id="SS3.p5.m9">t=T-1</span>.</p>
</div>
</div><div class="ltx_subsection" id="S8-sec:SS4">
<h2 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span class="ltx_text">8.4</span> </span><span class="ltx_text">Updates by considering step sizes</span>
</h2>
<figure class="ltx_float" id="S8-alg:linesearch">
<div class="ltx_listing ltx_lst_numbers_left ltx_listing">
<div class="ltx_listingline"> <span class="ltx_Math" id="algorithm3.m3">\alpha\leftarrow 1</span>
</div>
<div class="ltx_listingline"> <span class="ltx_text ltx_font_bold">while</span> <em class="ltx_emph ltx_font_italic"><span class="ltx_Math" id="algorithm3.m4">c(\bm{\hat{u}}+\alpha\;\Delta\bm{\hat{u}})&gt;c(\bm{\hat{u}})\;\textbf{and}\;\;\alpha&gt;\alpha_{\min}</span></em> <span class="ltx_text ltx_font_bold">do</span>
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>    <span class="ltx_Math" id="algorithm3.m5">\alpha\leftarrow\frac{\alpha}{2}</span>
</div>
<div class="ltx_listingline"> end while
</div>
<div class="ltx_listingline">
</div>
</div>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_float"><span class="ltx_text ltx_font_bold">Algorithm 3</span> </span>Backtracking line search method with parameter <span class="ltx_Math" id="algorithm3.m2">\alpha_{\min}</span></figcaption>
</figure>
<figure class="ltx_float" id="S8-alg:iLQRbatch">
<div class="ltx_listing ltx_lst_numbers_left ltx_listing">
<div class="ltx_listingline"> Define cost <span class="ltx_Math" id="algorithm4.m1">c(\cdot)</span>, dynamics <span class="ltx_Math" id="algorithm4.m2">\bm{d}(\cdot)</span>, <span class="ltx_Math" id="algorithm4.m3">\bm{x}_{1}</span>, <span class="ltx_Math" id="algorithm4.m4">\alpha_{\min}</span>, <span class="ltx_Math" id="algorithm4.m5">\Delta_{\min}</span>
</div>
<div class="ltx_listingline"> Initialize <span class="ltx_Math" id="algorithm4.m6">\bm{\hat{u}}</span>
</div>
<div class="ltx_listingline"> <span class="ltx_text ltx_font_bold">repeat</span>
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>    Compute <span class="ltx_Math" id="algorithm4.m7">\bm{\hat{x}}</span> using <span class="ltx_Math" id="algorithm4.m8">\bm{\hat{u}}</span>, <span class="ltx_Math" id="algorithm4.m9">\bm{d}(\cdot)</span>, and <span class="ltx_Math" id="algorithm4.m10">\bm{x}_{1}</span>
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>    Compute <span class="ltx_Math" id="algorithm4.m11">\bm{A}_{t},\bm{B}_{t}</span> in (<a class="ltx_ref" href="#S8-eq:DS" title="(91) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">91</span></a>) 
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>    Compute <span class="ltx_Math" id="algorithm4.m12">\bm{S}_{\bm{u}}</span> with (<a class="ltx_ref" href="#A1-eq:SxSu" title="(194) ‣ Appendix A System dynamics at trajectory level ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">194</span></a>) 
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>    Compute <span class="ltx_Math" id="algorithm4.m13">\bm{g}_{\bm{\cdot}}</span> and <span class="ltx_Math" id="algorithm4.m14">\bm{H}_{\bm{\cdot}}</span> in (<a class="ltx_ref" href="#S8-eq:dc_batch" title="(93) ‣ 8.1 Batch formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">93</span></a>), using (<a class="ltx_ref" href="#S8-eq:dc" title="(92) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">92</span></a>) 
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>    Compute <span class="ltx_Math" id="algorithm4.m15">\Delta\bm{\hat{u}}</span> with (<a class="ltx_ref" href="#S8-eq:du_general" title="(96) ‣ 8.1 Batch formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">96</span></a>) 
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>    Compute <span class="ltx_Math" id="algorithm4.m16">\alpha</span> with Algorithm <a class="ltx_ref" href="#S8-alg:linesearch" title="Algorithm 3 ‣ 8.4 Updates by considering step sizes ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">3</span></a>
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>    Update <span class="ltx_Math" id="algorithm4.m17">\bm{\hat{u}}</span> with (<a class="ltx_ref" href="#S8-eq:alpha" title="(109) ‣ 8.4 Updates by considering step sizes ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">109</span></a>) 
</div>
<div class="ltx_listingline">
<span class="ltx_text ltx_font_bold">until</span> <em class="ltx_emph ltx_font_italic"><span class="ltx_Math" id="algorithm4.m18">\|\Delta\bm{\hat{u}}\|&lt;\Delta_{\min}</span></em>;
</div>
<div class="ltx_listingline">
</div>
</div>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_float"><span class="ltx_text ltx_font_bold">Algorithm 4</span> </span>Batch formulation of iLQR</figcaption>
</figure>
<figure class="ltx_float" id="S8-alg:iLQRrecursive">
<div class="ltx_listing ltx_lst_numbers_left ltx_listing">
<div class="ltx_listingline"> Define cost <span class="ltx_Math" id="algorithm5.m1">c(\cdot)</span>, dynamics <span class="ltx_Math" id="algorithm5.m2">\bm{d}(\cdot)</span>, <span class="ltx_Math" id="algorithm5.m3">\bm{x}_{1}</span>, <span class="ltx_Math" id="algorithm5.m4">\alpha_{\min}</span>, <span class="ltx_Math" id="algorithm5.m5">\Delta_{\min}</span>
</div>
<div class="ltx_listingline"> Initialize all <span class="ltx_Math" id="algorithm5.m6">\bm{\hat{u}}_{t}</span>
</div>
<div class="ltx_listingline"> <span class="ltx_text ltx_font_bold">repeat</span>
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>    Compute <span class="ltx_Math" id="algorithm5.m7">\bm{\hat{x}}</span> using <span class="ltx_Math" id="algorithm5.m8">\bm{\hat{u}}</span>, <span class="ltx_Math" id="algorithm5.m9">\bm{d}(\cdot)</span>, and <span class="ltx_Math" id="algorithm5.m10">\bm{x}_{1}</span>
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>    <span class="ltx_text ltx_font_typewriter">// </span><span class="ltx_text ltx_font_typewriter">Evaluating derivatives </span>
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>    Compute all <span class="ltx_Math" id="algorithm5.m11">\bm{A}_{t},\bm{B}_{t}</span> in (<a class="ltx_ref" href="#S8-eq:DS" title="(91) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">91</span></a>) 
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>    Compute all <span class="ltx_Math" id="algorithm5.m12">\bm{g}_{\bm{\cdot},t}</span> and <span class="ltx_Math" id="algorithm5.m13">\bm{H}_{\bm{\cdot},t}</span> in (<a class="ltx_ref" href="#S8-eq:dc" title="(92) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">92</span></a>) 
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>    <span class="ltx_text ltx_font_typewriter">// </span><span class="ltx_text ltx_font_typewriter">Backward pass </span>
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>    Set <span class="ltx_Math" id="algorithm5.m14">\bm{v}_{\bm{x},T}=\bm{g}_{\bm{x},T}</span> and <span class="ltx_Math" id="algorithm5.m15">\bm{V}_{\bm{x}\bm{x},T}=\bm{H}_{\bm{x}\bm{x},T}</span>
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>    <span class="ltx_text ltx_font_bold">for</span> <em class="ltx_emph ltx_font_italic"><span class="ltx_Math" id="algorithm5.m16">t\leftarrow T-1</span> to <span class="ltx_Math" id="algorithm5.m17">1</span></em> <span class="ltx_text ltx_font_bold">do</span>
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>     <span class="ltx_rule"> </span>    Compute <span class="ltx_Math" id="algorithm5.m18">\bm{q}_{\bm{\cdot},t}</span> and <span class="ltx_Math" id="algorithm5.m19">\bm{Q}_{\bm{\cdot},t}</span> with (<a class="ltx_ref" href="#S8-eq:qt" title="(100) ‣ 8.2 Recursive formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">100</span></a>) 
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>     <span class="ltx_rule"> </span>    Compute <span class="ltx_Math" id="algorithm5.m20">\bm{k}_{t}</span> and <span class="ltx_Math" id="algorithm5.m21">\bm{K}_{t}</span> with (<a class="ltx_ref" href="#S8-eq:duhat" title="(101) ‣ 8.2 Recursive formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">101</span></a>) 
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>     <span class="ltx_rule"> </span>    Compute <span class="ltx_Math" id="algorithm5.m22">\bm{v}_{\bm{x},t}</span> and <span class="ltx_Math" id="algorithm5.m23">\bm{V}_{\bm{x}\bm{x},t}</span> with (<a class="ltx_ref" href="#S8-eq:vV" title="(102) ‣ 8.2 Recursive formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">102</span></a>) 
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>    end for
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>   <span class="ltx_text ltx_font_typewriter">// </span><span class="ltx_text ltx_font_typewriter">Forward pass </span>
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>    <span class="ltx_Math" id="algorithm5.m24">\alpha\leftarrow 2</span>
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>    <span class="ltx_text ltx_font_bold">while</span> <em class="ltx_emph ltx_font_italic"><span class="ltx_Math" id="algorithm5.m25">c(\bm{\hat{u}}+\alpha\;\Delta\bm{\hat{u}})&gt;c(\bm{\hat{u}})\;\textbf{and}\;\;\alpha&gt;\alpha_{\min}</span></em> <span class="ltx_text ltx_font_bold">do</span>
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>     <span class="ltx_rule"> </span>    <span class="ltx_Math" id="algorithm5.m26">\alpha\leftarrow\frac{\alpha}{2}</span>
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>     <span class="ltx_rule"> </span>    <span class="ltx_text ltx_font_bold">for</span> <em class="ltx_emph ltx_font_italic"><span class="ltx_Math" id="algorithm5.m27">t\leftarrow 1</span> to <span class="ltx_Math" id="algorithm5.m28">T-1</span></em> <span class="ltx_text ltx_font_bold">do</span>
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>     <span class="ltx_rule"> </span>     <span class="ltx_rule"> </span>    Update <span class="ltx_Math" id="algorithm5.m29">\bm{\hat{u}}_{t}</span> with (<a class="ltx_ref" href="#S8-eq:alpha2" title="(110) ‣ 8.4 Updates by considering step sizes ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">110</span></a>) 
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>     <span class="ltx_rule"> </span>     <span class="ltx_rule"> </span>    Compute <span class="ltx_Math" id="algorithm5.m30">\bm{\hat{x}}_{t+1}</span> with <span class="ltx_Math" id="algorithm5.m31">\bm{d}(\cdot)</span>
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>     <span class="ltx_rule"> </span>    end for
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>     <span class="ltx_rule"> </span>   
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>    end while
</div>
<div class="ltx_listingline">  <span class="ltx_rule"> </span>   
</div>
<div class="ltx_listingline">
<span class="ltx_text ltx_font_bold">until</span> <em class="ltx_emph ltx_font_italic"><span class="ltx_Math" id="algorithm5.m32">\|\Delta\bm{\hat{u}}\|&lt;\Delta_{\min}</span></em>;
</div>
<div class="ltx_listingline">Use (<a class="ltx_ref" href="#S8-eq:iLQRrecursiveController" title="(103) ‣ 8.2 Recursive formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">103</span></a>) and <span class="ltx_Math" id="algorithm5.m33">\bm{d}(\cdot)</span> for reproduction 
</div>
<div class="ltx_listingline">
</div>
</div>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_float"><span class="ltx_text ltx_font_bold">Algorithm 5</span> </span>Recursive formulation of iLQR</figcaption>
</figure>
<div class="ltx_para" id="S8-para:SS4.p1">
<p class="ltx_p">To be more efficient, iLQR most often requires at each iteration to estimate a step size <span class="ltx_Math" id="SS4.p1.m1">\alpha</span> to scale the control command updates.
For the batch formulation in Section <a class="ltx_ref" href="#S8-sec:iLQRbatch" title="8.1 Batch formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">8.1</span></a>, this can be achieved by setting the update (<a class="ltx_ref" href="#S8-eq:du_general" title="(96) ‣ 8.1 Batch formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">96</span></a>) as</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:alpha">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E109.m1">\bm{\hat{u}}\leftarrow\bm{\hat{u}}+\alpha\;\Delta\bm{\hat{u}},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(109)</span></td>
</tr>
</table>
<p class="ltx_p">where the resulting procedure consists of estimating a descent direction with (<a class="ltx_ref" href="#S8-eq:du_general" title="(96) ‣ 8.1 Batch formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">96</span></a>) along which the objective function will be reduced, and then estimating with (<a class="ltx_ref" href="#S8-eq:alpha" title="(109) ‣ 8.4 Updates by considering step sizes ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">109</span></a>) a step size that determines how far one can move along this direction.</p>
</div>
<div class="ltx_para" id="S8-para:SS4.p2">
<p class="ltx_p">For the recursive formulation in Section <a class="ltx_ref" href="#S8-sec:iLQRrecursive" title="8.2 Recursive formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">8.2</span></a>, this can be achieved by setting the update (<a class="ltx_ref" href="#S8-eq:duhat" title="(101) ‣ 8.2 Recursive formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">101</span></a>) as</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:alpha2">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E110.m1">\bm{\hat{u}}_{t}\leftarrow\bm{\hat{u}}_{t}+\alpha\;\bm{k}_{t}+\bm{K}_{t}\,\Delta\bm{x}_{t}.</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(110)</span></td>
</tr>
</table>
</div>
<div class="ltx_para" id="S8-para:SS4.p3">
<p class="ltx_p">In practice, a simple backtracking line search procedure can be considered with Algorithm <a class="ltx_ref" href="#S8-alg:linesearch" title="Algorithm 3 ‣ 8.4 Updates by considering step sizes ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">3</span></a>, by considering a small value for <span class="ltx_Math" id="SS4.p3.m1">\alpha_{\min}</span>. For more elaborated methods, see Ch. 3 of <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="#bib-bib:bib19" title="Numerical optimization">13</a>]</cite>.</p>
</div>
<div class="ltx_para" id="S8-para:SS4.p4">
<p class="ltx_p">The complete iLQR procedures are described in Algorithms <a class="ltx_ref" href="#S8-alg:iLQRbatch" title="Algorithm 4 ‣ 8.4 Updates by considering step sizes ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">4</span></a> and <a class="ltx_ref" href="#S8-alg:iLQRrecursive" title="Algorithm 5 ‣ 8.4 Updates by considering step sizes ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">5</span></a> for the batch and recursive formulations, respectively.</p>
</div>
</div><div class="ltx_subsection" id="S8-sec:iLQR_quadraticCost">
<h2 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span class="ltx_text">8.5</span> </span><span class="ltx_text">iLQR with quadratic cost on <span class="ltx_Math" id="SS5.m1">f(x_{t})</span></span>
</h2>
<div class="ltx_para" id="S8-para:SS5.p1">
<p class="ltx_p">We consider a cost defined by</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:E111">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E111.m1">c(\bm{x}_{t},\bm{u}_{t})=\bm{f}(\bm{x}_{t})^{\!{\scriptscriptstyle\top}}\bm{Q}_{t}\bm{f}(\bm{x}_{t})+\bm{u}_{t}^{\scriptscriptstyle\top}\bm{R}_{t}\,\bm{u}_{t},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(111)</span></td>
</tr>
</table>
<p class="ltx_p">where <span class="ltx_Math" id="SS5.p1.m1">\bm{Q}_{t}</span> and <span class="ltx_Math" id="SS5.p1.m2">\bm{R}_{t}</span> are weight matrices trading off task and control costs. Such cost is quadratic on <span class="ltx_Math" id="SS5.p1.m3">\bm{f}(\bm{x}_{t})</span> but non-quadratic on <span class="ltx_Math" id="SS5.p1.m4">\bm{x}_{t}</span>.</p>
</div>
<div class="ltx_para" id="S8-para:SS5.p2">
<p class="ltx_p">For the batch formulation of iLQR, the cost in (<a class="ltx_ref" href="#S8-eq:dc" title="(92) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">92</span></a>) then becomes</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:E112">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E112.m1">\Delta c(\Delta\bm{x}_{t},\Delta\bm{u}_{t})\approx 2\Delta\bm{x}_{t}^{\scriptscriptstyle\top}\bm{J}(\bm{x}_{t})^{\scriptscriptstyle\top}\bm{Q}_{t}\bm{f}(\bm{x}_{t})+2\Delta\bm{u}_{t}^{\scriptscriptstyle\top}\bm{R}_{t}\,\bm{u}_{t}+\Delta\bm{x}_{t}^{\scriptscriptstyle\top}\bm{J}(\bm{x}_{t})^{\scriptscriptstyle\top}\bm{Q}_{t}\bm{J}(\bm{x}_{t})\Delta\bm{x}_{t}+\Delta\bm{u}_{t}^{\scriptscriptstyle\top}\bm{R}_{t}\Delta\bm{u}_{t},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(112)</span></td>
</tr>
</table>
<p class="ltx_p">which used gradients</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:dcdx">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E113.m1">\bm{g}_{\bm{x},t}=2\bm{J}(\bm{x}_{t})^{\scriptscriptstyle\top}\bm{Q}_{t}\bm{f}(\bm{x}_{t}),\quad\bm{g}_{\bm{u},t}=2\bm{R}_{t}\bm{u}_{t},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(113)</span></td>
</tr>
</table>
<p class="ltx_p">and Hessian matrices</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:E114">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E114.m1">\bm{H}_{\bm{x}\bm{x},t}\approx 2\bm{J}(\bm{x}_{t})^{\scriptscriptstyle\top}\bm{Q}_{t}\bm{J}(\bm{x}_{t}),\quad\bm{H}_{\bm{u}\bm{x},t}=\bm{0},\quad\bm{H}_{\bm{u}\bm{u},t}=2\bm{R}_{t}.</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(114)</span></td>
</tr>
</table>
<p class="ltx_p">with <span class="ltx_Math" id="SS5.p2.m1">\bm{J}(\bm{x}_{t})=\frac{\partial\bm{f}(\bm{x}_{t})}{\partial\bm{x}_{t}}</span> a Jacobian matrix. The same results can be used in the recursive formulation in (<a class="ltx_ref" href="#S8-eq:qt" title="(100) ‣ 8.2 Recursive formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">100</span></a>).</p>
</div>
<div class="ltx_para" id="S8-para:SS5.p3">
<p class="ltx_p">At a trajectory level, the cost can be written as</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:E115">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E115.m1">c(\bm{x},\bm{u})=\bm{f}(\bm{x})^{\!{\scriptscriptstyle\top}}\bm{Q}\bm{f}(\bm{x})+\bm{u}_{t}^{\scriptscriptstyle\top}\bm{R}\,\bm{u},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(115)</span></td>
</tr>
</table>
<p class="ltx_p">where the tracking and control weights are represented by the diagonally concatenated matrices <span class="ltx_Math" id="SS5.p3.m1">\bm{Q}\!=\!\mathrm{blockdiag}(\bm{Q}_{1},\bm{Q}_{2},\ldots,\bm{Q}_{T})</span> and <span class="ltx_Math" id="SS5.p3.m2">\bm{R}\!=\!\mathrm{blockdiag}(\bm{R}_{1},\bm{R}_{2},\ldots,\bm{R}_{T-1})</span>, respectively. In the above, with a slight abuse of notation, we defined <span class="ltx_Math" id="SS5.p3.m3">\bm{f}(\bm{x})</span> as a vector concatenating the vectors <span class="ltx_Math" id="SS5.p3.m4">\bm{f}(\bm{x}_{t})</span>. Similarly, <span class="ltx_Math" id="SS5.p3.m5">\bm{J}(\bm{x})</span> will represent a block-diagonal concatenation of the Jacobian matrices <span class="ltx_Math" id="SS5.p3.m6">\bm{J}(\bm{x}_{t})</span>.</p>
</div>
<div class="ltx_para" id="S8-para:SS5.p4">
<p class="ltx_p">With this notation, the minimization problem (<a class="ltx_ref" href="#S8-eq:minu" title="(94) ‣ 8.1 Batch formulation of iLQR ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">94</span></a>) then becomes</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:E116">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E116.m1">\min_{\Delta\bm{u}}\quad 2\Delta\bm{x}^{\!{\scriptscriptstyle\top}}\bm{J}(\bm{x})^{\scriptscriptstyle\top}\bm{Q}\bm{f}(\bm{x})+2\Delta\bm{u}^{\!{\scriptscriptstyle\top}}\bm{R}\,\bm{u}\;+\Delta\bm{x}^{\!{\scriptscriptstyle\top}}\bm{J}(\bm{x})^{\scriptscriptstyle\top}\bm{Q}\bm{J}(\bm{x})\Delta\bm{x}+\Delta\bm{u}^{\!{\scriptscriptstyle\top}}\bm{R}\Delta\bm{u},\quad\text{s.t.}\quad\Delta\bm{x}=\bm{S}_{\bm{u}}\Delta\bm{u},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(116)</span></td>
</tr>
</table>
<p class="ltx_p">whose least squares solution is given by</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:du">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E117.m1">\Delta\bm{\hat{u}}\!=\!{\Big(\bm{S}_{\bm{u}}^{\scriptscriptstyle\top}\bm{J}(\bm{x})^{\scriptscriptstyle\top}\bm{Q}\bm{J}(\bm{x})\bm{S}_{\bm{u}}\!+\!\bm{R}\Big)}^{\!\!-1}\Big(-\bm{S}_{\bm{u}}^{\scriptscriptstyle\top}\bm{J}(\bm{x})^{\scriptscriptstyle\top}\bm{Q}\bm{f}(\bm{x})-\bm{R}\,\bm{u}\Big),</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(117)</span></td>
</tr>
</table>
<p class="ltx_p">which can be used to update the control commands estimates at each iteration step of the iLQR algorithm.</p>
</div>
<div class="ltx_para" id="S8-para:SS5.p5">
<p class="ltx_p">In the next sections, we show examples of functions <span class="ltx_Math" id="SS5.p5.m1">\bm{f}(\bm{x})</span> that can rely on this formulation.</p>
</div>
<div class="ltx_subsubsection" id="S8-sec:SS5.SSS1">
<h3 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection"><span class="ltx_text">8.5.1</span> </span><span class="ltx_text">Robot manipulator</span>
</h3>
<div class="ltx_para" id="S8-para:SS5.SSS1.p1">
<p class="ltx_p">We define a manipulation task involving a set of transformations as in Fig. <a class="ltx_ref" href="#S8-fig:transformations" title="Figure 18 ‣ 8.5.1 Robot manipulator ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">18</span></a>. By relying on these transformation operators, we will next describe all variables in the robot frame of reference (defined by <span class="ltx_Math" id="SS5.SSS1.p1.m1">\bm{0}</span>, <span class="ltx_Math" id="SS5.SSS1.p1.m2">\bm{e}_{1}</span> and <span class="ltx_Math" id="SS5.SSS1.p1.m3">\bm{e}_{2}</span> in the figure).</p>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS1.p2">
<p class="ltx_p">For a manipulator controlled by joint angle velocity commands <span class="ltx_Math" id="SS5.SSS1.p2.m1">\bm{u}=\bm{\dot{x}}</span>, the evolution of the system is described by <span class="ltx_Math" id="SS5.SSS1.p2.m2">\bm{x}_{t+1}=\bm{x}_{t}+\bm{u}_{t}\Delta t</span>, with the Taylor expansion (<a class="ltx_ref" href="#S8-eq:DS" title="(91) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">91</span></a>) simplifying to <span class="ltx_Math" id="SS5.SSS1.p2.m3">\bm{A}_{t}=\frac{\partial\bm{g}}{\partial\bm{x}_{t}}=\bm{I}</span> and <span class="ltx_Math" id="SS5.SSS1.p2.m4">\bm{B}_{t}=\frac{\partial\bm{g}}{\partial\bm{u}_{t}}=\bm{I}\Delta t</span>. Similarly, a double integrator can alternatively be considered, with acceleration commands <span class="ltx_Math" id="SS5.SSS1.p2.m5">\bm{u}=\bm{\ddot{x}}</span> and states composed of both positions and velocities.</p>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS1.p3">
<p class="ltx_p">For a robot manipulator, <span class="ltx_Math" id="SS5.SSS1.p3.m1">\bm{f}(\bm{x}_{t})</span> in (<a class="ltx_ref" href="#S8-eq:du" title="(117) ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">117</span></a>) typically represents the error between a reference <span class="ltx_Math" id="SS5.SSS1.p3.m2">\bm{\mu}_{t}</span> and the endeffector position computed by the forward kinematics function <span class="ltx_Math" id="SS5.SSS1.p3.m3">\bm{f}^{\text{\tiny ee}}(\bm{x}_{t})</span>. We then have</p>
<table class="ltx_equationgroup ltx_eqn_align ltx_eqn_table" id="S8-eq:A5.EGx24">
<tbody id="S8-eq:Ex80"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="Ex80.m1">\displaystyle\bm{f}(\bm{x}_{t})</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="Ex80.m2">\displaystyle=\bm{f}^{\text{\tiny ee}}(\bm{x}_{t})-\bm{\mu}_{t},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
<tbody id="S8-eq:Ex81"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="Ex81.m1">\displaystyle\bm{J}(\bm{x}_{t})</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="Ex81.m2">\displaystyle=\bm{J}^{\text{\tiny ee}}(\bm{x}_{t}).</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS1.p4">
<p class="ltx_p">For the orientation part of the data (if considered), the Euclidean distance vector <span class="ltx_Math" id="SS5.SSS1.p4.m1">\bm{f}^{\text{\tiny ee}}(\bm{x}_{t})-\bm{\mu}_{t}</span> is replaced by a geodesic distance measure computed with the logarithmic map <span class="ltx_Math" id="SS5.SSS1.p4.m2">\log_{\bm{\mu}_{t}}\!\big(\bm{f}^{\text{\tiny ee}}(\bm{x}_{t})\big)</span>, see <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="#bib-bib:bib11" title="Gaussians on Riemannian manifolds: applications for robot learning and adaptive control">3</a>]</cite> for details.</p>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS1.p5">
<p class="ltx_p">The approach can similarly be extended to target objects/landmarks with positions <span class="ltx_Math" id="SS5.SSS1.p5.m1">\bm{\mu}_{t}</span> and rotation matrices <span class="ltx_Math" id="SS5.SSS1.p5.m2">\bm{U}_{t}</span>, whose columns are basis vectors forming a coordinate system, see Fig. <a class="ltx_ref" href="#S8-fig:iLQR_manipulator" title="Figure 20 ‣ 8.5.3 Bounded task space ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">20</span></a>. We can then define an error between the robot endeffector and an object/landmark expressed in the object/landmark coordinate system as</p>
<table class="ltx_equationgroup ltx_eqn_table" id="S8-eq:fJU">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline" id="E118X">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="E118X.m2">\displaystyle\bm{f}(\bm{x}_{t})</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="E118X.m3">\displaystyle=\bm{U}_{t}^{\scriptscriptstyle\top}\big(\bm{f}^{\text{\tiny ee}}(\bm{x}_{t})-\bm{\mu}_{t}\big),</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="2"><span class="ltx_tag ltx_tag_equationgroup ltx_align_right">(118)</span></td>
</tr>
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline" id="E118Xa">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="E118Xa.m2">\displaystyle\bm{J}(\bm{x}_{t})</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="E118Xa.m3">\displaystyle=\bm{U}_{t}^{\scriptscriptstyle\top}\bm{J}^{\text{\tiny ee}}(\bm{x}_{t}).</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
</div>
<div class="ltx_subsubsection" id="S8-sec:SS5.SSS2">
<h3 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection"><span class="ltx_text">8.5.2</span> </span><span class="ltx_text">Bounded joint space</span>
</h3>
<div class="ltx_para" id="S8-para:SS5.SSS2.p1">
<p class="ltx_p">The iLQR solution in (<a class="ltx_ref" href="#S8-eq:du" title="(117) ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">117</span></a>) can be used to keep the state within a boundary (e.g., joint angle limits). We denote <span class="ltx_Math" id="SS5.SSS2.p1.m1">\bm{f}(\bm{x})=\bm{f}^{\text{\tiny cut}}(\bm{x})</span> as the vertical concatenation of <span class="ltx_Math" id="SS5.SSS2.p1.m2">\bm{f}^{\text{\tiny cut}}(\bm{x}_{t})</span> and <span class="ltx_Math" id="SS5.SSS2.p1.m3">\bm{J}(\bm{x})=\bm{J}^{\text{\tiny cut}}(\bm{x})</span> as a diagonal concatenation of diagonal Jacobian matrices <span class="ltx_Math" id="SS5.SSS2.p1.m4">\bm{J}^{\text{\tiny cut}}(\bm{x}_{t})</span>. Each element <span class="ltx_Math" id="SS5.SSS2.p1.m5">i</span> of <span class="ltx_Math" id="SS5.SSS2.p1.m6">\bm{f}^{\text{\tiny cut}}(\bm{x}_{t})</span> and <span class="ltx_Math" id="SS5.SSS2.p1.m7">\bm{J}^{\text{\tiny cut}}(\bm{x}_{t})</span> is defined as</p>
<table class="ltx_equationgroup ltx_eqn_align ltx_eqn_table" id="S8-eq:A5.EGx25">
<tbody id="S8-eq:Ex85"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="Ex85.m1">\displaystyle f^{\text{\tiny cut}}_{i}(x_{t,i})</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="Ex85.m2">\displaystyle=\begin{cases}\textstyle x_{t,i}-x_{i}^{\scriptscriptstyle\min},&amp;\text{if}\ x_{t,i}&lt;x_{i}^{\scriptscriptstyle\min}\\
\textstyle x_{t,i}-x_{i}^{\scriptscriptstyle\max},&amp;\text{if}\ x_{t,i}&gt;x_{i}^{\scriptscriptstyle\max}\\
\textstyle 0,&amp;\text{otherwise}\end{cases},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
<tbody id="S8-eq:Ex89"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="Ex89.m1">\displaystyle J^{\text{\tiny cut}}_{i,i}(x_{t,i})</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="Ex89.m2">\displaystyle=\begin{cases}\textstyle 1,\hskip 39.833858pt&amp;\text{if}\ x_{t,i}&lt;x_{i}^{\scriptscriptstyle\min}\\
\textstyle 1,&amp;\text{if}\ x_{t,i}&gt;x_{i}^{\scriptscriptstyle\max}\\
\textstyle 0,&amp;\text{otherwise}\end{cases},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p class="ltx_p">where <span class="ltx_Math" id="SS5.SSS2.p1.m8">f^{\text{\tiny cut}}_{i}(x_{t,i})</span> describes continuous ReLU-like functions for each dimension. <span class="ltx_Math" id="SS5.SSS2.p1.m9">f^{\text{\tiny cut}}_{i}(x_{t,i})</span> is <span class="ltx_Math" id="SS5.SSS2.p1.m10">0</span> inside the bounded domain and takes the signed distance value outside the boundary, see Fig. <a class="ltx_ref" href="#S8-fig:fcut" title="Figure 19 ‣ 8.5.2 Bounded joint space ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">19</span></a>-<em class="ltx_emph ltx_font_italic">left</em>.</p>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS2.p2">
<p class="ltx_p">We can see with (<a class="ltx_ref" href="#S8-eq:dcdx" title="(113) ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">113</span></a>) that for <span class="ltx_Math" id="SS5.SSS2.p2.m1">\bm{Q}=\frac{1}{2}\bm{I}</span>, if <span class="ltx_Math" id="SS5.SSS2.p2.m2">\bm{x}</span> is outside the domain during some time steps <span class="ltx_Math" id="SS5.SSS2.p2.m3">t</span>, <span class="ltx_Math" id="SS5.SSS2.p2.m4">\bm{g}_{\bm{x}}=\frac{\partial c}{\partial\bm{x}}=2{\bm{J}}^{\scriptscriptstyle\top}\bm{Q}\bm{f}</span> generates a vector bringing it back to the boundary of the domain.</p>
</div>
</div>
<div class="ltx_subsubsection" id="S8-sec:SS5.SSS3">
<h3 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection"><span class="ltx_text">8.5.3</span> </span><span class="ltx_text">Bounded task space</span>
</h3>
<div class="ltx_para" id="S8-para:SS5.SSS3.p1">
<p class="ltx_p">The iLQR solution in (<a class="ltx_ref" href="#S8-eq:du" title="(117) ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">117</span></a>) can be used to keep the endeffector within a boundary (e.g., endeffector position limits).
Based on the above definitions, <span class="ltx_Math" id="SS5.SSS3.p1.m1">\bm{f}(\bm{x})</span> and <span class="ltx_Math" id="SS5.SSS3.p1.m2">\bm{J}(\bm{x})</span> are in this case defined as
</p>
<table class="ltx_equationgroup ltx_eqn_align ltx_eqn_table" id="S8-eq:A5.EGx26">
<tbody id="S8-eq:Ex90"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="Ex90.m1">\displaystyle\bm{f}(\bm{x}_{t})</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="Ex90.m2">\displaystyle=\bm{f}^{\text{\tiny cut}}\Big(\bm{e}(\bm{x}_{t})\Big),</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
<tbody id="S8-eq:Ex91"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="Ex91.m1">\displaystyle\bm{J}(\bm{x}_{t})</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="Ex91.m2">\displaystyle=\bm{J}^{\text{\tiny cut}}\Big(\bm{e}(\bm{x}_{t})\Big)\;\bm{J}^{\text{\tiny ee}}(\bm{x}_{t}),</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
<tbody id="S8-eq:Ex92"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="Ex92.m1">\displaystyle\text{with}\quad\bm{e}(\bm{x}_{t})</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="Ex92.m2">\displaystyle=\bm{f}^{\text{\tiny ee}}(\bm{x}_{t}).</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
</div>
</div>
<div class="ltx_subsubsection" id="S8-sec:reaching">
<h3 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection"><span class="ltx_text">8.5.4</span> </span><span class="ltx_text">Reaching task with robot manipulator and prismatic object boundaries</span>
</h3>
<div class="ltx_para" id="S8-para:SS5.SSS4.p1">
<p class="ltx_p">The definition of <span class="ltx_Math" id="SS5.SSS4.p1.m1">\bm{f}(\bm{x}_{t})</span> and <span class="ltx_Math" id="SS5.SSS4.p1.m2">\bm{J}(\bm{x}_{t})</span> in (<a class="ltx_ref" href="#S8-eq:fJU" title="(118) ‣ 8.5.1 Robot manipulator ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">118</span></a>) can also be extended to objects/landmarks with boundaries by defining</p>
<table class="ltx_equationgroup ltx_eqn_align ltx_eqn_table" id="S8-eq:A5.EGx27">
<tbody id="S8-eq:Ex93"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="Ex93.m1">\displaystyle\bm{f}(\bm{x}_{t})</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="Ex93.m2">\displaystyle=\bm{f}^{\text{\tiny cut}}\Big(\bm{e}(\bm{x}_{t})\Big),</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
<tbody id="S8-eq:Ex94"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="Ex94.m1">\displaystyle\bm{J}(\bm{x}_{t})</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="Ex94.m2">\displaystyle=\bm{J}^{\text{\tiny cut}}\Big(\bm{e}(\bm{x}_{t})\Big)\;\bm{U}_{t}^{\scriptscriptstyle\top}\;\bm{J}^{\text{\tiny ee}}(\bm{x}_{t}),</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
<tbody id="S8-eq:Ex95"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="Ex95.m1">\displaystyle\text{with}\quad\bm{e}(\bm{x}_{t})</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="Ex95.m2">\displaystyle=\bm{U}_{t}^{\scriptscriptstyle\top}\big(\bm{f}^{\text{\tiny ee}}(\bm{x}_{t})-\bm{\mu}_{t}\big),</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p class="ltx_p">see also Fig. <a class="ltx_ref" href="#S8-fig:iLQR_manipulator" title="Figure 20 ‣ 8.5.3 Bounded task space ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">20</span></a>.</p>
</div>
</div>
<div class="ltx_subsubsection" id="S8-sec:iLQR_initStateOptim">
<h3 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection"><span class="ltx_text">8.5.5</span> </span><span class="ltx_text">Initial state optimization</span>
</h3>
<div class="ltx_para" id="S8-para:SS5.SSS5.p1">
<p class="ltx_p">Similarly as in Section <a class="ltx_ref" href="#S7-sec:initStateOptim" title="7.1 LQT with initial state optimization ‣ 7 Linear quadratic tracking (LQT) ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">7.1</span></a>, iLQR can easily be extended to determine the optimal initial state <span class="ltx_Math" id="SS5.SSS5.p1.m1">\bm{x}_{1}</span> together with the optimal control commands <span class="ltx_Math" id="SS5.SSS5.p1.m2">\bm{u}</span>, by defining <span class="ltx_Math" id="SS5.SSS5.p1.m3">\bm{\tilde{u}}={[\bm{x}_{1}^{\scriptscriptstyle\top},\bm{u}^{\scriptscriptstyle\top}]}^{\scriptscriptstyle\top}</span> as a vector concatenating <span class="ltx_Math" id="SS5.SSS5.p1.m4">\bm{x}_{1}</span> and <span class="ltx_Math" id="SS5.SSS5.p1.m5">\bm{u}</span>.</p>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS5.p2">
<p class="ltx_p">If the system evolution is linear, <span class="ltx_Math" id="SS5.SSS5.p2.m1">\bm{x}=\bm{S}\bm{\tilde{u}}</span> with <span class="ltx_Math" id="SS5.SSS5.p2.m2">\bm{S}=[\bm{S}_{\bm{x}},\bm{S}_{\bm{u}}]</span> can additionally be used, as in Section <a class="ltx_ref" href="#S7-sec:initStateOptim" title="7.1 LQT with initial state optimization ‣ 7 Linear quadratic tracking (LQT) ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">7.1</span></a>.</p>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS5.p3">
<p class="ltx_p">By defining <span class="ltx_Math" id="SS5.SSS5.p3.m1">\bm{\tilde{R}}=\begin{bmatrix}\bm{0}&amp;\bm{0}\\
\bm{0}&amp;\bm{R}\end{bmatrix}</span> to remove any constraint on the initial state, the optimization problem to estimate both the initial state <span class="ltx_Math" id="SS5.SSS5.p3.m2">\bm{x}_{1}</span> and the sequence of control commands <span class="ltx_Math" id="SS5.SSS5.p3.m3">\bm{u}</span> then becomes</p>
<table class="ltx_equationgroup ltx_eqn_align ltx_eqn_table" id="S8-eq:A5.EGx28">
<tbody id="S8-eq:E119"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="E119.m1">\displaystyle\min_{\bm{\tilde{u}}}\bm{f}(\bm{x})^{\!{\scriptscriptstyle\top}}\bm{Q}\bm{f}(\bm{x})+\bm{\tilde{u}}^{\scriptscriptstyle\top}\!\bm{\tilde{R}}\bm{\tilde{u}},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(119)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">where <span class="ltx_Math" id="SS5.SSS5.p3.m4">\bm{f}(\bm{x})</span> denotes the concatenation of <span class="ltx_Math" id="SS5.SSS5.p3.m5">\bm{f}(\bm{x}_{t})</span> for all time steps.</p>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS5.p4">
<p class="ltx_p">If only some parts of <span class="ltx_Math" id="SS5.SSS5.p4.m1">\bm{x}_{1}</span> need to be estimated, the corresponding diagonal entries in <span class="ltx_Math" id="SS5.SSS5.p4.m2">\bm{\tilde{R}}</span> can be set with arbitrary high values, by reformulating the minimization problem as</p>
<table class="ltx_equationgroup ltx_eqn_align ltx_eqn_table" id="S8-eq:A5.EGx29">
<tbody id="S8-eq:E120"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="E120.m1">\displaystyle\min_{\bm{\tilde{u}}}\bm{f}(\bm{x})^{\!{\scriptscriptstyle\top}}\bm{Q}\bm{f}(\bm{x})+{(\bm{\tilde{u}}-\bm{\mu})}^{\scriptscriptstyle\top}\!\bm{\tilde{R}}(\bm{\tilde{u}}-\bm{\mu}),</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(120)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">where <span class="ltx_Math" id="SS5.SSS5.p4.m3">\bm{\mu}</span> is a vector containing the initial elements in <span class="ltx_Math" id="SS5.SSS5.p4.m4">\bm{x}_{1}</span> that do not need to be estimated, where the other elements are zero.</p>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS5.p5">
<p class="ltx_p">The above approach can for example be used to estimate the optimal placement of a robot manipulator. For a planar robot, this can for example be implemented by defining the kinematic chain starting with two prismatic joints along the two axes directions, providing a way to represent the location of a free floating platform as two additional prismatic joints in the kinematic chain. If we would like the base of the robot to remain static, we can request that these first two prismatic joints will stay still during the motion. By using the above formulation, this can be done by setting arbitrary large control weights for these corresponding joints, see Figure <a class="ltx_ref" href="#S8-fig:iLQR_initStateOptim" title="Figure 21 ‣ 8.5.5 Initial state optimization ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">21</span></a> and the corresponding source code example.</p>
</div>
</div>
<div class="ltx_subsubsection" id="S8-sec:SS5.SSS6">
<h3 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection"><span class="ltx_text">8.5.6</span> </span><span class="ltx_text">Center of mass</span>
</h3>
<div class="ltx_para" id="S8-para:SS5.SSS6.p1">
<p class="ltx_p">If we assume an equal mass for each link concentrated at the joint (i.e., assuming that the motors and gripper are heavier than the link structures), the forward kinematics function to determine the center of a mass of an articulated chain can simply be computed with</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex96">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex96.m1">\bm{f}^{\text{\tiny CoM}}=\frac{1}{D}\begin{bmatrix}\bm{\ell}^{\scriptscriptstyle\top}\bm{L}\cos(\bm{L}\bm{x})\\
\bm{\ell}^{\scriptscriptstyle\top}\bm{L}\sin(\bm{L}\bm{x})\end{bmatrix},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">which corresponds to the row average of <span class="ltx_Math" id="SS5.SSS6.p1.m1">\tilde{f}</span> in (<a class="ltx_ref" href="#S4-eq:FKall" title="(21) ‣ 4 Forward kinematics (FK) for a planar robot manipulator ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">21</span></a>) for the first two columns (position). The corresponding Jacobian matrix is</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex97">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex97.m1">\bm{J}^{\text{\tiny CoM}}=\frac{1}{D}\begin{bmatrix}-\sin(\bm{L}\bm{x})^{\scriptscriptstyle\top}\bm{L}\;\mathrm{diag}(\bm{\ell}^{\scriptscriptstyle\top}\bm{L})\\
\cos(\bm{L}\bm{x})^{\scriptscriptstyle\top}\bm{L}\;\mathrm{diag}(\bm{\ell}^{\scriptscriptstyle\top}\bm{L})\end{bmatrix}.</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS6.p2">
<p class="ltx_p">The forward kinematics function <span class="ltx_Math" id="SS5.SSS6.p2.m1">\bm{f}^{\text{\tiny CoM}}</span> can be used in tracking tasks similar to the ones considering the endeffector, as in Section <a class="ltx_ref" href="#S8-sec:reaching" title="8.5.4 Reaching task with robot manipulator and prismatic object boundaries ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">8.5.4</span></a>. Fig. <a class="ltx_ref" href="#S8-fig:iLQR_CoM" title="Figure 22 ‣ 8.5.6 Center of mass ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">22</span></a> shows an example in which the starting and ending poses are depicted in different grayscale levels. The corresponding center of mass is depicted by a darker semi-filled disc. The area allowed for the center of mass is depicted as a transparent red rectangle. The task consists of reaching the green object with the endeffector at the end of the movement, while always keeping the center of mass within the desired bounding box during the movement.</p>
</div>
</div>
<div class="ltx_subsubsection" id="S8-sec:SS5.SSS7">
<h3 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection"><span class="ltx_text">8.5.7</span> </span><span class="ltx_text">Bimanual robot</span>
</h3>
<div class="ltx_para" id="S8-para:SS5.SSS7.p1">
<p class="ltx_p">We consider a 5-link planar bimanual robot with a torso link shared by the two arms, see Fig. <a class="ltx_ref" href="#S8-fig:iLQR_bimanual" title="Figure 23 ‣ 8.5.7 Bimanual robot ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">23</span></a>. We define the forward kinematics function as</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex98">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex98.m1">\bm{f}=\begin{bmatrix}\bm{\ell}_{\scriptscriptstyle{[1,2,3]}}^{\scriptscriptstyle\top}\cos(\bm{L}\bm{x}_{\scriptscriptstyle{[1,2,3]}})\\
\bm{\ell}_{\scriptscriptstyle{[1,2,3]}}^{\scriptscriptstyle\top}\sin(\bm{L}\bm{x}_{\scriptscriptstyle{[1,2,3]}})\\
\bm{\ell}_{\scriptscriptstyle{[1,4,5]}}^{\scriptscriptstyle\top}\cos(\bm{L}\bm{x}_{\scriptscriptstyle{[1,4,5]}})\\
\bm{\ell}_{\scriptscriptstyle{[1,4,5]}}^{\scriptscriptstyle\top}\sin(\bm{L}\bm{x}_{\scriptscriptstyle{[1,4,5]}})\\
\end{bmatrix}\!\!,</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">where the first two and last two dimensions of <span class="ltx_Math" id="SS5.SSS7.p1.m1">\bm{f}</span> correspond to the position of the left and right endeffectors, respectively. The corresponding Jacobian matrix <span class="ltx_Math" id="SS5.SSS7.p1.m2">\bm{J}\in\mathbb{R}^{4\times 5}</span> has entries</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex99">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex99.m1">\bm{J}_{\scriptscriptstyle{[1,2],[1,2,3]}}=\begin{bmatrix}-\sin(\bm{L}\bm{x}_{\scriptscriptstyle{[1,2,3]}})^{\scriptscriptstyle\top}\mathrm{diag}(\bm{\ell}_{\scriptscriptstyle{[1,2,3]}})\bm{L}\\
\cos(\bm{L}\bm{x}_{\scriptscriptstyle{[1,2,3]}})^{\scriptscriptstyle\top}\mathrm{diag}(\bm{\ell}_{\scriptscriptstyle{[1,2,3]}})\bm{L}\end{bmatrix},\quad\bm{J}_{\scriptscriptstyle{[3,4],[1,4,5]}}=\begin{bmatrix}-\sin(\bm{L}\bm{x}_{\scriptscriptstyle{[1,4,5]}})^{\scriptscriptstyle\top}\mathrm{diag}(\bm{\ell}_{\scriptscriptstyle{[1,4,5]}})\bm{L}\\
\cos(\bm{L}\bm{x}_{\scriptscriptstyle{[1,4,5]}})^{\scriptscriptstyle\top}\mathrm{diag}(\bm{\ell}_{\scriptscriptstyle{[1,4,5]}})\bm{L}\end{bmatrix},\\
</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">where the remaining entries are zeros.
</p>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS7.p2">
<p class="ltx_p">If we assume a unit mass for each arm link concentrated at the joint and a mass of two units at the tip of the first link (i.e., assuming that the motors and gripper are heavier than the link structures, and that two motors are located at the tip of the first link to control the left and right arms), the forward kinematics function to determine the center of a mass of the bimanual articulated chain in Fig. <a class="ltx_ref" href="#S8-fig:iLQR_bimanual" title="Figure 23 ‣ 8.5.7 Bimanual robot ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">23</span></a> can be computed with</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex100">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex100.m1">\bm{f}^{\text{\tiny CoM}}=\frac{1}{6}\begin{bmatrix}\bm{\ell}_{\scriptscriptstyle{[1,2,3]}}^{\scriptscriptstyle\top}\bm{L}\cos(\bm{L}\bm{x}_{\scriptscriptstyle{[1,2,3]}})+\bm{\ell}_{\scriptscriptstyle{[1,4,5]}}^{\scriptscriptstyle\top}\bm{L}\cos(\bm{L}\bm{x}_{\scriptscriptstyle{[1,4,5]}})\\
\bm{\ell}_{\scriptscriptstyle{[1,2,3]}}^{\scriptscriptstyle\top}\bm{L}\sin(\bm{L}\bm{x}_{\scriptscriptstyle{[1,2,3]}})+\bm{\ell}_{\scriptscriptstyle{[1,4,5]}}^{\scriptscriptstyle\top}\bm{L}\sin(\bm{L}\bm{x}_{\scriptscriptstyle{[1,4,5]}})\end{bmatrix},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">with the corresponding Jacobian matrix <span class="ltx_Math" id="SS5.SSS7.p2.m1">\bm{J}^{\text{\tiny CoM}}\in\mathbb{R}^{2\times 5}</span> computed as</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex101">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex101.m1">\bm{J}^{\text{\tiny CoM}}=\begin{bmatrix}\bm{J}^{\text{\tiny CoM-L}}_{[1,2],1}+\bm{J}^{\text{\tiny CoM-R}}_{[1,2],1},&amp;\bm{J}^{\text{\tiny CoM-L}}_{[1,2],[2,3]},&amp;\bm{J}^{\text{\tiny CoM-R}}_{[1,2],[2,3]}\end{bmatrix},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex102">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex102.m1">\text{with}\quad\bm{J}^{\text{\tiny CoM-L}}=\frac{1}{6}\begin{bmatrix}-\sin(\bm{L}\bm{x}_{\scriptscriptstyle{[1,2,3]}})^{\scriptscriptstyle\top}\bm{L}\;\mathrm{diag}(\bm{\ell}_{\scriptscriptstyle{[1,2,3]}}^{\scriptscriptstyle\top}\bm{L})\\
\cos(\bm{L}\bm{x}_{\scriptscriptstyle{[1,2,3]}})^{\scriptscriptstyle\top}\bm{L}\;\mathrm{diag}(\bm{\ell}_{\scriptscriptstyle{[1,2,3]}}^{\scriptscriptstyle\top}\bm{L})\end{bmatrix},\quad\bm{J}^{\text{\tiny CoM-R}}=\frac{1}{6}\begin{bmatrix}-\sin(\bm{L}\bm{x}_{\scriptscriptstyle{[1,4,5]}})^{\scriptscriptstyle\top}\bm{L}\;\mathrm{diag}(\bm{\ell}_{\scriptscriptstyle{[1,4,5]}}^{\scriptscriptstyle\top}\bm{L})\\
\cos(\bm{L}\bm{x}_{\scriptscriptstyle{[1,4,5]}})^{\scriptscriptstyle\top}\bm{L}\;\mathrm{diag}(\bm{\ell}_{\scriptscriptstyle{[1,4,5]}}^{\scriptscriptstyle\top}\bm{L})\end{bmatrix}.</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
</div>
<div class="ltx_subsubsection" id="S8-sec:SS5.SSS8">
<h3 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection"><span class="ltx_text">8.5.8</span> </span><span class="ltx_text">Obstacle avoidance with ellipsoid shapes</span>
</h3>
<div class="ltx_para" id="S8-para:SS5.SSS8.p1">
<p class="ltx_p">By taking as example a point-mass system, iLQR can be used to solve an ellipsoidal obstacle avoidance problem with the cost (typically used with other costs, see Fig. <a class="ltx_ref" href="#S8-fig:iLQR_obstacle" title="Figure 24 ‣ 8.5.8 Obstacle avoidance with ellipsoid shapes ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">24</span></a> for an example). We first define a ReLU-like function and its gradient as (see also Fig. <a class="ltx_ref" href="#S8-fig:fcut" title="Figure 19 ‣ 8.5.2 Bounded joint space ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">19</span></a>-<em class="ltx_emph ltx_font_italic">right</em>)</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex103">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex103.m1">f^{\text{\tiny avoid}}(d)=\begin{cases}0,&amp;\text{if}\ d&gt;1\\
1-d,&amp;\text{otherwise}\end{cases},\quad\quad g^{\text{\tiny avoid}}(d)=\begin{cases}0,\hskip 17.071654pt&amp;\text{if}\ d&gt;1\\
-1,&amp;\text{otherwise}\end{cases},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">that we exploit to define <span class="ltx_Math" id="SS5.SSS8.p1.m1">\bm{f}(\bm{x}_{t})</span> and <span class="ltx_Math" id="SS5.SSS8.p1.m2">\bm{J}(\bm{x}_{t})</span> in (<a class="ltx_ref" href="#S8-eq:du" title="(117) ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">117</span></a>) as
</p>
<table class="ltx_equationgroup ltx_eqn_align ltx_eqn_table" id="S8-eq:A5.EGx30">
<tbody id="S8-eq:Ex104"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="Ex104.m1">\displaystyle\bm{f}(\bm{x}_{t})</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="Ex104.m2">\displaystyle=f^{\text{\tiny avoid}}\Big(e(\bm{x}_{t})\Big),\quad\quad\bm{J}(\bm{x}_{t})=2\;g^{\text{\tiny avoid}}\Big(e(\bm{x}_{t})\Big)\;{(\bm{x}_{t}-\bm{\mu})}^{\scriptscriptstyle\top}\;\bm{\Sigma}^{-1},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
<tbody id="S8-eq:Ex105"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="Ex105.m1">\displaystyle\text{with}\quad e(\bm{x}_{t})</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="Ex105.m2">\displaystyle={(\bm{x}_{t}-\bm{\mu})}^{\scriptscriptstyle\top}\bm{\Sigma}^{-1}(\bm{x}_{t}-\bm{\mu}).</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS8.p2">
<p class="ltx_p">In the above, <span class="ltx_Math" id="SS5.SSS8.p2.m1">\bm{f}(\bm{x})</span> defines a continuous function that is <span class="ltx_Math" id="SS5.SSS8.p2.m2">0</span> outside the obstacle boundaries and <span class="ltx_Math" id="SS5.SSS8.p2.m3">1</span> at the center of the obstacle. The ellipsoid is defined by a center <span class="ltx_Math" id="SS5.SSS8.p2.m4">\bm{\mu}</span> and a shape <span class="ltx_Math" id="SS5.SSS8.p2.m5">\bm{\Sigma}=\bm{V}\bm{V}^{\scriptscriptstyle\top}</span>, where <span class="ltx_Math" id="SS5.SSS8.p2.m6">\bm{V}</span> is a horizontal concatenation of vectors <span class="ltx_Math" id="SS5.SSS8.p2.m7">\bm{V}_{i}</span> describing the principal axes of the ellipsoid, see Fig. <a class="ltx_ref" href="#S8-fig:iLQR_obstacle" title="Figure 24 ‣ 8.5.8 Obstacle avoidance with ellipsoid shapes ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">24</span></a>.
</p>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS8.p3">
<p class="ltx_p">A similar principle can be applied to robot manipulators by composing forward kinematics and obstacle avoidance functions.</p>
</div>
</div>
<div class="ltx_subsubsection" id="S8-sec:SS5.SSS9">
<h3 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection"><span class="ltx_text">8.5.9</span> </span><span class="ltx_text">Maintaining a desired distance to an object</span>
</h3>
<div class="ltx_para" id="S8-para:SS5.SSS9.p1">
<p class="ltx_p">The obstacle example above can easily be extended to the problem of maintaining a desired distance to an object, which can also typically used with other objectives. We first define a function and a gradient</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex106">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex106.m1">f^{\text{\tiny dist}}(d)=1-d,\quad\quad g^{\text{\tiny dist}}(d)=-1,</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">that we exploit to define <span class="ltx_Math" id="SS5.SSS9.p1.m1">\bm{f}(\bm{x}_{t})</span> and <span class="ltx_Math" id="SS5.SSS9.p1.m2">\bm{J}(\bm{x}_{t})</span> in (<a class="ltx_ref" href="#S8-eq:du" title="(117) ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">117</span></a>) as</p>
<table class="ltx_equationgroup ltx_eqn_align ltx_eqn_table" id="S8-eq:A5.EGx31">
<tbody id="S8-eq:Ex107"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="Ex107.m1">\displaystyle\bm{f}(\bm{x}_{t})</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="Ex107.m2">\displaystyle=f^{\text{\tiny dist}}\Big(e(\bm{x}_{t})\Big),\quad\quad\bm{J}(\bm{x}_{t})=-\frac{2}{r^{2}}{(\bm{x}_{t}-\bm{\mu})}^{\scriptscriptstyle\top},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
<tbody id="S8-eq:Ex108"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="Ex108.m1">\displaystyle\text{with}\quad e(\bm{x}_{t})</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="Ex108.m2">\displaystyle=\frac{1}{r^{2}}{(\bm{x}_{t}-\bm{\mu})}^{\scriptscriptstyle\top}(\bm{x}_{t}-\bm{\mu}).</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS9.p2">
<p class="ltx_p">In the above, <span class="ltx_Math" id="SS5.SSS9.p2.m1">\bm{f}(\bm{x})</span> defines a continuous function that is <span class="ltx_Math" id="SS5.SSS9.p2.m2">0</span> on a sphere of radius <span class="ltx_Math" id="SS5.SSS9.p2.m3">r</span> centered on the object (defined by a center <span class="ltx_Math" id="SS5.SSS9.p2.m4">\bm{\mu}</span>), and increasing/decreasing when moving away from this surface in one direction or the other.</p>
</div>
</div>
<div class="ltx_subsubsection" id="S8-sec:SS5.SSS10">
<h3 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection"><span class="ltx_text">8.5.10</span> </span><span class="ltx_text">Manipulability tracking</span>
</h3>
<div class="ltx_para" id="S8-para:SS5.SSS10.p1">
<p class="ltx_p">Skills transfer can exploit manipulability ellipsoids in the form of geometric descriptors representing the skills to be transferred to the robot. As these ellipsoids lie on symmetric positive definite (SPD) manifolds, Riemannian geometry can be used to learn and reproduce these descriptors in a probabilistic manner <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="#bib-bib:bib11" title="Gaussians on Riemannian manifolds: applications for robot learning and adaptive control">3</a>]</cite>.</p>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS10.p2">
<p class="ltx_p">Manipulability ellipsoids come in different flavors. They can be defined for either positions or forces (including the orientation/rotational part). Manipulability can be described at either kinematic or dynamic levels, for either open or closed linkages (e.g., for bimanual manipulation or in-hand manipulation), and for either actuated or non-actuated joints <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="#bib-bib:bib15" title="Manipulability of closed kinematic chains">16</a>]</cite>. This large set of manipulability ellipsoids provide rich descriptors to characterize robot skills for robots with legs and arms.</p>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS10.p3">
<p class="ltx_p">Manipulability ellipsoids are helpful descriptors to handle skill transfer problems involving dissimilar kinematic chains, such as transferring manipulation skills between humans and robots, or between two robots with different kinematic chains or capabilities. In such transfer problems, imitation at joint angles level is not possible due to the different structures, and imitation at endeffector(s) level is limited, because it does not encapsulate postural information, which is often an essential aspect of the skill that we would like to transfer. Manipulability ellipsoids provide intermediate descriptors that allows postural information to be transferred indirectly, with the advantage that it allows different embodiments and capabilities to be considered in the skill transfer process.</p>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS10.p4">
<p class="ltx_p">The manipulability ellipsoid <span class="ltx_Math" id="SS5.SSS10.p4.m1">\bm{M}(\bm{x})=\bm{J}(\bm{x}){\bm{J}(\bm{x})}^{\scriptscriptstyle\top}</span> is a symmetric positive definite matrix representing the manipulability at a given point on the kinematic chain defined by a forward kinematics function <span class="ltx_Math" id="SS5.SSS10.p4.m2">\bm{f}(\bm{x})</span>, given the joint angle posture <span class="ltx_Math" id="SS5.SSS10.p4.m3">\bm{x}</span>, where <span class="ltx_Math" id="SS5.SSS10.p4.m4">\bm{J}(\bm{x})</span> is the Jacobian of <span class="ltx_Math" id="SS5.SSS10.p4.m5">\bm{f}(\bm{x})</span>. The determinant of <span class="ltx_Math" id="SS5.SSS10.p4.m6">\bm{M}(\bm{x})</span> is often used as a scalar manipulability index indicating the volume of the ellipsoid <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="#bib-bib:bib14" title="Dynamic manipulability of robot manipulators">19</a>]</cite>, with the drawback of ignoring the specific shape of this ellipsoid.</p>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS10.p5">
<p class="ltx_p">In <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="#bib-bib:bib13" title="Geometry-aware manipulability learning, tracking and transfer">7</a>]</cite>, we showed that a geometric cost on manipulability can alternatively be defined with the geodesic distance</p>
<table class="ltx_equationgroup ltx_eqn_align ltx_eqn_table" id="S8-eq:A5.EGx32">
<tbody id="S8-eq:Ex109"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="Ex109.m1">\displaystyle c</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="Ex109.m2">\displaystyle=\|\bm{A}\|^{2}_{\text{F}},\quad\text{with}\quad\bm{A}=\log\!\big(\bm{S}^{-\frac{1}{2}}\bm{M}(\bm{x})\bm{S}^{-\frac{1}{2}}\big),</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
<tbody id="S8-eq:cManipulability"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="E121.m1">\displaystyle\iff\;c</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="E121.m2">\displaystyle=\text{trace}(\bm{A}\bm{A}^{\scriptscriptstyle\top})=\sum_{i}\text{trace}(\bm{A}_{i}\bm{A}_{i}^{\scriptscriptstyle\top})=\sum_{i}\bm{A}_{i}^{\scriptscriptstyle\top}\bm{A}_{i}={\text{vec}(\bm{A})}^{\scriptscriptstyle\top}\text{vec}(\bm{A}),</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(121)</span></td>
</tr></tbody>
</table>
<p class="ltx_p">where <span class="ltx_Math" id="SS5.SSS10.p5.m1">\bm{S}</span> is the desired manipulability matrix to reach, <span class="ltx_Math" id="SS5.SSS10.p5.m2">\log(\cdot)</span> is the logarithm matrix function, and <span class="ltx_Math" id="SS5.SSS10.p5.m3">\|\cdot\|_{\text{F}}</span> is a Frobenius norm. By exploiting the trace properties, we can see that (<a class="ltx_ref" href="#S8-eq:cManipulability" title="(121) ‣ 8.5.10 Manipulability tracking ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">121</span></a>) can be expressed in a quadratic form, where the vectorization operation <span class="ltx_Math" id="SS5.SSS10.p5.m4">\text{vec}(\bm{A})</span> can be computed efficiently by exploiting the symmetry of the matrix <span class="ltx_Math" id="SS5.SSS10.p5.m5">\bm{A}</span>. This is implemented by keeping only the lower half of the matrix, with the elements below the diagonal multiplied by a factor <span class="ltx_Math" id="SS5.SSS10.p5.m6">\sqrt{2}</span>.
</p>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS10.p6">
<p class="ltx_p">The derivatives of (<a class="ltx_ref" href="#S8-eq:cManipulability" title="(121) ‣ 8.5.10 Manipulability tracking ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">121</span></a>) with respect to the state <span class="ltx_Math" id="SS5.SSS10.p6.m1">\bm{x}</span> and control commands <span class="ltx_Math" id="SS5.SSS10.p6.m2">\bm{u}</span> can be computed numerically (as in the provided example), analytically (by following an approach similar to the one presented in <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="#bib-bib:bib13" title="Geometry-aware manipulability learning, tracking and transfer">7</a>]</cite>), or by automatic differentiation. The quadratic form of (<a class="ltx_ref" href="#S8-eq:cManipulability" title="(121) ‣ 8.5.10 Manipulability tracking ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">121</span></a>) can be exploited to solve the problem with Gauss–Newton optimization, by using Jacobians (see description in Section <a class="ltx_ref" href="#S5-sec:IKnum" title="5.1 Numerical estimation of the Jacobian ‣ 5 Inverse kinematics (IK) for a planar robot manipulator ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">5.1</span></a> within the context of inverse kinematics). Marić <em class="ltx_emph ltx_font_italic">et al.</em> demonstrated the advantages of a geometric cost as in (<a class="ltx_ref" href="#S8-eq:cManipulability" title="(121) ‣ 8.5.10 Manipulability tracking ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">121</span></a>) for planning problems, by comparing it to alternative widely used metrics such as the manipulability index and the dexterity index <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="#bib-bib:bib16" title="A Riemannian metric for geometry-aware singularity avoidance by articulated robots">9</a>]</cite>.</p>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS10.p7">
<p class="ltx_p">Note here that manipulability can be defined at several points of interest, including endeffectors and centers of mass. Figure <a class="ltx_ref" href="#S8-fig:iLQR_manipulability" title="Figure 25 ‣ 8.5.10 Manipulability tracking ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">25</span></a> presents a simple example with a bimanual robot. Manipulability ellipsoids can also be exploited as descriptors for object affordances, by defining manipulability at the level of specific points on objects or tools held by the robot. For example, we can consider a manipulability ellipsoid at the level of the head of a hammer. When the robot grasps the hammer, its endeffector is extended so that the head of the hammer becomes the extremity of the kinematic chain. In this situation, the different options that the robot has to grasp the hammer will have an impact on the resulting manipulability at the head of the hammer. Thus, grabbing the hammer at the extremity of the handle will improve the resulting manipulability. Such descriptors offer promises for learning and optimization in manufacturing environments, in order to let robots automatically determine the correct ways to employ tools, including grasping points and body postures.
</p>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS10.p8">
<p class="ltx_p">The above iLQR approach, with a geodesic cost on SPD manifolds, has been presented for manipulability ellipsoids, but it can be extended to other descriptors represented as ellipsoids. In particular, stiffness, feedback gains, inertia, and centroidal momentum have similar structures. For the latter, the centroidal momentum ellipsoid quantifies the momentum generation ability of the robot <cite class="ltx_cite ltx_citemacro_cite">[<a class="ltx_ref" href="#bib-bib:bib17" title="Centroidal momentum matrix of a humanoid robot: structure and properties">14</a>]</cite>, which is another useful descriptor for robotics skills. Similarly to manipulability ellipsoids, it is constructed from Jacobians, which are in this case the centroidal momentum matrices mapping the joint angle velocities to the centroidal momentum, which sums over the individual link momenta after projecting each to the robot’s center of mass.</p>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS10.p9">
<p class="ltx_p">The approach can also be extended to other forms of symmetric positive definite matrices, such as kernel matrices used in machine learning algorithms to compute similarities, or graph graph Laplacians (a matrix representation of a graph that can for example be used to construct a low dimensional embedding of a graph).</p>
</div>
</div>
<div class="ltx_subsubsection" id="S8-sec:SS5.SSS11">
<h3 class="ltx_title ltx_title_subsubsection">
<span class="ltx_tag ltx_tag_subsubsection"><span class="ltx_text">8.5.11</span> </span><span class="ltx_text">Decoupling of control commands</span>
</h3>
<div class="ltx_para" id="S8-para:SS5.SSS11.p1">
<p class="ltx_p">In some situations, we would like to control a robot by avoiding that all degrees of freedom are controlled at the same time. For example, we might in some cases prefer that a mobile manipulator stops moving the arm while the platform is moving and vice versa.</p>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS11.p2">
<p class="ltx_p">For a 2 DOFs robot controlled at each time step <span class="ltx_Math" id="SS5.SSS11.p2.m1">t</span> with two control command <span class="ltx_Math" id="SS5.SSS11.p2.m2">u_{1,t}</span> and <span class="ltx_Math" id="SS5.SSS11.p2.m3">u_{2,t}</span>, the corresponding cost to find the full sequence of control commands for a duration <span class="ltx_Math" id="SS5.SSS11.p2.m4">T</span> (gathered in a concatenated vector <span class="ltx_Math" id="SS5.SSS11.p2.m5">\bm{u}</span>) is</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex110">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex110.m1">\min_{\bm{u}}\;\sum_{t=1}^{T}\,{(u_{1,t}\,u_{2,t})}^{2},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">with corresponding residuals and Jacobian given by</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex111">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex111.m1">r_{t}=u_{1,t}\,u_{2,t},\quad\bm{J}_{t}=\big[u_{2,t},\,u_{1,t}\big],\quad\forall t\in\{1,\ldots,T\}.</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS11.p3">
<p class="ltx_p">The Gauss–Newton update rule in concatenated vector form is given by</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex112">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex112.m1">\bm{u}_{k+1}\;\leftarrow\;\bm{u}_{k}-\alpha\,{\big(\bm{J}^{\scriptscriptstyle\top}\bm{J}\big)}^{\!-1}\,\bm{J}^{\scriptscriptstyle\top}\,\bm{r},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">where <span class="ltx_Math" id="SS5.SSS11.p3.m1">\alpha</span> is a line search parameter, <span class="ltx_Math" id="SS5.SSS11.p3.m2">\bm{r}</span> is a vector concatenating vertically all residuals <span class="ltx_Math" id="SS5.SSS11.p3.m3">r_{t}</span>, and <span class="ltx_Math" id="SS5.SSS11.p3.m4">\bm{J}</span> is a Jacobian matrix with <span class="ltx_Math" id="SS5.SSS11.p3.m5">\bm{J}_{t}</span> as block diagonal elements. With some linear algebra machinery, this can also be computed in batch form using <span class="ltx_Math" id="SS5.SSS11.p3.m6">\bm{r}=\bm{u}_{1}\odot\bm{u}_{2}</span>, and <span class="ltx_Math" id="SS5.SSS11.p3.m7">\bm{J}=(\bm{I}_{T-1}\otimes\bm{1}_{1\times 2})\;\text{diag}\Big(\big(\bm{I}_{T-1}\otimes(\bm{1}_{2\times 2}-\bm{I}_{2})\big)\bm{u}\Big)</span>, with <span class="ltx_Math" id="SS5.SSS11.p3.m8">\odot</span> and <span class="ltx_Math" id="SS5.SSS11.p3.m9">\otimes</span> the elementwise product and Kronecker product operators, respectively.</p>
</div>
<div class="ltx_para" id="S8-para:SS5.SSS11.p4">
<p class="ltx_p">Figure <a class="ltx_ref" href="#S8-fig:iLQR_decoupling" title="Figure 26 ‣ 8.5.11 Decoupling of control commands ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">26</span></a> presents a simple example within a 2D reaching problem with a point mass agent and velocity commands.</p>
</div>
</div>
</div><div class="ltx_subsection" id="S8-sec:SS6">
<h2 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span class="ltx_text">8.6</span> </span><span class="ltx_text">iLQR with control primitives</span>
</h2>
<div class="ltx_para" id="S8-para:SS6.p1">
<p class="ltx_p">The use of control primitives can be extended to iLQR, by considering <span class="ltx_Math" id="SS6.p1.m1">\Delta\bm{u}=\bm{\Psi}\Delta\bm{w}</span>.
For problems with quadratic cost on <span class="ltx_Math" id="SS6.p1.m2">\bm{f}(\bm{x}_{t})</span> (see previous Section), the update of the weights vector is then given by</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:dw">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E122.m1">\Delta\bm{\hat{w}}\!=\!{\Big(\bm{\Psi}^{\!{\scriptscriptstyle\top}}\bm{S}_{\bm{u}}^{\scriptscriptstyle\top}\bm{J}(\bm{x})^{\scriptscriptstyle\top}\bm{Q}\bm{J}(\bm{x})\bm{S}_{\bm{u}}\bm{\Psi}+\bm{\Psi}^{\!{\scriptscriptstyle\top}}\bm{R}\,\bm{\Psi}\Big)}^{\!\!-1}\Big(-\bm{\Psi}^{\!{\scriptscriptstyle\top}}\bm{S}_{\bm{u}}^{\scriptscriptstyle\top}\bm{J}(\bm{x})^{\scriptscriptstyle\top}\bm{Q}\bm{f}(\bm{x})-\bm{\Psi}^{\!{\scriptscriptstyle\top}}\bm{R}\,\bm{u}\Big).</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(122)</span></td>
</tr>
</table>
</div>
<div class="ltx_para" id="S8-para:SS6.p2">
<p class="ltx_p">For a 5-link kinematic chain, by setting the coordination matrix in (<a class="ltx_ref" href="#S7-eq:Psi2" title="(75) ‣ 7.3 LQT with control primitives ‣ 7 Linear quadratic tracking (LQT) ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">75</span></a>) as</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex113">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex113.m1">\bm{C}=\begin{bmatrix}-1&amp;0&amp;0\\
2&amp;0&amp;0\\
-1&amp;0&amp;0\\
0&amp;1&amp;0\\
0&amp;0&amp;1\end{bmatrix},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">the first three joints are coordinated such that the third link is always oriented in the same direction, while the last two joints can move independently. Figure <a class="ltx_ref" href="#S8-fig:iLQR_humanoid" title="Figure 27 ‣ 8.6 iLQR with control primitives ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">27</span></a> shows an example for a reaching task, with the 5-link kinematic chain depicting a humanoid robot that needs to keep its torso upright.</p>
</div>
<div class="ltx_para" id="S8-para:SS6.p3">
<p class="ltx_p">Note also that the iLQR updates in (<a class="ltx_ref" href="#S8-eq:dw" title="(122) ‣ 8.6 iLQR with control primitives ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">122</span></a>) can usually be computed faster than in the original formulation, since a matrix of much smaller dimension needs to be inverted.
</p>
</div>
</div><div class="ltx_subsection" id="S8-sec:SS7">
<h2 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span class="ltx_text">8.7</span> </span><span class="ltx_text">iLQR for spacetime optimization</span>
</h2>
<div class="ltx_para" id="S8-para:SS7.p1">
<p class="ltx_p">We define a phase variable <span class="ltx_Math" id="SS7.p1.m1">s_{t}</span> starting from <span class="ltx_Math" id="SS7.p1.m2">s_{1}=0</span> at the beginning of the movement.
With an augmented state <span class="ltx_Math" id="SS7.p1.m3">\bm{x}_{t}={[\mathbf{x}_{t}^{\scriptscriptstyle\top},s_{t}]}^{\scriptscriptstyle\top}</span> and control command <span class="ltx_Math" id="SS7.p1.m4">\bm{u}_{t}={[{\bm{u}^{\mathbf{x}}_{t}}^{\scriptscriptstyle\top},u^{s}_{t}]}^{\scriptscriptstyle\top}</span>, we define the evolution of the system <span class="ltx_Math" id="SS7.p1.m5">\bm{x}_{t+1}=\bm{d}(\bm{x}_{t},\bm{u}_{t})</span> as</p>
<table class="ltx_equationgroup ltx_eqn_align ltx_eqn_table" id="S8-eq:A5.EGx33">
<tbody id="S8-eq:Ex114"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="Ex114.m1">\displaystyle\mathbf{x}_{t+1}</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="Ex114.m2">\displaystyle=\mathbf{A}_{t}\mathbf{x}_{t}+\mathbf{B}_{t}\bm{u}^{\mathbf{x}}_{t}\,u^{s}_{t},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
<tbody id="S8-eq:Ex115"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="Ex115.m1">\displaystyle s_{t+1}</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="Ex115.m2">\displaystyle=s_{t}+u^{s}_{t}.</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
</div>
<div class="ltx_para" id="S8-para:SS7.p2">
<p class="ltx_p">Its first order Taylor expansion around <span class="ltx_Math" id="SS7.p2.m1">\bm{\hat{x}},\bm{\hat{u}}</span> provides the linear system</p>
<table class="ltx_equationgroup ltx_eqn_align ltx_eqn_table" id="S8-eq:A5.EGx34">
<tbody id="S8-eq:Ex126"><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_td ltx_align_right ltx_eqn_cell"><span class="ltx_Math" id="Ex126.m1">\displaystyle\underbrace{\begin{bmatrix}\textstyle\Delta\mathbf{x}_{t+1}\\
\textstyle\Delta s_{t+1}\end{bmatrix}}_{\Delta\bm{x}_{t+1}}</span></td>
<td class="ltx_td ltx_align_left ltx_eqn_cell"><span class="ltx_Math" id="Ex126.m2">\displaystyle=\underbrace{\begin{bmatrix}\textstyle\mathbf{A}_{t}&amp;\bm{0}\\
\textstyle\bm{0}&amp;1\end{bmatrix}}_{\bm{A}_{t}}\underbrace{\begin{bmatrix}\textstyle\Delta\mathbf{x}_{t}\\
\textstyle\Delta s_{t}\end{bmatrix}}_{\Delta\bm{x}_{t}}+\underbrace{\begin{bmatrix}\textstyle\mathbf{B}_{t}u^{s}_{t}&amp;\mathbf{B}_{t}\bm{u}^{\mathbf{x}}_{t}\\
\textstyle\bm{0}&amp;1\end{bmatrix}}_{\bm{B}_{t}}\underbrace{\begin{bmatrix}\textstyle\Delta\bm{u}^{\mathbf{x}}_{t}\\
\textstyle\Delta u^{s}_{t}\end{bmatrix}}_{\Delta\bm{u}_{t}},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p class="ltx_p">with Jacobian matrices <span class="ltx_Math" id="SS7.p2.m2">\bm{A}_{t}\!=\!\frac{\partial\bm{d}}{\partial\bm{x}_{t}}</span>, <span class="ltx_Math" id="SS7.p2.m3">\bm{B}_{t}\!=\!\frac{\partial\bm{d}}{\partial\bm{u}_{t}}</span>. Note that in the above equations, we used here the notation <span class="ltx_Math" id="SS7.p2.m4">\mathbf{x}_{t}</span> and <span class="ltx_Math" id="SS7.p2.m5">\bm{x}_{t}</span> to describe the standard state and augmented state, respectively. We similarly used <span class="ltx_Math" id="SS7.p2.m6">\{\mathbf{A}_{t},\mathbf{B}_{t}\}</span> and <span class="ltx_Math" id="SS7.p2.m7">\{\bm{A}_{t},\bm{B}_{t}\}</span> (with slanted font) for standard linear system and augmented linear system.</p>
</div>
<div class="ltx_para" id="S8-para:SS7.p3">
<p class="ltx_p">Figure <a class="ltx_ref" href="#S8-fig:iLQR_spacetime" title="Figure 28 ‣ 8.7 iLQR for spacetime optimization ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">28</span></a> shows a viapoints task example in which both path and duration are optimized (convergence after 10 iterations when starting from zero commands). The example uses a double integrator as linear system defined by constant <span class="ltx_Math" id="SS7.p3.m1">\mathbf{A}_{t}</span> and <span class="ltx_Math" id="SS7.p3.m2">\mathbf{B}_{t}</span> matrices.</p>
</div>
</div><div class="ltx_subsection" id="S8-sec:SS8">
<h2 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span class="ltx_text">8.8</span> </span><span class="ltx_text">iLQR with offdiagonal elements in the precision matrix</span>
</h2>
<div class="ltx_para" id="S8-para:SS8.p1">
<p class="ltx_p">Spatial and/or temporal constraints can be considered by setting <span class="ltx_Math" id="SS8.p1.m1">\left[\begin{smallmatrix}\bm{I}&amp;-\bm{I}\\
-\bm{I}&amp;\bm{I}\end{smallmatrix}\right]</span> in the corresponding entries of the precision matrix <span class="ltx_Math" id="SS8.p1.m2">\bm{Q}</span>. With this formulation, we can constrain two positions to be the same without having to predetermine the position at which the two should meet. Indeed, we can see that a cost <span class="ltx_Math" id="SS8.p1.m3">c\!=\!\left[\begin{smallmatrix}x_{i}\\
x_{j}\end{smallmatrix}\right]^{\scriptscriptstyle\top}\left[\begin{smallmatrix}1&amp;-1\\
-1&amp;1\end{smallmatrix}\right]\left[\begin{smallmatrix}x_{i}\\
x_{j}\end{smallmatrix}\right]\!=\!(x_{i}-x_{j})^{2}</span> is minimized when <span class="ltx_Math" id="SS8.p1.m4">x_{i}\!=\!x_{j}</span>.</p>
</div>
<div class="ltx_para" id="S8-para:SS8.p2">
<p class="ltx_p">Such cost can for example be used to define costs on object affordances, see Fig. <a class="ltx_ref" href="#S8-fig:iLQR_manipulator_objAffordances" title="Figure 29 ‣ 8.8 iLQR with offdiagonal elements in the precision matrix ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">29</span></a> for an example.</p>
</div>
</div><div class="ltx_subsection" id="S8-sec:SS9">
<h2 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span class="ltx_text">8.9</span> </span><span class="ltx_text">Car steering</span>
</h2>
<div class="ltx_para ltx_noindent" id="S8-para:SS9.p1">
<p class="ltx_p"><span class="ltx_text ltx_font_bold">Velocity Control Input</span>
<br class="ltx_break"/>A car motion with position <span class="ltx_Math" id="SS9.p1.m1">(x_{1},x_{2})</span>, car orientation <span class="ltx_Math" id="SS9.p1.m2">\theta</span>, and front wheels orientation <span class="ltx_Math" id="SS9.p1.m3">\phi</span> (see Fig. <a class="ltx_ref" href="#S8-fig:iLQR_car_bicopter" title="Figure 30 ‣ 8.9 Car steering ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">30</span></a>-<em class="ltx_emph ltx_font_italic">left</em>) is characterized by equations</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex127">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex127.m1">\dot{x}_{1}=u_{1}\cos(\theta),\quad\dot{x}_{2}=u_{1}\sin(\theta),\quad\dot{\theta}=\frac{u_{1}}{\ell}\tan(\phi),\quad\dot{\phi}=u_{2},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">where <span class="ltx_Math" id="SS9.p1.m4">\ell</span> is the distance between the front and back axles, <span class="ltx_Math" id="SS9.p1.m5">u_{1}</span> is the back wheels velocity command and <span class="ltx_Math" id="SS9.p1.m6">u_{2}</span> is the front wheels steering velocity command.
Its first order Taylor expansion around <span class="ltx_Math" id="SS9.p1.m7">(\hat{\theta},\hat{\phi},\hat{u}_{1})</span> is</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:E123">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E123.m1">\footnotesize\begin{bmatrix}\Delta\dot{x}_{1}\\
\Delta\dot{x}_{2}\\
\Delta\dot{\theta}\\
\Delta\dot{\phi}\end{bmatrix}=\begin{bmatrix}0&amp;0&amp;-\hat{u}_{1}\sin(\hat{\theta})&amp;0\\
0&amp;0&amp;\hat{u}_{1}\cos(\hat{\theta})&amp;0\\
0&amp;0&amp;0&amp;\frac{\hat{u}_{1}}{\ell}(\tan(\hat{\phi})^{2}\!+\!1)\\
0&amp;0&amp;0&amp;0\end{bmatrix}\begin{bmatrix}\Delta x_{1}\\
\Delta x_{2}\\
\Delta\theta\\
\Delta\phi\end{bmatrix}+\footnotesize\begin{bmatrix}\cos(\hat{\theta})&amp;0\\
\sin(\hat{\theta})&amp;0\\
\frac{1}{\ell}\tan(\hat{\phi})&amp;0\\
0&amp;1\end{bmatrix}\begin{bmatrix}\Delta u_{1}\\
\Delta u_{2}\end{bmatrix},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(123)</span></td>
</tr>
</table>
<p class="ltx_p">which can then be converted to a discrete form with (<a class="ltx_ref" href="#A3-eq:AdAc" title="(198) ‣ Appendix C Linear systems used in the bimanual tennis serve example ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">198</span></a>). 
<br class="ltx_break"/></p>
</div>
<div class="ltx_para ltx_noindent" id="S8-para:SS9.p2">
<p class="ltx_p"><span class="ltx_text ltx_font_bold">Acceleration Control Input
<br class="ltx_break"/></span>A car motion with position <span class="ltx_Math" id="SS9.p2.m1">(x_{1},x_{2})</span>, car orientation <span class="ltx_Math" id="SS9.p2.m2">\theta</span>, and front wheels orientation <span class="ltx_Math" id="SS9.p2.m3">\phi</span> (see Fig. <a class="ltx_ref" href="#S8-fig:iLQR_car_bicopter" title="Figure 30 ‣ 8.9 Car steering ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">30</span></a>-<em class="ltx_emph ltx_font_italic">left</em>) is characterized by equations</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex128">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex128.m1">\dot{x}_{1}=v\cos(\theta),\quad\dot{x}_{2}=v\sin(\theta),\quad\dot{\theta}=\frac{v}{\ell}\tan(\phi),\quad\dot{v}=u_{1},\quad\dot{\phi}=u_{2},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">where <span class="ltx_Math" id="SS9.p2.m4">\ell</span> is the distance between the front and back axles, <span class="ltx_Math" id="SS9.p2.m5">u_{1}</span> is the back wheels acceleration command and <span class="ltx_Math" id="SS9.p2.m6">u_{2}</span> is the front wheels steering velocity command.
Its first order Taylor expansion around <span class="ltx_Math" id="SS9.p2.m7">(\hat{\theta},\hat{\phi},\hat{v})</span> is</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:E124">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E124.m1">\footnotesize\begin{bmatrix}\Delta\dot{x}_{1}\\
\Delta\dot{x}_{2}\\
\Delta\dot{\theta}\\
\Delta\dot{v}\\
\Delta\dot{\phi}\end{bmatrix}=\begin{bmatrix}0&amp;0&amp;-\hat{v}\sin(\hat{\theta})&amp;\cos(\hat{\theta})&amp;0\\
0&amp;0&amp;\hat{v}\cos(\hat{\theta})&amp;\sin(\hat{\theta})&amp;0\\
0&amp;0&amp;0&amp;\frac{1}{\ell}\tan(\hat{\phi})&amp;\frac{\hat{v}}{\ell}(\tan(\hat{\phi})^{2}\!+\!1)\\
0&amp;0&amp;0&amp;0&amp;0\\
0&amp;0&amp;0&amp;0&amp;0\end{bmatrix}\begin{bmatrix}\Delta x_{1}\\
\Delta x_{2}\\
\Delta\theta\\
\Delta v\\
\Delta\phi\end{bmatrix}+\footnotesize\begin{bmatrix}0&amp;0\\
0&amp;0\\
0&amp;0\\
1&amp;0\\
0&amp;1\end{bmatrix}\begin{bmatrix}\Delta u_{1}\\
\Delta u_{2}\end{bmatrix},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(124)</span></td>
</tr>
</table>
<p class="ltx_p">which can then be converted to a discrete form with (<a class="ltx_ref" href="#A3-eq:AdAc" title="(198) ‣ Appendix C Linear systems used in the bimanual tennis serve example ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">198</span></a>).</p>
</div>
</div><div class="ltx_subsection" id="S8-sec:SS10">
<h2 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection"><span class="ltx_text">8.10</span> </span><span class="ltx_text">Bicopter</span>
</h2>
<div class="ltx_para" id="S8-para:SS10.p1">
<p class="ltx_p">A planar bicopter of mass <span class="ltx_Math" id="SS10.p1.m1">m</span> and inertia <span class="ltx_Math" id="SS10.p1.m2">I</span> actuated by two propellers at distance <span class="ltx_Math" id="SS10.p1.m3">\ell</span> (see Fig. <a class="ltx_ref" href="#S8-fig:iLQR_car_bicopter" title="Figure 30 ‣ 8.9 Car steering ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">30</span></a>-<em class="ltx_emph ltx_font_italic">right</em>) is characterized by equations</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:Ex129">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="Ex129.m1">\ddot{x}_{1}=-\frac{1}{m}(u_{1}+u_{2})\sin(\theta),\quad\ddot{x}_{2}=\frac{1}{m}(u_{1}+u_{2})\cos(\theta)-g,\quad\ddot{\theta}=\frac{\ell}{I}(u_{1}-u_{2}),</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">with acceleration <span class="ltx_Math" id="SS10.p1.m4">g\!=\!9.81</span> due to gravity. Its first order Taylor expansion around <span class="ltx_Math" id="SS10.p1.m5">(\hat{\theta},\hat{u}_{2},\hat{u}_{2})</span> is</p>
<table class="ltx_equation ltx_eqn_table" id="S8-eq:E125">
<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><span class="ltx_Math" id="E125.m1">\footnotesize\begin{bmatrix}\Delta\dot{x}_{1}\\
\Delta\dot{x}_{2}\\
\Delta\dot{\theta}\\
\Delta\ddot{x}_{1}\\
\Delta\ddot{x}_{2}\\
\Delta\ddot{\theta}\end{bmatrix}=\begin{bmatrix}0&amp;0&amp;0&amp;1&amp;0&amp;0\\
0&amp;0&amp;0&amp;0&amp;1&amp;0\\
0&amp;0&amp;0&amp;0&amp;0&amp;1\\
0&amp;0&amp;-\frac{1}{m}(\hat{u}_{1}+\hat{u}_{2})\cos(\hat{\theta})&amp;0&amp;0&amp;0\\
0&amp;0&amp;-\frac{1}{m}(\hat{u}_{1}+\hat{u}_{2})\sin(\hat{\theta})&amp;0&amp;0&amp;0\\
0&amp;0&amp;0&amp;0&amp;0&amp;0\end{bmatrix}\begin{bmatrix}\Delta x_{1}\\
\Delta x_{2}\\
\Delta\theta\\
\Delta\dot{x}_{1}\\
\Delta\dot{x}_{2}\\
\Delta\dot{\theta}\end{bmatrix}+\footnotesize\begin{bmatrix}0&amp;0\\
0&amp;0\\
0&amp;0\\
-\frac{1}{m}\sin(\hat{\theta})&amp;-\frac{1}{m}\sin(\hat{\theta})\\
\frac{1}{m}\cos(\hat{\theta})&amp;\frac{1}{m}\cos(\hat{\theta})\\
\frac{\ell}{I}&amp;-\frac{\ell}{I}\end{bmatrix}\begin{bmatrix}\Delta u_{1}\\
\Delta u_{2}\end{bmatrix},</span></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
<td class="ltx_eqn_cell ltx_eqn_eqno ltx_align_middle ltx_align_right" rowspan="1"><span class="ltx_tag ltx_tag_equation ltx_align_right">(125)</span></td>
</tr>
</table>
<p class="ltx_p">which can then be converted to a discrete form with (<a class="ltx_ref" href="#A3-eq:AdAc" title="(198) ‣ Appendix C Linear systems used in the bimanual tennis serve example ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">198</span></a>).</p>
</div>
</div><ul class="pagination justify-content-center small_menu"><li class="page-item previous_file"><a class="page-link" href="#S7">Previous</a></li><li class="page-item next_file"><a class="page-link" href="#S9">Next</a></li></ul></div></div><div class="col-sm-3"><div id="img-col"><figure class="ltx_figure figure_main" id="S8-fig:iLQR_summary"><a href="online_course/images/iLQR-eqs-overview01.png" target="_blank"><img class="ltx_graphics ltx_centering" id="F17.g1" src="online_course/images/small/iLQR-eqs-overview01.png"/></a>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text">Figure 17</span>: </span><span class="ltx_text">Summary of the iLQR optimization procedure in batch form.
</span></figcaption>
</figure><figure class="ltx_figure figure_main" id="S8-fig:transformations"><a href="online_course/images/transformations01.jpg" target="_blank"><img class="ltx_graphics ltx_centering" id="F18.g1" src="online_course/images/small/transformations01.jpg"/></a>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text">Figure 18</span>: </span><span class="ltx_text">Typical transformations involved in a manipulation task involving a robot, a vision system, a visual marker on the object, and a desired grasping location on the object.
</span></figcaption>
</figure><figure class="ltx_figure ltx_align_floatright figure_main" id="S8-fig:fcut"><a href="online_course/images/fcut01.png" target="_blank"><img class="ltx_graphics ltx_centering" id="F19.g1" src="online_course/images/small/fcut01.png"/></a>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text">Figure 19</span>: </span><span class="ltx_text">ReLU-like functions used in optimization costs. The derivatives of these functions are simple, providing Jacobians whose entries are either <span class="ltx_Math" id="F19.m3">0</span> or <span class="ltx_Math" id="F19.m4">\pm 1</span>.
</span></figcaption>
</figure><figure class="ltx_figure figure_main" id="S8-fig:iLQR_manipulator"><a href="online_course/images/iLQR_objectBoundaries01.jpg" target="_blank"><img class="ltx_graphics" id="F20.g1" src="online_course/images/small/iLQR_objectBoundaries01.jpg"/></a>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text">Figure 20</span>: </span><span class="ltx_text">Example of a viapoints task in which a planar robot with 3 joints needs to sequentially reach 2 objects, with object boundaries defining the allowed reaching points on the objects surfaces. <em class="ltx_emph ltx_font_italic">Left:</em> Reaching task with two viapoints at <span class="ltx_Math" id="F20.m5">t=25</span> and <span class="ltx_Math" id="F20.m6">t=50</span>. <em class="ltx_emph ltx_font_italic">Right:</em> Corresponding values of the cost function for the endeffector space at <span class="ltx_Math" id="F20.m7">t=25</span> and <span class="ltx_Math" id="F20.m8">t=50</span>.
</span></figcaption>
</figure><figure class="ltx_figure ltx_align_floatright figure_main" id="S8-fig:iLQR_initStateOptim"><a href="online_course/images/iLQR_initStateOptim01.png" target="_blank"><img class="ltx_graphics ltx_centering" id="F21.g1" src="online_course/images/small/iLQR_initStateOptim01.png"/></a>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text">Figure 21</span>: </span><span class="ltx_text">Optimal robot base location for a viapoint task, by defining a kinematic chain with both revolute and prismatic joints, which is employed to encode the location of the robot base in the plane as two prismatic joint variables. In this example, the prismatic joints in green represent the initial states that we estimate, and the angular joints in blue represent the state variables that can be moved during the task. </span></figcaption>
</figure><figure class="ltx_figure ltx_align_floatright figure_main" id="S8-fig:iLQR_CoM"><a href="online_course/images/iLQR_CoM01.png" target="_blank"><img class="ltx_graphics ltx_centering" id="F22.g1" src="online_course/images/small/iLQR_CoM01.png"/></a>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text">Figure 22</span>: </span><span class="ltx_text">Reaching task with a humanoid (side view) by keeping the center of mass in an area defined by the feet location.
</span></figcaption>
</figure><figure class="ltx_figure figure_main" id="S8-fig:iLQR_bimanual">
<a href="online_course/images/iLQR_bimanual02.png" target="_blank"><img class="ltx_graphics" id="F23.g1" src="online_course/images/small/iLQR_bimanual02.png"/></a>
<a href="online_course/images/iLQR_bimanual01.png" target="_blank"><img class="ltx_graphics" id="F23.g2" src="online_course/images/small/iLQR_bimanual01.png"/></a>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text">Figure 23</span>: </span><span class="ltx_text">Reaching tasks with a bimanual robot (frontal view). <em class="ltx_emph ltx_font_italic">Left:</em> with a target for each hand. <em class="ltx_emph ltx_font_italic">Right:</em> with a target for the hand on the left, while keeping the center of mass at the same location during the whole movement.
</span></figcaption>
</figure><figure class="ltx_figure ltx_align_floatright figure_main" id="S8-fig:iLQR_obstacle"><a href="online_course/images/iLQR_ellipsoidObstacle01.png" target="_blank"><img class="ltx_graphics ltx_centering" id="F24.g1" src="online_course/images/small/iLQR_ellipsoidObstacle01.png"/></a>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text">Figure 24</span>: </span><span class="ltx_text">Reaching task with obstacle avoidance, by starting from <span class="ltx_Math" id="F24.m3">\bm{x}_{1}</span> and reaching <span class="ltx_Math" id="F24.m4">\bm{\mu}_{T}</span> while avoiding the two obstacles in red.
</span></figcaption>
</figure><figure class="ltx_figure figure_main" id="S8-fig:iLQR_manipulability"><a href="online_course/images/iLQR_manipulability01.png" target="_blank"><img class="ltx_graphics" id="F25.g1" src="online_course/images/small/iLQR_manipulability01.png"/></a>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text">Figure 25</span>: </span><span class="ltx_text">Example of iLQR optimization with a cost on manipulability, where the goal is to reach, at the end of the motion, a desired manipulability defined at the center of mass (CoM) of a bimanual planar robot. The initial pose of the bimanual robot is displayed in light gray and the final pose of the robot is displayed in dark gray. The desired manipulability is represented by the red ellipse. The achieved manipulability at the end of the motion is represented by the gray ellipse. Both manipulability ellipses are displayed at the CoM reached at the end of the motion, displayed as a semi-filled dark gray disc (the CoM at the beginning of the motion is displayed in lighter gray color). We can see that the posture adopted by the robot to approach the desired manipulability is to extend both arms, which is the pose allowing the robot to swiftly move its center of mass in case of unexpected perturbations.
</span></figcaption>
</figure><figure class="ltx_figure ltx_align_floatright figure_main" id="S8-fig:iLQR_decoupling"><a href="online_course/images/iLQR_decoupling01.png" target="_blank"><img class="ltx_graphics ltx_centering" id="F26.g1" src="online_course/images/small/iLQR_decoupling01.png"/></a>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text">Figure 26</span>: </span><span class="ltx_text">2D reaching task problem (initial point in black and target point in red), with an additional cost to favor the decoupling of the control commands.
</span></figcaption>
</figure><figure class="ltx_figure figure_main" id="S8-fig:iLQR_humanoid"><a href="online_course/images/iLQR_humanoid_CP01.png" target="_blank"><img class="ltx_graphics ltx_centering" id="F27.g1" src="online_course/images/small/iLQR_humanoid_CP01.png"/></a>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text">Figure 27</span>: </span><span class="ltx_text">Reaching task with control primitives.
</span></figcaption>
</figure><figure class="ltx_figure ltx_align_floatright figure_main" id="S8-fig:iLQR_spacetime"><a href="online_course/images/iLQR_spacetime01.png" target="_blank"><img class="ltx_graphics ltx_centering" id="F28.g1" src="online_course/images/small/iLQR_spacetime01.png"/></a>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text">Figure 28</span>: </span><span class="ltx_text">Spacetime optimization with iLQR for a viapoints task, where the estimated durations between consecutive viapoints are shown in blue.
</span></figcaption>
</figure><figure class="ltx_figure figure_main" id="S8-fig:iLQR_manipulator_objAffordances">
<a href="online_course/images/iLQR_objAffordances01.png" target="_blank"><img class="ltx_graphics" id="F29.g1" src="online_course/images/small/iLQR_objAffordances01.png"/></a>
<a href="online_course/images/iLQR_objAffordances02.png" target="_blank"><img class="ltx_graphics" id="F29.g2" src="online_course/images/small/iLQR_objAffordances02.png"/></a>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text">Figure 29</span>: </span><span class="ltx_text">Manipulation with object affordances cost. The depicted <em class="ltx_emph ltx_font_italic">pick-and-place</em> task requires the offset at the picking location to be the same as the offset at the placing location, which can be achieved by setting a precision matrix with nonzero offdiagonal entries, see main text for details. In this example, an additional cost is set for choosing the picking and placing points within the object boundaries, which was also used for the task depicted in Fig. <a class="ltx_ref" href="#S8-fig:iLQR_manipulator" title="Figure 20 ‣ 8.5.3 Bounded task space ‣ 8.5 iLQR with quadratic cost on f(xt) ‣ 8 iLQR optimization ‣ A Math Cookbook for Robot Manipulation"><span class="ltx_text ltx_ref_tag">20</span></a>. We can see with the resulting motions that when picking the object, the robot anticipates what will be done later with this object, which can be viewed as a basic form of object affordance. In the two situations depicted in the figure, the robot efficiently chooses a grasping point close to one of the corners of the object, different in the two situations, so that the robot can bring the object at the desired location with less effort and without reaching joint angle limits.
</span></figcaption>
</figure><figure class="ltx_figure figure_main" id="S8-fig:iLQR_car_bicopter"><a href="online_course/images/car-bicopter01.jpg" target="_blank"><img class="ltx_graphics ltx_centering" id="F30.g1" src="online_course/images/small/car-bicopter01.jpg"/></a>
<figcaption class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure"><span class="ltx_text">Figure 30</span>: </span><span class="ltx_text">iLQR for car and bicopter control/planning problems.
</span></figcaption>
</figure></div></div></div>