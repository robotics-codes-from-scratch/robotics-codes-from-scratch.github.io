<style>
    .python-editor {
        margin-bottom: 10px;
    }
</style>


<div class="row exercise">
    <div class="col-sm-1"> </div>

    <div class="col-sm-7">
        <h1>Exercise 1<br/>Linear algebra in Python</h1>
        <p>
            The goal of this first exercise is to get familiar with linear algebra operations
            in Python and to the use of the web interface that we will use for the exercises.
        </p>
        <p>
            This page contains a series of codes that you can edit and run. It might take
            some time to load (especially the first time you load it). The functionalities
            have been tested with Chrome and Firefox.
        </p>
        <p>
            To run the code in each editor box, click on the green run button
            <svg aria-hidden="false" role="img" style="height:20px;width:20px;vertical-align:-.125em;transform-origin:center;overflow:visible;color:green" viewbox="0 0 384 512" xmlns="http://www.w3.org/2000/svg"><g transform="translate(192 256)" transform-origin="96 0"><g transform="translate(0,0) scale(1,1)"><path d="M361 215C375.3 223.8 384 239.3 384 256C384 272.7 375.3 288.2 361 296.1L73.03 472.1C58.21 482 39.66 482.4 24.52 473.9C9.377 465.4 0 449.4 0 432V80C0 62.64 9.377 46.63 24.52 38.13C39.66 29.64 58.21 29.99 73.03 39.04L361 215z" fill="currentColor" transform="translate(-192 -256)"></path></g></g></svg>
            that appears on the right corner of the editor when you hover over it.
        </p>
        <p>
            When defining functions, you can use the tab key to create four spaces tabulations.
        </p>
        <p>
            This first exercise only requires you to run the codes, to display the results,
            to analyze these outputs, and to modify the examples in order to get familiar
            with the use of matrices, vectors and associated linear algebra operations in
            Python. Some of the exercises require the previous codes to have been run once,
            in order to define the variables.
        </p>

        <h5>1. Test your first Python code</h5>
        <editor id="editor1" src="exercise1" output="output1" errors="errors1"></editor>
        <pre id="errors1" class="py-error"></pre>
        <pre id="output1" class="py-output"></pre>

        <h5>2. Create and display a random 3D vector</h5>
        <editor id="editor2" src="exercise2" output="output2" errors="errors2"></editor>
        <pre id="errors2" class="py-error"></pre>
        <pre id="output2" class="py-output"></pre>

        <h5>3. Create and display a random 3D matrix</h5>
        <editor id="editor3" src="exercise3" output="output3" errors="errors3"></editor>
        <pre id="errors3" class="py-error"></pre>
        <pre id="output3" class="py-output"></pre>

        <h5>4. Multiplication and product operations</h5>
        <editor id="editor4" src="exercise4" output="output4" errors="errors4"></editor>
        <pre id="errors4" class="py-error"></pre>
        <pre id="output4" class="py-output"></pre>

        <h5>5. Reformatting and stacking of vectors and matrices</h5>
        <editor id="editor5" src="exercise5" output="output5" errors="errors5"></editor>
        <pre id="errors5" class="py-error"></pre>
        <pre id="output5" class="py-output"></pre>

        <h5>6. Inversion of a matrix</h5>
        <editor id="editor6" src="exercise6" output="output6" errors="errors6"></editor>
        <pre id="errors6" class="py-error"></pre>
        <pre id="output6" class="py-output"></pre>

        <h5>7. Solve Ax=b using least squares</h5>
        <p>Complete the code below to compute x so that Ax=b.</p>
        <p>Compute the error between Ax and b to see if your solution for x seems correct.</p>
        <p>Modify the dimensions of A and b (including rectangular matrices for A) and observe the results.</p>
        <editor id="editor7" src="exercise7" output="output7" errors="errors7"></editor>
        <pre id="errors7" class="py-error"></pre>
        <pre id="output7" class="py-output"></pre>

        <h5>8. Implementing a function</h5>
        <p>Implement a function fun(x) that inverts a matrix, by taking x as input (matrix) and by generating x_inv as output.</p>
        <p>Can you make this function robust to the use of singular matrices? (see part 6 above as a hint)</p>
        <editor id="editor8" src="exercise8" output="output8" errors="errors8"></editor>
        <pre id="errors8" class="py-error"></pre>
        <pre id="output8" class="py-output"></pre>

        <h5>9. Plotting</h5>
        <editor id="editor9" src="exercise9" output="output9" errors="errors9"></editor>
        <pre id="errors9" class="py-error"></pre>
        <pre id="output9" class="py-output"></pre>

        <br/><br/><br/>
    </div>

    <div class="col-sm-4"></div>
</div>


<script id="exercise1" type="python">
    print('Hello world!')
</script>


<script id="exercise2" type="python">
    vec1 = np.array([3., 4.]) # create a vector with given entries
    vec2 = np.random.randn(3) # create a random vector
    print(vec1)
    print(vec2)
</script>


<script id="exercise3" type="python">
    mat1 = np.array([[1.,2.],[2., 10.]]) # create a matrix with given entries
    mat2 = np.random.randn(3,3) # create a random 3x3 matrix
    print(mat1)
    print(mat2)
</script>


<script id="exercise4" type="python">
    prod1 = mat1 @ mat1 # multiply mat1 by mat1
    prod2 = mat1 * mat1 # elementwise product between mat1 by mat1
    prod3 = mat1 @ vec1 # multiply mat1 by vec1
    prod4a = vec2.T @ vec2 # dot product between vec2 and vec2
    prod4b = vec2.dot(vec2) # dot product between vec2 and vec2
    prod5 = np.outer(vec2, vec2) # Outer product between vec2 and vec2
    print(prod4a)
    print(prod4b) # Display two of the results
</script>


<script id="exercise5" type="python">
    vec3 = np.random.randn(3)
    # stack vec2 and vec3 to obtain a matrix of shape (2,3)
    stacked1 = np.stack([vec2, vec3])
    # stack mat2 and vec2 to obtain a matrix of shape (4,3)
    concatenated1 =  np.vstack([mat2, vec2[None]])
    # stack mat2 and vec2 to obtain a matrix of shape (3,4)
    concatenated2 =  np.hstack([mat2, vec2[:,None]])
    print(stacked1.shape) # display the matrix dimension of stacked1
</script>


<script id="exercise6" type="python">
    mat = np.diag([0.1, 0.2, 0.3]) # set diagonal matrix
    mat_inv = np.linalg.inv(mat) # matrix inversion

    # # Let's make it not invertible by changing the last entry to 0
    # mat[-1,-1] = 0.

    # Let's check if the matrix is invertible (without inverting it)
    is_invertible = np.linalg.det(mat) != 0.

    # Pseudoinverses of mat
    mat1_pinv = np.linalg.inv(mat.T @ mat) @ mat.T # using inv(A.T @ A) @ A.T
    mat2_pinv = np.linalg.pinv(mat) # using np.linalg.pinv()

    #Compare the two solutions
    diff = np.linalg.norm(mat1_pinv - mat2_pinv, ord='fro')

    print(is_invertible)
    print(diff) # diff should be almost zero
</script>


<script id="exercise7" type="python">
    A = np.random.randn(3,3)
    b = np.random.randn(3)
    # x = ...
</script>
<!--
x = np.linalg.pinv(A) @ b # solve
print(np.linalg.norm(A @ x - b))
-->


<script id="exercise8" type="python">
    def fun(x):
        # x_inv = ...
        return x_inv

    x = np.diag([1., 2, 0.])
    y = fun(x)
    print(y)
</script>
<!--
def fun(x):
    i = 0
    while np.linalg.det(x) == 0.:
        x = x + np.eye(x.shape[0])*(10**(-10+i))
        i += 1
        if i == 15:
            break
    return x

x = np.diag([1., 2, 0.])
y = fun(x)
print(y)
-->


<script id="exercise9" type="python">
    x = np.arange(5) # create data
    fig,ax = plt.subplots(figsize=(5,5))
    ax.plot(x, x**2) # plot data in a graph
    ax.set_xlabel(r'$x$')
    ax.set_ylabel(r'$x^2$')
    fig.tight_layout()
    print(fig)
</script>


<script id="page_code" type="python">
    import numpy as np
    import matplotlib.pyplot as plt
    from rcfs import configure

    configure({})
</script>
