<style>
    .py-repl-output {
        font-size: 0.7em;
        padding-top: 0.5rem;
    }
</style>


<div class="row exercise">
    <div class="col-sm-1"> </div>

    <div class="col-sm-7">
        <h1>Exercise 1<br/>Linear algebra in Python</h1>
        <p>
            The goal of this first exercise is to get familiar with linear algebra operations
            in Python and to the use of the web interface that we will use for the exercises.
        </p>
        <p>
            This page contains a series of codes that you can edit and run. It might take
            some time to load (especially the first time you load it). The functionalities
            have been tested with Chrome and Firefox.
        </p>
        <p>
            To run the code in each editor box, click on the green run button
            <svg aria-hidden="false" role="img" style="height:20px;width:20px;vertical-align:-.125em;transform-origin:center;overflow:visible;color:green" viewbox="0 0 384 512" xmlns="http://www.w3.org/2000/svg"><g transform="translate(192 256)" transform-origin="96 0"><g transform="translate(0,0) scale(1,1)"><path d="M361 215C375.3 223.8 384 239.3 384 256C384 272.7 375.3 288.2 361 296.1L73.03 472.1C58.21 482 39.66 482.4 24.52 473.9C9.377 465.4 0 449.4 0 432V80C0 62.64 9.377 46.63 24.52 38.13C39.66 29.64 58.21 29.99 73.03 39.04L361 215z" fill="currentColor" transform="translate(-192 -256)"></path></g></g></svg>
            that appears on the right corner of the editor when you hover over it.
        </p>
        <p>
            The last line of the code can be used to display the outputs of the execution,
            by just writing the name of the variable. <em>print(var)</em> can alternatively
            by used at any place within the code.
        </p>
        <p>
            When defining functions, you can use two space characters to create tabulations
            (the tab key should be kept for navigating the web interface).
        </p>
        <p>
            This first exercise only requires you to run the codes, to display the results,
            to analyze these outputs, and to modify the examples in order to get familiar
            with the use of matrices, vectors and associated linear algebra operations in
            Python. Some of the exercises require the previous codes to have been run once,
            in order to define the variables.
        </p>

        <h5>1. Test your first Python code</h5>
        <py-repl>print('Hello world!')</py-repl>

        <h5>2. Create and display a random 3D vector</h5>
        <py-repl>
            vec1 = np.array([3., 4.]) # create a vector with given entries
            vec2 = np.random.randn(3) # create a random vector
            print(vec1)
            print(vec2)
        </py-repl>

        <h5>3. Create and display a random 3D matrix</h5>
        <py-repl>
            mat1 = np.array([[1.,2.],[2., 10.]]) # create a matrix with given entries
            mat2 = np.random.randn(3,3) # create a random 3x3 matrix
            print(mat1)
            print(mat2)
        </py-repl>

        <h5>4. Multiplication and product operations</h5>
        <py-repl>
            prod1 = mat1 @ mat1 # multiply mat1 by mat1
            prod2 = mat1 * mat1 # elementwise product between mat1 by mat1
            prod3 = mat1 @ vec1 # multiply mat1 by vec1
            prod4a = vec2.T @ vec2 # dot product between vec2 and vec2
            prod4b = vec2.dot(vec2) # dot product between vec2 and vec2
            prod5 = np.outer(vec2, vec2) # Outer product between vec2 and vec2
            print(prod4a)
            print(prod4b) # Display two of the results
        </py-repl>

        <h5>5. Reformatting and stacking of vectors and matrices</h5>
        <py-repl>
            vec3 = np.random.randn(3)
            # stack vec2 and vec3 to obtain a matrix of shape (2,3)
            stacked1 = np.stack([vec2, vec3])
            # stack mat2 and vec2 to obtain a matrix of shape (4,3)
            concatenated1 =  np.vstack([mat2, vec2[None]])
            # stack mat2 and vec2 to obtain a matrix of shape (3,4)
            concatenated2 =  np.hstack([mat2, vec2[:,None]])
            print(stacked1.shape) # display the matrix dimension of stacked1
        </py-repl>

        <h5>6. Inversion of a matrix</h5>
        <py-repl>
            mat = np.diag([0.1, 0.2, 0.3]) # set diagonal matrix
            mat_inv = np.linalg.inv(mat) # matrix inversion

            # # Let's make it not invertible by changing the last entry to 0
            # mat[-1,-1] = 0.

            # Let's check if the matrix is invertible (without inverting it)
            is_invertible = np.linalg.det(mat) != 0.

            # Pseudoinverses of mat
            mat1_pinv = np.linalg.inv(mat.T @ mat) @ mat.T # using inv(A.T @ A) @ A.T
            mat2_pinv = np.linalg.pinv(mat) # using np.linalg.pinv()

            #Compare the two solutions
            diff = np.linalg.norm(mat1_pinv - mat2_pinv, ord='fro')

            print(is_invertible)
            print(diff) # diff should be almost zero
        </py-repl>

        <h5>7. Solve Ax=b using least squares</h5>
        <p>Complete the code below to compute x so that Ax=b.</p>
        <p>Compute the error between Ax and b to see if your solution for x seems correct.</p>
        <p>Modify the dimensions of A and b (including rectangular matrices for A) and observe the results.</p>
        <py-repl>
            A = np.random.randn(3,3)
            b = np.random.randn(3)
            # x = ...
        </py-repl>
        <!--
        x = np.linalg.pinv(A) @ b # solve
        np.linalg.norm(A @ x - b)
        -->

        <h5>8. Implementing a function</h5>
        <p>Implement a function fun(x) that inverts a matrix, by taking x as input (matrix) and by generating x_inv as output.</p>
        <p>Can you make this function robust to the use of singular matrices? (see part 6 above as a hint)</p>
        <py-repl>
            def fun(x):
                # x_inv = ...
                return x_inv

            x = np.diag([1., 2, 0.])
            y = fun(x)
            print(y)
        </py-repl>
        <!--
        def fun(x):
          i = 0
          while np.linalg.det(x) == 0.:
            x = x + np.eye(x.shape[0])*(10**(-10+i))
            i += 1
            if i == 15: break
          return x

        x = np.diag([1., 2, 0.])
        fun(x)
        -->

        <h5>9. Plotting</h5>
        <py-repl>
            x = np.arange(5) # create data
            fig,ax = plt.subplots(figsize=(5,5))
            ax.plot(x, x**2) # plot data in a graph
            ax.set_xlabel(r'$x$')
            ax.set_ylabel(r'$x^2$')
            fig.tight_layout()
            fig
        </py-repl>

        <br/><br/><br/>
    </div>

    <div class="col-sm-4"></div>
</div>


<py-script>
    import numpy as np
    import matplotlib.pyplot as plt
    from js import document, console
    from pyodide.ffi import create_proxy
</py-script>
