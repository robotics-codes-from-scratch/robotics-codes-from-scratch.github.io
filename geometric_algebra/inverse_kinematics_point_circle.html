<style>
    table {
        border-collapse: collapse;
        margin-bottom: 20px;
        font-family: monospace;
        font-size: 13px;
    }

    th {
        background-color: rgb(50, 50, 50);
        color: white;
    }

    td, th {
        border: 1px solid rgb(50, 50, 50);
        padding-right: 10px;
        padding-left: 10px;
        padding-top: 4px;
        padding-bottom: 4px;
    }

    td:first-child {
        background-color: lightgray;
    }
</style>


<div class='row'>
    <div class='col-sm-1'></div>

    <div class='col-sm-11'>
        <h3>Inverse kinematics: Point to Circle</h3>
        <p>Robot: Franka Emika Panda</p>

        <div id="loader-container">
            <span class="loader"></span>
        </div>

        <table id="results" style="display: none;">
            <thead>
                <tr>
                    <th>Value</th>
                    <th>Multivector</th>
                    <th>Position (x, y, z)</th>
                    <th>Normal (x, y, z)</th>
                    <th>Radius</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Start Point</td>
                    <td id="start_mv"></td>
                    <td id="start_pos"></td>
                    <td>-</td>
                    <td>-</td>
                </tr>
                <tr>
                    <td>Target Circle</td>
                    <td id="target_mv"></td>
                    <td id="target_pos"></td>
                    <td id="target_normal"></td>
                    <td id="target_radius"></td>
                </tr>
                <tr>
                    <td>Solution Point</td>
                    <td id="solution_mv"></td>
                    <td id="solution_pos"></td>
                    <td>-</td>
                    <td>-</td>
                </tr>
            </tbody>
        </table>

        <pre id="errors" class="py-error"></pre>
        <div id="output" class="py-output"></div>
    </div>
</div>


<script id="page_code" type="python">
    from rcfs import configure

    from pyscript import display
    import numpy as np
    import matplotlib.pyplot as plt
    from matplotlib.ticker import MaxNLocator
    from js import document, console

    from pygafro import FrankaEmikaRobot
    from pygafro import Point
    from pygafro import Circle
    from pygafro import SingleManipulatorTarget


    # Display a point in a row of the table
    def displayPoint(point, prefix):
        p = point.getEuclideanPoint()
        document.getElementById(f'{prefix}_mv').textContent = str(point)
        document.getElementById(f'{prefix}_pos').textContent = f'{p[0]:.3}, {p[1]:.3}, {p[2]:.3}'


    # Display a circle in a row of the table
    def displayCircle(circle, prefix):
        c = circle.getCenter().getEuclideanPoint()
        n = circle.getPlane().getNormal()
        n = [ n['e1'], n['e2'], n['e3'] ]
        n = n / np.linalg.norm(n)
        r = circle.getRadius()
        document.getElementById(f'{prefix}_mv').textContent = str(circle)
        document.getElementById(f'{prefix}_pos').textContent = f'{c[0]:.3}, {c[1]:.3}, {c[2]:.3}'
        document.getElementById(f'{prefix}_normal').textContent = f'{n[0]:.3}, {n[1]:.3}, {n[2]:.3}'
        document.getElementById(f'{prefix}_radius').textContent = f'{r:.3}'


    # Display a point in the 3D plot
    def drawPoint(ax, point, s=20, facecolors=None, edgecolors=None, label=None):
        p = point.getEuclideanPoint()
        ax.scatter(p[0], p[1], p[2], s=s, facecolors=facecolors, edgecolors=edgecolors, label=label)


    # Display a circle in the 3D plot
    def drawCircle(ax, circle, color=None, label=None):
        c = circle.getCenter().getEuclideanPoint()
        n = circle.getPlane().getNormal()
        n = np.array([ n['e1'], n['e2'], n['e3'] ])
        n = n / np.linalg.norm(n)
        r = circle.getRadius()

        v = np.array([1, 0, 0])
        if np.linalg.norm(n - v) < 1e-6:
            v = np.array([0, 1, 0])

        v1 = np.cross(n, v)
        v2 = np.cross(n, v1)

        points = np.array([ c + r * np.cos(theta) * v1 + r * np.sin(theta) * v2 for theta in np.linspace(0, 2*np.pi) ])
        ax.plot(points[:, 0], points[:, 1], points[:, 2], color=color, label=label)


    # Create the robot
    panda = FrankaEmikaRobot()

    # Initial robot state
    x = [0.5, -0.3, 0.0, -1.8, 0.0, 1.5, 1.0]
    start_point = panda.getEEMotor(x).apply(Point())

    # Target circle
    ee_target_circle = Circle(Point(-0.3, 0.6, 0.65), Point(-0.1, 0.6, 0.65), Point(-0.2, 0.7, 0.6))

    # Create the cost function
    cost_function = SingleManipulatorTarget(panda, Point(), ee_target_circle)

    # To store the values displayed in the plots
    costs = []
    update_norms = []
    positions = [start_point.getEuclideanPoint()]

    # Gauss-Newton algorithm to find the inverse kinematics
    cost = np.linalg.norm(cost_function.getError(x))

    for i in range(100):
        gradient, hessian = cost_function.getGradientAndHessian(x)

        update = -(np.linalg.inv(hessian + 1e-5 * np.eye(7)) @ gradient)

        # line search
        iter = 1
        c = cost
        alpha = 2.0

        while (c >= cost) and (iter < 20):
            alpha *= 0.5
            xk = x + alpha * update
            c = np.linalg.norm(cost_function.getError(xk))
            iter += 1

        update = alpha * update

        if (np.linalg.norm(update) < 1e-10) or np.isnan(update).any():
            break

        x = x + update

        if np.isnan(x).any():
            break

        cost = np.linalg.norm(cost_function.getError(x))

        console.log(f"iteration: {i} -> cost: {cost}, update norm: {np.linalg.norm(update)}")

        costs.append(cost)
        update_norms.append(np.linalg.norm(update))
        positions.append(panda.getEEMotor(x).apply(Point()).getEuclideanPoint())

        if cost < 1e-10:
            break


    # Display the results
    displayPoint(start_point, 'start')
    displayCircle(ee_target_circle, 'target')
    displayPoint(panda.getEEMotor(x).apply(Point()), 'solution')

    document.getElementById('results').style.display = 'block'
    document.getElementById('loader-container').style.display = 'none';


    # Display the trajectory of the end-effector
    fig = plt.figure(layout='constrained', figsize=(12, 6))
    subfigs = fig.subfigures(1, 2, wspace=0.07)

    ax = subfigs[0].add_subplot(111, projection='3d')

    ax.plot([0, 1], [0, 0], [0, 0], color='r', alpha=0.5)
    ax.plot([0, 0], [0, 1], [0, 0], color='g', alpha=0.5)
    ax.plot([0, 0], [0, 0], [0, 1], color='b', alpha=0.5)

    drawPoint(ax, start_point, label='Start Point')
    drawCircle(ax, ee_target_circle, color='g', label='Target Circle')
    drawPoint(ax, panda.getEEMotor(x).apply(Point()), label='Solution Point')

    positions = np.array(positions)
    ax.plot(positions[:, 0], positions[:, 1], positions[:, 2], color='darkturquoise', label='Trajectory')

    ax.set_xlim(-0.5, 0.5)
    ax.set_ylim(0, 1)
    ax.set_zlim(0, 1)
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')

    ax.legend()

    ax.view_init(elev=30., azim=60)


    # Display the evolution of the cost and the update norm
    axes = subfigs[1].subplots(2, 1)

    axes[0].set_title('Cost')
    axes[0].set_xlabel('Iteration')
    axes[0].set_yscale('log')
    axes[0].set_xmargin(0)
    axes[0].xaxis.set_major_locator(MaxNLocator(integer=True))
    axes[0].grid(True)
    axes[0].plot(list(range(len(costs))), costs)

    axes[1].set_title('Update norm')
    axes[1].set_xlabel('Iteration')
    axes[1].set_yscale('log')
    axes[1].set_xmargin(0)
    axes[1].xaxis.set_major_locator(MaxNLocator(integer=True))
    axes[1].grid(True)
    axes[1].plot(list(range(len(update_norms))), update_norms)

    display(fig, target='output')


    configure({
        'output': 'output',
        'errors': 'errors',
    })
</script>
