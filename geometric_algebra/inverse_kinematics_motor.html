<style>
    table {
        border-collapse: collapse;
        margin-bottom: 20px;
        font-family: monospace;
        font-size: 13px;
    }

    th {
        background-color: rgb(50, 50, 50);
        color: white;
    }

    td, th {
        border: 1px solid rgb(50, 50, 50);
        padding-right: 10px;
        padding-left: 10px;
        padding-top: 4px;
        padding-bottom: 4px;
    }

    td:first-child {
        background-color: lightgray;
    }
</style>


<div class='row'>
    <div class='col-sm-1'></div>

    <div class='col-sm-11'>
        <h3>Inverse kinematics: Motor</h3>
        <p>Robot: Franka Emika Panda</p>

        <div id="loader-container">
            <span class="loader"></span>
        </div>

        <table id="results" style="display: none;">
            <thead>
                <tr>
                    <th>Value</th>
                    <th>Multivector</th>
                    <th>Position (x, y, z)</th>
                    <th>Quaternion (w, x, y, z)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Start Motor</td>
                    <td id="start_mv"></td>
                    <td id="start_pos"></td>
                    <td id="start_quat"></td>
                </tr>
                <tr>
                    <td>Target Motor</td>
                    <td id="target_mv"></td>
                    <td id="target_pos"></td>
                    <td id="target_quat"></td>
                </tr>
                <tr>
                    <td>Solution Motor</td>
                    <td id="solution_mv"></td>
                    <td id="solution_pos"></td>
                    <td id="solution_quat"></td>
                </tr>
            </tbody>
        </table>

        <pre id="errors" class="py-error"></pre>
        <div id="output" class="py-output"></div>
    </div>
</div>


<script id="page_code" type="python">
    from rcfs import configure

    from pyscript import display
    import numpy as np
    import matplotlib.pyplot as plt
    from matplotlib.ticker import MaxNLocator
    from js import document, console

    from pygafro import FrankaEmikaRobot
    from pygafro import SingleManipulatorMotorCost
    from pygafro import Motor
    from pygafro import Translator
    from pygafro import TranslatorGenerator
    from pygafro import Rotor
    from pygafro import Point


    # Display a point in a row of the table
    def displayMotor(motor, prefix):
        p = motor.getTranslator().toTranslationVector()
        q = motor.getRotor().quaternion()
        document.getElementById(f'{prefix}_mv').textContent = str(motor)
        document.getElementById(f'{prefix}_pos').textContent = f'{p[0]:.3}, {p[1]:.3}, {p[2]:.3}'
        document.getElementById(f'{prefix}_quat').textContent = f'{q[0]:.3}, {q[1]:.3}, {q[2]:.3}, {q[3]:.3}'

    
    # Display a motor in the 3D plot
    def drawMotor(ax, motor, s=20, facecolors=None, edgecolors=None, label=None):
        p = motor.getTranslator().toTranslationVector()
        ax.scatter(p[0], p[1], p[2], s=s, facecolors=facecolors, edgecolors=edgecolors, label=label)

        rotor = motor.getRotor()

        px = rotor.apply(Point(0.1, 0.0, 0.0)).getEuclideanPoint()
        py = rotor.apply(Point(0.0, 0.1, 0.0)).getEuclideanPoint()
        pz = rotor.apply(Point(0.0, 0.0, 0.1)).getEuclideanPoint()

        ax.plot([p[0], p[0] + px[0]], [p[1], p[1] + px[1]], [p[2], p[2] + px[2]], color='r', alpha=0.5)
        ax.plot([p[0], p[0] + py[0]], [p[1], p[1] + py[1]], [p[2], p[2] + py[2]], color='g', alpha=0.5)
        ax.plot([p[0], p[0] + pz[0]], [p[1], p[1] + pz[1]], [p[2], p[2] + pz[2]], color='b', alpha=0.5)


    # Create the robot
    panda = FrankaEmikaRobot()

    # Initial robot state
    x = [0.5, -0.3, 0.0, -1.8, 0.0, 1.5, 1.0]
    start_motor = panda.getEEMotor(x)

    # Target motor
    ee_target_motor = Motor(
        Translator.exp(TranslatorGenerator([-0.2, 0.6, 0.65])),
        Rotor.fromQuaternion([-0.44217198, 0.51251752, 0.5728137, 0.4622707])
    )

    # Create the cost function
    cost_function = SingleManipulatorMotorCost(panda, ee_target_motor)

    # To store the values displayed in the plots
    costs = []
    update_norms = []
    motors = [start_motor]

    # Gauss-Newton algorithm to find the inverse kinematics
    cost = np.linalg.norm(cost_function.getError(x))

    for i in range(100):
        gradient, hessian = cost_function.getGradientAndHessian(x)

        update = -(np.linalg.inv(hessian + 1e-5 * np.eye(7)) @ gradient)

        # line search
        iter = 1
        c = cost
        alpha = 1.0

        while (c >= cost) and (iter < 20):
            alpha *= 0.5
            xk = x + alpha * update
            c = np.linalg.norm(cost_function.getError(xk))
            iter += 1

        update = alpha * update

        if (np.linalg.norm(update) < 1e-10) or np.isnan(update).any():
            break

        x = x + update

        if np.isnan(x).any():
            break

        cost = np.linalg.norm(cost_function.getError(x))

        console.log(f"iteration: {i} -> cost: {cost}, update norm: {np.linalg.norm(update)}")

        costs.append(cost)
        update_norms.append(np.linalg.norm(update))
        motors.append(panda.getEEMotor(x))

        if cost < 1e-10:
            break


    # Display the results
    displayMotor(start_motor, 'start')
    displayMotor(ee_target_motor, 'target')
    displayMotor(panda.getEEMotor(x), 'solution')

    document.getElementById('results').style.display = 'block'
    document.getElementById('loader-container').style.display = 'none';


    # Display the trajectory of the end-effector
    fig = plt.figure(layout='constrained', figsize=(12, 6))
    subfigs = fig.subfigures(1, 2, wspace=0.07)

    ax = subfigs[0].add_subplot(111, projection='3d')

    ax.plot([0, 1], [0, 0], [0, 0], color='r', alpha=0.5)
    ax.plot([0, 0], [0, 1], [0, 0], color='g', alpha=0.5)
    ax.plot([0, 0], [0, 0], [0, 1], color='b', alpha=0.5)

    drawMotor(ax, start_motor, label='Start Motor')
    drawMotor(ax, ee_target_motor, s=50, facecolors='none', edgecolors='g', label='Target Motor')
    drawMotor(ax, panda.getEEMotor(x), label='Solution Motor')

    positions = np.array([ m.getTranslator().toTranslationVector() for m in motors ])
    ax.plot(positions[:, 0], positions[:, 1], positions[:, 2], color='darkturquoise', label='Trajectory')

    ax.set_xlim(-0.5, 0.5)
    ax.set_ylim(0, 1)
    ax.set_zlim(0, 1)
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')

    ax.legend()

    ax.view_init(elev=30., azim=60)


    # Display the evolution of the cost and the update norm
    axes = subfigs[1].subplots(2, 1)

    axes[0].set_title('Cost')
    axes[0].set_xlabel('Iteration')
    axes[0].set_yscale('log')
    axes[0].set_xmargin(0)
    axes[0].xaxis.set_major_locator(MaxNLocator(integer=True))
    axes[0].grid(True)
    axes[0].plot(list(range(len(costs))), costs)

    axes[1].set_title('Update norm')
    axes[1].set_xlabel('Iteration')
    axes[1].set_yscale('log')
    axes[1].set_xmargin(0)
    axes[1].xaxis.set_major_locator(MaxNLocator(integer=True))
    axes[1].grid(True)
    axes[1].plot(list(range(len(update_norms))), update_norms)

    display(fig, target='output')


    configure({
        'output': 'output',
        'errors': 'errors',
    })
</script>
