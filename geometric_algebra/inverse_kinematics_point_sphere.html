<style>
    table {
        border-collapse: collapse;
        margin-bottom: 20px;
        font-family: monospace;
        font-size: 13px;
    }

    th {
        background-color: rgb(50, 50, 50);
        color: white;
    }

    td, th {
        border: 1px solid rgb(50, 50, 50);
        padding-right: 10px;
        padding-left: 10px;
        padding-top: 4px;
        padding-bottom: 4px;
    }

    td:first-child {
        background-color: lightgray;
    }
</style>


<div class='row'>
    <div class='col-sm-1'></div>

    <div class='col-sm-11'>
        <h3>Inverse kinematics: Point to Sphere</h3>
        <p>Robot: Franka Emika Panda</p>

        <div id="loader-container">
            <span class="loader"></span>
        </div>

        <table id="results" style="display: none;">
            <thead>
                <tr>
                    <th>Value</th>
                    <th>Multivector</th>
                    <th>Position (x, y, z)</th>
                    <th>Radius</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Start Point</td>
                    <td id="start_mv"></td>
                    <td id="start_pos"></td>
                    <td>-</td>
                </tr>
                <tr>
                    <td>Target Sphere</td>
                    <td id="target_mv"></td>
                    <td id="target_pos"></td>
                    <td id="target_radius"></td>
                </tr>
                <tr>
                    <td>Solution Point</td>
                    <td id="solution_mv"></td>
                    <td id="solution_pos"></td>
                    <td>-</td>
                </tr>
            </tbody>
        </table>

        <pre id="errors" class="py-error"></pre>
        <div id="output" class="py-output"></div>
    </div>
</div>


<script id="page_code" type="python">
    from rcfs import configure

    from pyscript import display
    import numpy as np
    import matplotlib.pyplot as plt
    from matplotlib.ticker import MaxNLocator
    from mpl_toolkits.mplot3d.art3d import Poly3DCollection
    from js import document, console

    from pygafro import FrankaEmikaRobot
    from pygafro import Sphere
    from pygafro import Point
    from pygafro import SingleManipulatorTarget


    # Display a point in a row of the table
    def displayPoint(point, prefix):
        p = point.getEuclideanPoint()
        document.getElementById(f'{prefix}_mv').textContent = str(point)
        document.getElementById(f'{prefix}_pos').textContent = f'{p[0]:.3}, {p[1]:.3}, {p[2]:.3}'


    # Display a sphere in a row of the table
    def displaySphere(sphere, prefix):
        c = sphere.getCenter().getEuclideanPoint()
        r = sphere.getRadius()

        document.getElementById(f'{prefix}_mv').textContent = str(sphere)
        document.getElementById(f'{prefix}_pos').textContent = f'{c[0]:.3}, {c[1]:.3}, {c[2]:.3}'
        document.getElementById(f'{prefix}_radius').textContent = f'{r:.3}'


    # Display a point in the 3D plot
    def drawPoint(ax, point, s=20, facecolors=None, edgecolors=None, color=None, label=None):
        p = point.getEuclideanPoint()
        ax.scatter(p[0], p[1], p[2], s=s, facecolors=facecolors, edgecolors=edgecolors, color=color, label=label)


    # Display a sphere in the 3D plot
    def drawSphere(ax, sphere, color=None, label=None):
        c = sphere.getCenter().getEuclideanPoint()
        r = sphere.getRadius()

        u = np.linspace(0, 2 * np.pi, 100)
        v = np.linspace(0, np.pi, 100)
        x = r * np.outer(np.cos(u), np.sin(v)) + c[0]
        y = r * np.outer(np.sin(u), np.sin(v)) + c[1]
        z = r * np.outer(np.ones(np.size(u)), np.cos(v)) + c[2]

        ax.plot_surface(x, y, z, alpha=0.3, color=color)


    # Create the robot
    panda = FrankaEmikaRobot()

    # Initial robot state
    x = [0.5, -0.3, 0.0, -1.8, 0.0, 1.5, 1.0]
    start_point = panda.getEEMotor(x).apply(Point())

    # Target sphere
    target_sphere = Sphere(Point(-0.2, 0.6, 0.65), 0.2)

    # Create the cost function
    cost_function = SingleManipulatorTarget(panda, Point(), target_sphere)

    # To store the values displayed in the plots
    costs = []
    update_norms = []
    positions = [start_point.getEuclideanPoint()]

    # Gauss-Newton algorithm to find the inverse kinematics
    cost = np.linalg.norm(cost_function.getError(x))

    for i in range(100):
        gradient, hessian = cost_function.getGradientAndHessian(x)

        update = -(np.linalg.inv(hessian + 1e-5 * np.eye(7)) @ gradient)

        # line search
        iter = 1
        c = cost
        alpha = 2.0

        while (c >= cost) and (iter < 20):
            alpha *= 0.5
            xk = x + alpha * update
            c = np.linalg.norm(cost_function.getError(xk))
            iter += 1

        update = alpha * update

        if (np.linalg.norm(update) < 1e-10) or np.isnan(update).any():
            break

        x = x + update

        if np.isnan(x).any():
            break

        cost = np.linalg.norm(cost_function.getError(x))

        console.log(f"iteration: {i} -> cost: {cost}, update norm: {np.linalg.norm(update)}")

        costs.append(cost)
        update_norms.append(np.linalg.norm(update))
        positions.append(panda.getEEMotor(x).apply(Point()).getEuclideanPoint())

        if cost < 1e-10:
            break


    # Display the results
    displayPoint(start_point, 'start')
    displaySphere(target_sphere, 'target')
    displayPoint(panda.getEEMotor(x).apply(Point()), 'solution')

    document.getElementById('results').style.display = 'block'
    document.getElementById('loader-container').style.display = 'none';


    # Display the trajectory of the end-effector
    fig = plt.figure(layout='constrained', figsize=(12, 6))
    subfigs = fig.subfigures(1, 2, wspace=0.07)

    ax = subfigs[0].add_subplot(111, projection='3d')

    ax.plot([0, 1], [0, 0], [0, 0], color='r', alpha=0.5)
    ax.plot([0, 0], [0, 1], [0, 0], color='g', alpha=0.5)
    ax.plot([0, 0], [0, 0], [0, 1], color='b', alpha=0.5)

    drawPoint(ax, start_point, label='Start Point')
    drawSphere(ax, target_sphere, color='g', label='Target Sphere')
    drawPoint(ax, panda.getEEMotor(x).apply(Point()), label='Solution Point')

    positions = np.array(positions)
    ax.plot(positions[:, 0], positions[:, 1], positions[:, 2], color='darkturquoise', label='Trajectory')

    ax.set_xlim(-0.5, 0.5)
    ax.set_ylim(0, 1)
    ax.set_zlim(0, 1)
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')

    ax.legend()

    ax.view_init(elev=30., azim=60)


    # Display the evolution of the cost and the update norm
    axes = subfigs[1].subplots(2, 1)

    axes[0].set_title('Cost')
    axes[0].set_xlabel('Iteration')
    axes[0].set_yscale('log')
    axes[0].set_xmargin(0)
    axes[0].xaxis.set_major_locator(MaxNLocator(integer=True))
    axes[0].grid(True)
    axes[0].plot(list(range(len(costs))), costs)

    axes[1].set_title('Update norm')
    axes[1].set_xlabel('Iteration')
    axes[1].set_yscale('log')
    axes[1].set_xmargin(0)
    axes[1].xaxis.set_major_locator(MaxNLocator(integer=True))
    axes[1].grid(True)
    axes[1].plot(list(range(len(update_norms))), update_norms)

    display(fig, target='output')


    configure({
        'output': 'output',
        'errors': 'errors',
    })
</script>
