<!--
SPDX-FileCopyrightText: 2023 Idiap Research Institute <contact@idiap.ch>

SPDX-FileContributor: Philip Abbet <philip.abbet@idiap.ch>

SPDX-License-Identifier: MIT
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <title>iLQR manipulator example (Python version)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <link href="https://pyscript.net/releases/2024.8.2/core.css" rel="stylesheet"/>
    <link href="../../css/loader.css" rel="stylesheet"/>

    <py-config type="toml">
        packages = ['numpy']
        [[fetch]]
            from = '../../viewer3d/'
            files = ['viewer3d.py']
    </py-config>
</head>


<body style="font-family: MONOSPACE;">
    <h2>iLQR manipulator example (Python version)</h2>

    <p>iLQR (batch formulation) applied to a Franka Emika manipulator for a viapoints task in a 3D workspace.</p>

    <p>The user can translate and rotate the two targets, and click on the "Recompute trajectory" button to update the
        path followed by the end-effector.</p>

    <button id="btnCompute" style="font-family: sans-serif; margin-bottom: 20px; font-size: 0.9em;">Recompute trajectory</button>

    <div id="loader-container">
        <span class="loader"></span>
    </div>

    <div id="viewer3d" style="height: 700px"></div>


    <!-- Import all the necessary JavaScript dependency modules
    Sadly, can't be imported from an external file for the moment, this is not supported by Chrome
    -->
    <script src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
                "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
                "mujoco": "../../viewer3d/jsm/mujoco_wasm.js",
                "katex": "https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.mjs",
                "mathjs": "https://cdn.jsdelivr.net/npm/mathjs@14.1.0/+esm"
            }
        }
    </script>


    <!-- Import the viewer3d.js library -->
    <script type="module">
        import { downloadScene, downloadPandaRobot, initPyScript } from '../../viewer3d/viewer3d.js';

        // Download the assets
        await downloadPandaRobot();
        await downloadScene('../scenes/panda.xml');

        // Now PyScript can be initialised
        initPyScript();
    </script>


    <py-script>
        from viewer3d import Viewer3D, configs, Shapes, logmap
        from js import document
        from pyodide.ffi import create_proxy
        import numpy as np

        document.getElementById('loader-container').style.display = 'none';

        # Contains all the variables needed for the animation
        animation = lambda: None # Lazy way to define an empty class in python
        animation.startTime = None
        animation.dt = 5e-2
        animation.positions = None

        # This function will be called once per frame
        def update(delta, time):
            if animation.positions is None:
                return

            if animation.startTime is None:
                animation.startTime = time

            t = min(int((time - animation.startTime) / animation.dt), animation.positions.shape[1] - 1)
            robot.jointPositions = animation.positions[:, t]

            if time > animation.startTime + (animation.positions.shape[1] + 10) * animation.dt:
                animation.startTime = None

        # Recompute the trajectory
        def recompute(event=None):
            viewer3D.removePath('trajectory')
            animation.startTime = None

            x = ilqr()

            # Add some paths
            points = np.ndarray((x.shape[1], 3))
            for i in range(x.shape[1]):
                points[i, :] = robot.fkin(x[:, i])[:3]

            viewer3D.addPath(
                'trajectory',
                points,
                0.005,
                '#ffcc00',
                False,      # No shading
                True        # Transparent
            )

            animation.positions = x

        # Compute the trajectory using iLQR
        def ilqr():
            ## Parameters
            # ===============================

            param = lambda: None # Lazy way to define an empty class in python
            param.dt = animation.dt # Time step length
            param.nbData = 50 # Number of datapoints
            param.nbIter = 30 # Maximum number of iterations for iLQR
            param.nbPoints = 2 # Number of viapoints
            param.nbVarX = 7 # State space dimension (x1,x2,x3)
            param.nbVarU = param.nbVarX # Control space dimension (dx1,dx2,dx3)
            param.nbVarF = 7 # Task space dimension (f1,f2,f3 for position, f4,f5,f6,f7 for unit quaternion)
            param.q = 1e0 # Tracking weighting term
            param.r = 1e-6 # Control weighting term

            param.Mu = np.ndarray((param.nbVarF, param.nbPoints))
            param.Mu[:, 0] = target1.transforms
            param.Mu[:, 1] = target2.transforms

            # Initialisations
            # ===============================

            # Precision matrix
            Q = np.eye((param.nbVarF-1) * param.nbPoints) * param.q

            # Control weight matrix (at trajectory level)
            R = np.eye((param.nbData-1) * param.nbVarU) * param.r

            # Time occurrence of viapoints
            tl = np.linspace(1, param.nbData, param.nbPoints+1)
            tl = np.rint(tl[1:]).astype(np.int64) - 1
            idx = np.array([i + np.arange(0,param.nbVarX,1) for i in (tl*param.nbVarX)]).flatten()

            # Transfer matrices (for linear system as single integrator)
            Su0 = np.vstack([
                np.zeros([param.nbVarX, param.nbVarX*(param.nbData-1)]), 
                np.tril(np.kron(np.ones([param.nbData-1, param.nbData-1]), np.eye(param.nbVarX) * param.dt))
            ]) 
            Sx0 = np.kron(np.ones(param.nbData), np.eye(param.nbVarX)).T
            Su = Su0[idx,:] # We remove the lines that are out of interest

            # iLQR
            # ===============================

            u = np.zeros((param.nbVarU * (param.nbData-1), 1)) # Initial control command
            x0 = np.array([0, 0, 0, -np.pi/2, -0, np.pi/2, 0]) # Initial robot pose
            x0 = x0.reshape((-1, 1))

            for i in range(param.nbIter):
                x = Su0 @ u + Sx0 @ x0 # System evolution
                x = x.reshape([param.nbVarX, param.nbData], order='F')

                f, J = f_reach(x[:,tl], param) # Residuals and Jacobians
                f = f.reshape((-1,1), order='F')

                du = np.linalg.pinv(Su.T @ J.T @ Q @ J @ Su + R) @ (-Su.T @ J.T @ Q @ f - u * param.r) # Gauss-Newton update

                # Estimate step size with backtracking line search method
                alpha = 1
                cost0 = f.T @ Q @ f + np.linalg.norm(u)**2 * param.r # Cost
                while True:
                    utmp = u + du * alpha
                    xtmp = Su0 @ utmp + Sx0 @ x0 # System evolution
                    xtmp = xtmp.reshape([param.nbVarX, param.nbData], order='F')
                    ftmp,_ = f_reach(xtmp[:,tl], param) # Residuals
                    ftmp = ftmp.reshape((-1,1), order='F')
                    cost = ftmp.T @ Q @ ftmp + np.linalg.norm(utmp)**2 * param.r # Cost
                    if cost < cost0 or alpha < 1e-3:
                        break
                    alpha /= 2

                u = u + du * alpha

                if np.linalg.norm(du * alpha) < 1E-2:
                    break # Stop iLQR iterations when solution is reached

            return x

        # Cost and gradient for a viapoints reaching task (in object coordinate system)
        def f_reach(x, param):
            ftmp = robot.fkin(x)
            f = logmap(ftmp, param.Mu)
            J = np.zeros([param.nbPoints * 6, param.nbPoints * param.nbVarX])
            for t in range(param.nbPoints):
                J[t*6:(t+1)*6, t*param.nbVarX:(t+1)*param.nbVarX] = robot.Jkin(x[:,t])
            return f, J


        # Create the Viewer3D
        viewer3D = Viewer3D(document.getElementById('viewer3d'))
        viewer3D.setRenderingCallback(update)

        # Load the scene and retrieve the robot
        viewer3D.loadScene('/scenes/panda.xml')
        robot = viewer3D.createRobot('panda', configs.Panda.new())

        # Disable the manipulation of the joints and the end-effector (since the robot is controlled by our code)
        viewer3D.jointsManipulationEnabled = False
        viewer3D.endEffectorManipulationEnabled = False

        # Add some targets
        target1 = viewer3D.addTarget('target1', [0.6, 0.0, 0.2], [1.0, 0.0, 0.0, 0.0], '#0000aa', Shapes.Cone)
        target2 = viewer3D.addTarget('target2', [0.3, -0.5, 0.3], [0.0, -1.0, 0.0, 0.0], '#00aa00', Shapes.Cone)

        # Handle clicks on the 'recompute' button
        document.getElementById('btnCompute').addEventListener('click', create_proxy(recompute))
        recompute()
    </py-script>
</body>
</html>
