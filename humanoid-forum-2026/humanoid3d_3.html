<h3>Humanoid robot: Pick-and-place challenge</h3>

<div style="display: inline-block; width: 49%; height: 90%; vertical-align: top;">
    <editor id="humanoid3d_3_editor" src="humanoid3d_3_user_code"></editor>

    <pre id="humanoid3d_3_errors" class="py-error"></pre>
    <pre id="humanoid3d_3_output" class="py-output"></pre>
</div>

<div style="display: inline-block; width: 49%; height: 90%; vertical-align: top;">
    <div id="humanoid3d_3_viewer3d" style="width: 100%; height: 400px;"></div>
    <div id="success" style="display:none; position: absolute; top: 6rem; text-align: center; width: 49%; color: limegreen; font-size: 100px; font-weight: bold;">
        &#x2714;
    </div>
</div>


<script id="humanoid3d_3_user_code" type="python">
# The steps we'll follow to grab the cube and place it on the target
STEP_RAISE_ARM = 0
STEP_GO_ON_TOP_OF_CUBE = 1
STEP_GO_DOWN = 2
STEP_CLOSE_GRIPPER = 3
STEP_GO_UP = 4
STEP_GO_ON_TOP_OF_TARGET = 5
STEP_GO_DOWN_ON_TARGET = 6
STEP_RELEASE_CUBE = 7
STEP_GO_UP_FINAL = 8


class IK:
    """An helper class to perform Inverse Kinematics to reach a
    specific destination (position + orientation)
    """

    def __init__(self, chain, destination, weights=None):
        self.chain = chain
        self.destination = destination
        self.weights = weights
        self.last_errors = []

    def process(self, x, dt):
        """Returns the control command to apply to the robot
        """
        J = self.chain.Jkin(x)
        f = self.chain.fkin(x)

        # Position & orientation tracking (with weights)
        if self.weights is not None:
            Q = np.diag(self.weights)
            u = np.linalg.pinv(J.T @ Q @ J) @ J.T @ Q @ logmap(self.destination, f)

        # Position & orientation tracking
        else:
            u = np.linalg.pinv(J) @ logmap(self.destination, f)

        return u / dt  # Velocity in rad/s

    def done(self, x):
        """Indicates if the destination is reached

        We'll consider that if the difference between the
        position/orientation of the gripper and the destination
        didn't diminish significantly over 5 updates, then
        the destination is reached
        """

        # Compute the difference (by applying weights if needed)
        f = self.chain.fkin(x)
        diff = logmap(self.destination, f)

        if self.weights is not None:
            diff = diff @ self.weights

        error = np.linalg.norm(diff)

        # Memorize the 5 last differences
        self.last_errors.append(error)
        if len(self.last_errors) < 5:
            return False

        self.last_errors = self.last_errors[1:]

        # Use the variance to determine if the diminution is still
        # significant
        return np.var(self.last_errors) < 1e-10


# The variables we need to keep track of the current step
step = None
ik = None


def controlCommand(x, dt):
    global step, ik

    # Only keep the joint positions of the kinematic chain we are
    # using
    chain_x = right_chain.sample(x)
    
    # If an IK-based movement is in progress, continue it until
    # the destination is reached
    if (ik is not None) and not(ik.done(chain_x)):
        return right_chain.project(ik.process(chain_x, dt))

    ik = None

    # At startup: we need to rise the arm, in order to not collide
    # with the orange base later
    if step is None:
        if right_chain.fkin(chain_x)[2] < 0.9:
            u = np.zeros(chain_x.shape)
            u[4] = -0.2 / dt
            return right_chain.project(u)
        else:
            step = STEP_RAISE_ARM

    # Once the arm is raised, we want to go above the cube,
    # but with a small offset (thus when the hand will go
    # grab the cube, it doesn't risk to push it with a finger),
    # with the hand horizontal (= Y-axis pointing down)
    elif step == STEP_RAISE_ARM:
        step = STEP_GO_ON_TOP_OF_CUBE

        destination = np.concatenate((
            cube_start_position + np.array([-0.1, -0.1, 0.15]),
            [
                math.sin(-math.pi / 4.0),
                0.0,
                0.0,
                math.cos(-math.pi / 4.0)
            ]
        ))

        ik = IK(right_chain, destination)
        return right_chain.project(ik.process(chain_x, dt))

    # We are above the cube and correctly oriented, now move the
    # hand down
    elif step == STEP_GO_ON_TOP_OF_CUBE:
        step = STEP_GO_DOWN
        gripper_pose = right_chain.fkin(chain_x)
        destination = np.concatenate((
            cube_start_position,
            gripper_pose[3:]
        ))
        ik = IK(right_chain, destination)
        return right_chain.project(ik.process(chain_x, dt))

    # Once at the cube location, close the hand
    elif step == STEP_GO_DOWN:
        robot.closeGripper(0)
        step = STEP_CLOSE_GRIPPER

    # Wait until the gripper is holding the cube and go up again
    elif step == STEP_CLOSE_GRIPPER:
        if robot.isGripperHoldingSomeObject(0):
            step = STEP_GO_UP
            destination = right_chain.fkin(chain_x)
            destination[2] += 0.15
            ik = IK(right_chain, destination)
            return right_chain.project(ik.process(chain_x, dt))

    # Once we lifted the cube, move on top of the target
    # (again using weighted IK)
    elif step == STEP_GO_UP:
        step = STEP_GO_ON_TOP_OF_TARGET
        destination = right_chain.fkin(chain_x)
        destination[:3] = target_position
        destination[2] += 0.15
        ik = IK(right_chain, destination, [1, 1, 1, 1, 1, 0])
        return right_chain.project(ik.process(chain_x, dt))
    
    # Once above the target, go down
    elif step == STEP_GO_ON_TOP_OF_TARGET:
        step = STEP_GO_DOWN_ON_TARGET
        destination = right_chain.fkin(chain_x)
        destination[:3] = target_position
        ik = IK(right_chain, destination)
        return right_chain.project(ik.process(chain_x, dt))

    # Once at the target, open the hand
    elif step == STEP_GO_DOWN_ON_TARGET:
        robot.openGripper(0)
        step = STEP_RELEASE_CUBE

    # Once the cube is released, go up one last time
    elif step == STEP_RELEASE_CUBE:
        if robot.isGripperOpen(0):
            step = STEP_GO_UP_FINAL
            destination = right_chain.fkin(chain_x)
            destination[2] += 0.15
            ik = IK(right_chain, destination)
            return right_chain.project(ik.process(chain_x, dt))

    # By default: no movement
    return np.zeros(x.shape)  # Velocity in rad/s
</script>


<script id="humanoid3d_3_page_code" type="python">
    from viewer3d import Viewer3D, logmap_S3, logmap, readFile, writeFile, SceneBuilder, Robots, Tools
    from js import document, three
    from pyodide.ffi import create_proxy
    from rcfs import configure, displayError, setAspectRatio
    import numpy as np
    from scipy.spatial.transform import Rotation as R
    import math


    # The elements in the scene
    robot = None
    right_chain = None
    left_chain = None
    cube = None

    # Initial state of the elements in the scene
    initial_robot_joint_positions = None
    initial_cube_position = None
    initial_cube_orientation = None
    initial_source_base_position = None
    initial_target_base_position = None

    # Internal state
    targetReached = False
    targetReachedStartTime = None
    resetting = False


    # Variables available to the user
    cube_start_position = None
    cube_start_angle = None
    source_position = None
    target_position = None
    bases_width = None

    cube_start_ref = None
    cube_start_angle_ref = None
    source_position_ref = None
    target_position_ref = None
    bases_width_ref = None

    # The function that will be called once per frame
    def callback(delta, time):
        global cube_start_position, cube_start_angle, source_position, target_position, \
               bases_width, targetReached, targetReachedStartTime, resetting

        if resetting:
            if robot.isGripperOpen(0) and robot.isGripperOpen(1):
                resetting = False
            return

        cube_start_position = np.copy(cube_start_ref[:3])
        cube_start_angle = cube_start_angle_ref
        source_position = np.copy(source_position_ref)
        target_position = np.copy(target_position_ref)
        bases_width = bases_width_ref

        try:
            x = robot.jointPositions
            u = np.array(controlCommand(x, delta))
            x += u * delta * 0.2
            robot.control = x
        except Exception as e:
            displayError(e)

        pos = cube.position
        reached = robot.isGripperOpen(0) and robot.isGripperOpen(1) and \
                  (pos[0] > target_position_ref[0] - 0.1) and (pos[0] < target_position_ref[0] + 0.1) and \
                  (pos[1] > target_position_ref[1] - 0.1) and (pos[1] < target_position_ref[1] + 0.1) and \
                  (pos[2] > target_position_ref[2] - 0.03) and (pos[2] < target_position_ref[2] + 0.02)

        if reached:
            if not targetReached:
                targetReached = True
                targetReachedStartTime = time
            elif time - targetReachedStartTime > 5.0:
                viewer3D.physicsSimulatorPaused = False
                viewer3D.setRenderingCallback(None)
                document.getElementById('success').style.display = 'block'
        else:
            targetReached = False
            targetReachedStartTime = None


    # Load the scene and retrieve the robot
    def reset():
        global targetReached, targetReachedStartTime, cube_start_ref, cube_start_angle_ref, \
               source_position_ref, target_position_ref, bases_width_ref, resetting

        viewer3D.physicsSimulatorPaused = True

        targetReached = False
        targetReachedStartTime = None
        resetting = True

        # Reset the robot to its initial state
        robot.jointPositions = initial_robot_joint_positions
        robot.control = initial_robot_joint_positions

        if not robot.isGripperOpen(0):
            robot.openGripper(0)

        if not robot.isGripperOpen(1):
            robot.openGripper(1)

        # Randomly place the cube on its base
        position = np.copy(initial_cube_position)

        # offset = np.random.rand(2) * 0.16 - 0.08
        # position[:2] += offset

        # cube_start_angle_ref = np.random.random() * math.pi / 2 - math.pi / 4

        orientation = R.from_quat(initial_cube_orientation)
        # orientation *= R.from_euler('Y', -cube_start_angle_ref)

        cube.position = position
        cube.orientation = orientation.as_quat()

        # Store the values we want the user to have access to
        cube_start_ref = np.concatenate((position, orientation.as_quat()))
        source_position_ref = np.array(initial_source_base_position) + [0, 0, 0.4]
        target_position_ref = np.array(initial_target_base_position) + [0, 0, 0.46]
        bases_width_ref = 0.2

        # Hide the success indicator
        document.getElementById('success').style.display = 'none'

        # Starts the physics simulation
        viewer3D.physicsSimulatorPaused = False
        viewer3D.setRenderingCallback(callback)


    # Resize the container of the Viewer3D to have a 1:1 aspect ratio
    setAspectRatio('humanoid3d_3_viewer3d', 1.0)

    # Create the Viewer3D
    viewer3D = Viewer3D(
        document.getElementById('humanoid3d_3_viewer3d'),
        {
            'external_loop': True,
        }
    )

    # Setup the scene
    builder = SceneBuilder('/scenes/humanoid3d_3.xml')

    builder.addRobot(
        'robot', Robots.G1_FixedLegs,
        [0.0, 0.0, 0.0],
        [0.0, 0.0, 0.0, 1.0],
        [
            Tools.UnitreeRightDex3_1,
            Tools.UnitreeLeftDex3_1,
        ]
    )

    # Load the scene
    viewer3D.loadScene(builder)
    viewer3D.translateCamera([0.0, 0.0, 0.3])

    # Retrieve the robot, the kinematic chains and the initial joint positions
    robot = viewer3D.getRobot('robot')
    right_chain = robot.getKinematicChainForTool(0)
    left_chain = robot.getKinematicChainForTool(1)
    initial_robot_joint_positions = [ 0., 0., 0., 0., 0.2, 0., 1.28, 0., 0., 0., 0., -0.2, 0., 1.28, 0., 0., 0. ]

    # Retrieve the cube and its initial transforms
    cube = viewer3D.getPhysicalBody('redcube')
    initial_cube_position = cube.position
    initial_cube_orientation = cube.orientation

    # Retrieve the bases and their initial position
    def getBasePosition(name):
        body_id = viewer3D.viewer.physicsSimulator.getBodyId(name)
        position = viewer3D.viewer.physicsSimulator.getBodyPosition(body_id)
        return np.array([position.x, position.y, position.z])

    initial_source_base_position = getBasePosition('source_base')
    initial_target_base_position = getBasePosition('target_base')

    # Add some axes
    right_hand_axes = viewer3D.addAxes('right_hand_axes')
    robot.toolControlPoint(0).add(right_hand_axes)

    left_hand_axes = viewer3D.addAxes('left_hand_axes')
    robot.toolControlPoint(1).add(left_hand_axes)

    cube_axes = viewer3D.addAxes('cube_axes')
    cube_axes.object.lines[1].scale.set(0, 0, 0)
    cube_axes.object.lines[2].scale.set(0, 0, 0)
    cube.add(cube_axes)

    scene_axes = viewer3D.addAxes('scene_axes', length=1.0)

    # Disable the manipulations
    viewer3D.controlsEnabled = False

    reset()


    # Placeholder for the function to implement
    def controlCommand(x, dt):
        return np.zeros(x.shape)

    # Forward kinematics function (allows to not care about 'robot' in the user code)
    def fkin(x):
        return robot.fkin(x)

    # Jacobian function (allows to not care about 'robot' in the user code)
    def Jkin(x):
        return robot.Jkin(x)

    # Function to open the gripper (allows to not care about 'robot' in the user code)
    def openGripper(index):
        robot.openGripper(index)

    # Function to close the gripper (allows to not care about 'robot' in the user code)
    def closeGripper(index):
        robot.closeGripper(index)

    # Function that indicates if the gripper is fully open (allows to not care about 'robot' in the user code)
    def isGripperOpen(index):
        return robot.isGripperOpen(index)

    # Function that indicates if the gripper is fully closed (allows to not care about 'robot' in the user code)
    def isGripperClosed(index):
        return robot.isGripperClosed(index)

    # Function that indicates if the gripper is holding an object (allows to not care about 'robot' in the user code)
    def isGripperHoldingSomeObject(index):
        return robot.isGripperHoldingSomeObject(index)


    async def run():
        try:
            reset()
        except Exception as e:
            displayError(e)


    async def loop(delta, time):
        viewer3D.render()


    async def cleanup():
        global viewer3D
        viewer3D.dispose()
        viewer3D = None
        document.getElementById('humanoid3d_3_viewer3d').innerHTML = ''


    configure({
        'loop': loop,
        'run': run,
        'cleanup': cleanup,
        'output': 'humanoid3d_3_output',
        'errors': 'humanoid3d_3_errors',
    })
</script>
