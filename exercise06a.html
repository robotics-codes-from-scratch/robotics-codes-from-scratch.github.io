<!DOCTYPE html>

<html lang="en">
<head>


<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="RCFS" name="description"/>
<meta content="robotics codes, robotics tutorial, rcfs, robotics from scratch" name="keywords"/>
<meta content="Sylvain Calinon" name="author"/>
<title>RCFS</title>
<link href="static_images/favicon.ico" rel="icon" sizes="any"/>
<link href="static_images/favicon.svg" rel="icon" type="image/svg+xml"/>

<link href="css/bootstrap.min.css" rel="stylesheet"/>
<link href="css/bootstrap-icons-1.10.4/font/bootstrap-icons.css" rel="stylesheet"/>
<link href="css/permanent_marker.css" rel="stylesheet"/>
<link href="css/sidebars.css" rel="stylesheet"/>
<script src="js/jquery-3.6.4.min.js"></script>
<script src="js/bootstrap.bundle.min.js"></script>

<script defer="" src="https://pyscript.net/latest/pyscript.min.js"></script>
<!--<script defer src='js/pyscript.js'></script>-->
<py-config type="toml">

				packages = ['numpy']
			
</py-config>
<link href="https://pyscript.net/latest/pyscript.css" rel="stylesheet"/> <!-- pyscript.css is incompatible with hypothes.is/embed.js-->

<link href="css/katex.min.css" rel="stylesheet"/>
<script src="js/katex.min.js"></script>
<script defer="" src="js/katex-auto-render.js"></script>
<script>
        const macros = {
            '\\tp': '\\text{\\tiny{#1}}',
            '\\trsp' : '\\top',
            '\\psin' : '\\dagger',
            '\\eqref': '\\href{###1}{(\\text{#1})}',
            '\\ref': '\\href{###1}{\\text{#1}}',
            '\\label': '\\htmlId{#1}{}'
        };

        function initialize(){
            convertMath();
        }

        function convertMath(){
            const elements = document.getElementsByClassName("ltx_Math");
            for(let element of elements){
                katex.render(element.textContent, element, {
                    throwOnError: false,
                    macros
                });
            }
        }

        window.onload = initialize;

        document.addEventListener('DOMContentLoaded', function() {
            renderMathInElement(document.body, {
                // customised options
                trust: (context) => ['\\htmlId', '\\href'].includes(context.command),
                macros: macros,
                // • auto-render specific keys, e.g.:
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\begin{equation}', right: '\\end{equation}', display: true},
                    {left: '\\begin{equation*}', right: '\\end{equation*}', display: true},
                    {left: '\\begin{align}', right: '\\end{align}', display: true},
                    {left: '\\begin{align*}', right: '\\end{align*}', display: true},
                    {left: '\\begin{alignat}', right: '\\end{alignat}', display: true},
                    {left: '\\begin{gather}', right: '\\end{gather}', display: true},
                    {left: '\\begin{CD}', right: '\\end{CD}', display: true},
                    {left: '\\[', right: '\\]', display: true}
                ],
                // • rendering keys, e.g.:
                throwOnError : false
            });
        });
    </script>

<link href="css/main-template.css" rel="stylesheet"/>
</head>
<body><nav aria-label="Light offcanvas navbar" class="navbar fixed-top" style="width: 50px;">
<div class="container-fluid">
<button aria-controls="offcanvasNavbarLight" class="navbar-toggler" data-bs-target="#offcanvasNavbarLight" data-bs-toggle="offcanvas" type="button">
<span class="navbar-toggler-icon" style="cursor: pointer;"></span>
</button>
<div aria-labelledby="offcanvasNavbarLightLabel" class="offcanvas offcanvas-start" id="offcanvasNavbarLight" style="width: 500px;" tabindex="-1">
<div class="offcanvas-header"><!--style='height: 50px;'-->
<a class="navbar-brand" href="index.html"><h4 class="offcanvas-title" id="offcanvasNavbarLightLabel"> <i class="bi bi-code-slash"></i> RCFS</h4></a>
<button aria-label="Close" class="btn-close" data-bs-dismiss="offcanvas" type="button"></button>
</div>
<div class="offcanvas-body">
<!--Menu goes here-->
<ul class="list-unstyled ps-0">
<li class="border-top my-1"></li>
<li class="mb-1">
<button aria-expanded="true" class="btn btn-toggle d-inline-flex align-items-center rounded border-0 collapsed" data-bs-target="#general-collapse" data-bs-toggle="collapse">General information</button>
<div class="collapse show" id="general-collapse">
<!--<li><a href='index.html' class='link-dark d-inline-flex text-decoration-none rounded'>Home</a></li>-->
<ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small">
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="about.html">
<div class="p-1 mb-0">About</div></a></li>
</ul>
</div>
</li>
<li class="border-top my-1"></li>
<li class="mb-1">
<button aria-expanded="false" class="btn btn-toggle d-inline-flex align-items-center rounded border-0 collapsed" data-bs-target="#sandboxes2d-collapse" data-bs-toggle="collapse">2D sandboxes</button>
<div class="collapse" id="sandboxes2d-collapse">
<ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small">
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="sandbox_FK.html">
<div class="p-1 mb-0">Forward kinematics (FK)</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="sandbox_IK.html">
<div class="p-1 mb-0">Inverse kinematics (IK)</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="sandbox_bimanual.html">
<div class="p-1 mb-0">Bimanual robot</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="sandbox_humanoid.html">
<div class="p-1 mb-0">Humanoid robot (CoM and coordination matrix)</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="sandbox_iLQR.html">
<div class="p-1 mb-0">Iterative linear quadratic regulator (iLQR)</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="sandbox_iLQR_car.html">
<div class="p-1 mb-0">iLQR for car</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="sandbox_iLQR_bicopter.html">
<div class="p-1 mb-0">iLQR for bicopter</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="sandbox_impedance.html">
<div class="p-1 mb-0">Impedance control</div></a></li>
</ul>
</div>
</li>
<li class="border-top my-1"></li>
<li class="mb-1">
<button aria-expanded="false" class="btn btn-toggle d-inline-flex align-items-center rounded border-0 collapsed" data-bs-target="#sandboxes3d-collapse" data-bs-toggle="collapse">3D sandboxes</button>
<div class="collapse" id="sandboxes3d-collapse">
<ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small">
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="sandbox3d_IK.html">
<div class="p-1 mb-0">Inverse kinematics (IK)</div></a></li>
</ul>
</div>
</li>
<li class="border-top my-1"></li>
<li class="mb-1">
<button aria-expanded="false" class="btn btn-toggle d-inline-flex align-items-center rounded border-0 collapsed" data-bs-target="#exercises-collapse" data-bs-toggle="collapse">Coding exercises</button>
<div class="collapse" id="exercises-collapse">
<ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small">
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise01.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">01</div>
<div class="p-1 mb-0">Linear algebra in Python</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise02.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">02</div>
<div class="p-1 mb-0">Movement primitives and Newton's method</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise03.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">03</div>
<div class="p-1 mb-0">Gaussian Distributions</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise04a.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">4a</div>
<div class="p-1 mb-0">Forward kinematics</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise04b.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">4b</div>
<div class="p-1 mb-0">Inverse kinematics and nullspace control</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise05a.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">5a</div>
<div class="p-1 mb-0">Forward dynamics</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise05b.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">5b</div>
<div class="p-1 mb-0">Inverse dynamics and impedance control</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise06a.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">6a</div>
<div class="p-1 mb-0">Planning with linear quadratic regulator</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise06b.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">6b</div>
<div class="p-1 mb-0">Planning in joint space with LQR</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise07.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">07</div>
<div class="p-1 mb-0">Iterative linear quadratic regulator (iLQR)</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise08.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">08</div>
<div class="p-1 mb-0">Exploration with ergodic control</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise09.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">09</div>
<div class="p-1 mb-0">Orientation with Riemannian manifold</div></a></li>
</ul>
</div>
</li>
<li class="border-top my-1"></li>
<li class="mb-1">
<button aria-expanded="false" class="btn btn-toggle d-inline-flex align-items-center rounded border-0 collapsed" data-bs-target="#doc-collapse" data-bs-toggle="collapse">Online course</button>
<div class="collapse" id="doc-collapse">
<ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small" id="menu_container">
<li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="toc.html" style="font-weight:bold;">Table of contents</a></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="S1.html" style="font-weight:bold;">1 Introduction</a></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="S2.html" style="font-weight:bold;">2 Newton’s method for minimization</a><div><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S2.html#sec:GaussNewton"><span class="p-1 mb-0">2.1 Gauss–Newton algorithm</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S2.html#sec:LS"><span class="p-1 mb-0">2.2 Least squares</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S2.html#sec:LSconstraints"><span class="p-1 mb-0">2.3 Least squares with constraints</span></a></li></ul></div></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="S3.html" style="font-weight:bold;">3 Forward kinematics (FK) for a planar robot manipulator</a></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="S4.html" style="font-weight:bold;">4 Inverse kinematics (IK) for a planar robot manipulator</a><div><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S4.html#sec:IKnum"><span class="p-1 mb-0">4.1 Numerical estimation of the Jacobian</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S4.html#sec:IK_nullspace"><span class="p-1 mb-0">4.2 Inverse kinematics (IK) with task prioritization</span></a></li></ul></div></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="S5.html" style="font-weight:bold;">5 Encoding with basis functions</a><div><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S5.html#SS1"><span class="p-1 mb-0">5.1 Univariate trajectories</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S5.html#SS2"><span class="p-1 mb-0">5.2 Multivariate trajectories</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S5.html#SS3"><span class="p-1 mb-0">5.3 Multidimensional inputs</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S5.html#SS4"><span class="p-1 mb-0">5.4 Derivatives</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S5.html#SS5"><span class="p-1 mb-0">5.5 Concatenated basis functions</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S5.html#SS6"><span class="p-1 mb-0">5.6 Batch computation of basis functions coefficients</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S5.html#SS7"><span class="p-1 mb-0">5.7 Recursive computation of basis functions coefficients</span></a></li></ul></div></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="S6.html" style="font-weight:bold;">6 Linear quadratic tracking (LQT)</a><div><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S6.html#SS1"><span class="p-1 mb-0">6.1 LQT with smoothness cost</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S6.html#SS2"><span class="p-1 mb-0">6.2 LQT with control primitives</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S6.html#sec:LQRrecursive"><span class="p-1 mb-0">6.3 LQR with a recursive formulation</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S6.html#sec:augmState"><span class="p-1 mb-0">6.4 LQT with a recursive formulation and an augmented state space</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S6.html#sec:LQRLS"><span class="p-1 mb-0">6.5 Least squares formulation of recursive LQR</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S6.html#sec:DMPLQT"><span class="p-1 mb-0">6.6 Dynamical movement primitives (DMP) reformulated as LQT with control primitives</span></a></li></ul></div></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html" style="font-weight:bold;">7 iLQR optimization</a><div><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html#sec:iLQRbatch"><span class="p-1 mb-0">7.1 Batch formulation of iLQR</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html#sec:iLQRrecursive"><span class="p-1 mb-0">7.2 Recursive formulation of iLQR</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html#sec:iLQRLS"><span class="p-1 mb-0">7.3 Least squares formulation of recursive iLQR</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html#SS4"><span class="p-1 mb-0">7.4 Updates by considering step sizes</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html#SS5"><span class="p-1 mb-0">7.5 iLQR with quadratic cost on f(x_{t})</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html#SS6"><span class="p-1 mb-0">7.6 iLQR with control primitives</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html#SS7"><span class="p-1 mb-0">7.7 iLQR for spacetime optimization</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html#SS8"><span class="p-1 mb-0">7.8 iLQR with offdiagonal elements in the precision matrix</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html#SS9"><span class="p-1 mb-0">7.9 Car steering</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html#SS10"><span class="p-1 mb-0">7.10 Bicopter</span></a></li></ul></div></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="S8.html" style="font-weight:bold;">8 Forward dynamics (FD) for a planar robot manipulator</a><div><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S8.html#SS1"><span class="p-1 mb-0">8.1 Robot manipulator with dynamics equation</span></a></li></ul></div></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="bib.html" style="font-weight:bold;">References</a></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="A1.html" style="font-weight:bold;">A System dynamics at trajectory level</a></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="A2.html" style="font-weight:bold;">B Derivation of motion equation for a planar robot</a></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="A3.html" style="font-weight:bold;">C Linear systems used in the bimanual tennis serve example</a></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="A4.html" style="font-weight:bold;">D Equivalence between LQT and LQR with augmented state space</a></li></ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</nav>
<div class="container-fluid">
<script>
function clearMsgs() {
  const el = document.getElementById('errors');
  el.innerText = '';
  //console.log('event!');
}
function clearMsgsOutput() {
  const el = document.getElementById('output');
  el.innerText = '';
  //console.log('event!');
}
const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b','#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
</script>
<div class="row">
<div class="col-sm-1"></div>
<div class="col-sm-7">
<h1>Exercise 6a<br/>Planning with linear quadratic regulator</h1>
<p>Previously, in exercises 4 and 5, a desired target position was defined either in joint space or task space, without specifying the timings when the robot should follow to reach these target positions. We here extend the optimization to problems in which we can describe the timings and consider viapoints or full reference paths to be tracked, which provides the robot with planning and anticipation capability.<p>
<p>Optimal control is the principled way of planning a robot motion by specifying timings and/or a set of viapoints or a reference trajectory to follow.</p>
<p>Linear quadratic regulator (LQR) is the most simple form of optimal control. In this exercise, the goal is to understand how LQR works and how it can be applied to robot planning problems.</p>
<p>This exercise considers a point-mass agent in a 2D space. The two viapoints can be moved with the mouse. The provided code snippet allows you to specify the precision matrices used in LQR and to change the placement of two viapoints. The series of control commands generates a resulting path displayed in the figure (the black point shows the initial position). The figure also shows the corresponding covariance matrices (inverses of precision matrices) for the two viapoints (in pink and green).</p>
<ul class="list-group list-group-numbered">
<li class="list-group-item">
Modify the code so that the point-mass agent first passes through any point on the pink line (as displayed in the figure) and then reaches the green point at the end of the motion. This can be achieved by modifying the entries of <code>Q1</code>. Move the green point and observe the resulting path. Set <code>Q1</code> back to an identity matrix.
</li>
<li class="list-group-item">
<ul>
<li>Modify the code by setting <code>param.nbDeriv=2</code> so that the point-mass agent is controlled with acceleration commands instead of velocity commands (system dynamics defined as a double integrator instead of a simple integrator).</li>
<li>By modifying the entries of <code>Q1</code> and <code>Q2</code>, set precision matrices so that the first keypoint can be reached with any velocity and the final keypoint is reached with null velocity.</li>
<li>Try to decrease the values in the diagonal of <code>Q1</code> and <code>Q2</code> to change the desired precision requested to pass through the two viapoints and observe the results.
<li>Try to modify the control weight <code>param.r</code> and observe the result on the path.</li>
<li>Modify the code so that the first keypoint is reached at time steps 20 instead of 50. What do you observe?</li>
</li></ul>
</li>
</ul><br/>
<ul class="nav nav-tabs" id="myTab" role="tablist">
<li class="nav-item" role="presentation"> <button aria-controls="question1-tab-pane" aria-selected="true" class="nav-link active" data-bs-target="#question1-tab-pane" data-bs-toggle="tab" id="question1-tab" role="tab" type="button">LQR in task space</button>
</li>
<li class="nav-item" role="presentation"> <button aria-controls="answer1-tab-pane" aria-selected="false" class="nav-link" data-bs-target="#answer1-tab-pane" data-bs-toggle="tab" id="answer1-tab" role="tab" type="button">Answer 1</button>
</li>
<li class="nav-item" role="presentation"> <button aria-controls="answer2-tab-pane" aria-selected="false" class="nav-link" data-bs-target="#answer2-tab-pane" data-bs-toggle="tab" id="answer2-tab" role="tab" type="button">Answer 2</button>
</li>
</ul>
<div class="tab-content" id="myTabContent">
<div aria-labelledby="question1-tab" class="tab-pane fade show active" id="question1-tab-pane" role="tabpanel" tabindex="0">
<py-repl std-err="errors" std-out="output">
param.nbVarPos = 2 # Dimension of position variable
param.nbDeriv = 1 # Number of derivatives (1 for velocity commands)
param.nbVarX = param.nbVarPos * param.nbDeriv # Dimension of the state space
param.r = 1E-3 # Control command weight
# param.Mu = np.array([[100, 100], [0, 100]]) # Viapoints positions

x = np.array([0, 0]) # Initial position

# Time occurrence of viapoints
tl = np.array([50, 100])

# Precision matrix for the first viapoint
# Q1 = np.diag([1.0, 1.0]) # Precision matrix for a state described by position
Q1 = np.eye(param.nbVarX)

# Precision matrix for the second viapoint
Q2 = np.eye(param.nbVarX)

xs = solve_LQR(x, param) #Compute trajectory 

</py-repl>
</div>
<div aria-labelledby="answer1-tab" class="tab-pane fade" id="answer1-tab-pane" role="tabpanel" tabindex="0">
<py-repl std-err="errors" std-out="output">
param.nbVarPos = 2 # Dimension of position variable
param.nbDeriv = 1 # Number of derivatives (1 for velocity commands)
param.nbVarX = param.nbVarPos * param.nbDeriv # Dimension of the state space
param.r = 1E-3 # Control command weight
param.Mu = np.array([[-50, 100], [0, 100]]) # Viapoints positions

x = np.array([0, 0]) # Initial position

# Time occurrence of viapoints
tl = np.array([50, 100])

# Precision matrix for the first viapoint
Q1 = np.diag([10.0, 0.0])

# Precision matrix for the second viapoint
Q2 = np.eye(param.nbVarX)

xs = solve_LQR(x, param) #Compute trajectory 

</py-repl>
</div>
<div aria-labelledby="answer2-tab" class="tab-pane fade" id="answer2-tab-pane" role="tabpanel" tabindex="0">
<py-repl std-err="errors" std-out="output">
param.nbVarPos = 2 # Dimension of position variable
param.nbDeriv = 2 # Number of derivatives (2 for acceleration commands)
param.nbVarX = param.nbVarPos * param.nbDeriv # Dimension of the state space
param.r = 1E-3 # Control command weight

x = np.array([0, 0]) # Initial position

# Time occurrence of viapoints
tl = np.array([20, 100])

# Precision matrix for the first viapoint
Q1 = np.diag([1.0, 1.0, 0, 0])

# Precision matrix for the second viapoint
Q2 = np.eye(param.nbVarX)

xs = solve_LQR(x, param) #Compute trajectory 

</py-repl>
</div>
</div>
<br/><br/>
</p></p></div> <!--sm-7-->
<div class="col-sm-4">
<div class="sticky-sm-top" style="padding: 2rem 1rem 1rem 1rem;">
<hr/>
<div class="row justify-content-between">
<div class="col-auto"><button class="btn btn-light btn-sm" disabled="">Output</button></div>
<div class="col-auto"><button class="btn btn-outline-secondary btn-sm float-right" onclick="clearMsgsOutput()">Clear</button></div>
</div>
<div id="output"></div>
<hr/>
<div class="row justify-content-between">
<div class="col-auto"><button class="btn btn-light btn-sm" disabled="">Error</button></div>
<div class="col-auto"><button class="btn btn-outline-secondary btn-sm float-right" onclick="clearMsgs()">Clear</button></div>
</div>
<div id="errors"></div>
<hr/>
<canvas height="700px" id="canvas" style="width:100%;" width="900px"></canvas>
</div>
</div> <!--sm-4-->
</div> <!--row-->
<py-script>
    def print(x):
        display(x, target='output')
</py-script>
<py-script std-err="errors" std-out="output">
from pyodide.ffi import create_proxy
from js import Path2D, document, console
import numpy as np
import asyncio
from math import factorial

#########################################################################################
def compute_transfer_matrices(param):
	A1d = np.zeros((param.nbDeriv,param.nbDeriv))
	B1d = np.zeros((param.nbDeriv,1))

	for i in range(param.nbDeriv):
		A1d += np.diag( np.ones(param.nbDeriv-i) ,i ) * param.dt**i * 1/factorial(i)
		B1d[param.nbDeriv-i-1] = param.dt**(i+1) * 1/factorial(i+1)

	A = np.kron(A1d,np.identity(param.nbVarPos))
	B = np.kron(B1d,np.identity(param.nbVarPos))

	# Build Sx and Su transfer matrices
	Su = np.zeros((param.nbVarX*param.nbData,param.nbVarPos * (param.nbData-1)))
	Sx = np.kron(np.ones((param.nbData,1)),np.eye(param.nbVarX,param.nbVarX))
	M = B
	for i in range(1,param.nbData):
		Sx[i*param.nbVarX:param.nbData*param.nbVarX,:] = np.dot(Sx[i*param.nbVarX:param.nbData*param.nbVarX,:], A)
		Su[param.nbVarX*i:param.nbVarX*i+M.shape[0],0:M.shape[1]] = M
		M = np.hstack((np.dot(A,M),B)) # [0,nb_state_var-1]
	return Sx, Su

def solve_LQR(x0, param):
	idx = np.array([i + np.arange(0,param.nbVarX,1) for i in (tl*param.nbVarX)]).flatten() 
	Q = np.zeros((param.nbVarX * param.nbPoints, param.nbVarX * param.nbPoints))
	Q[:param.nbVarX, :param.nbVarX] = Q1
	Q[param.nbVarX:, param.nbVarX:] = Q2
	R = np.identity((param.nbData-1) * param.nbVarU) * param.r
	# Batch LQR Reproduction
	Sx, Su = compute_transfer_matrices(param)
	x0 = np.append(x, np.zeros(param.nbVarX-param.nbVarPos))
	xd = np.vstack([param.Mu, np.zeros((param.nbVarX-param.nbVarPos, param.nbPoints))]).T.flatten()
	u_hat = np.linalg.pinv(Su[idx,:].T @ Q @ Su[idx,:] + R) @ Su[idx,:].T @ Q @ (xd - Sx[idx,:] @ x0)
	x_hat = (Sx @ x0 + Su @ u_hat).reshape((param.nbData, -1)).T
	return x_hat

## Parameters
# ===============================

param = lambda: None # Lazy way to define an empty class in python
param.dt = 1E-1 # Time step length
param.nbData = 101 # Number of datapoints
param.nbVarU = 2 # Control space dimension (dx1,dx2)
param.nbPoints = 2 # Number of viapoints
param.nbDeriv = 1
param.nbVarPos = 2
param.nbVarX = param.nbVarPos * param.nbDeriv
param.Mu = np.array([[100, 100], [0, 100]]) # Viapoints positions
param.r = 1E-3

# Precision matrix
Q1 = np.eye(param.nbVarX) * 1E0
Q2 = np.eye(param.nbVarX) * 1E0

# Time occurrence of viapoints
tl = np.array([50, 100])

#########################################################################################

# GUI
scaling_factor = 2 # General scaling factor for rendering

# Mouse events
mouse0 = np.zeros(2)
mouse = np.zeros(2)
mousedown = 0
selected_obj = -1

def onMouseMove(event):
	global mouse, mouse0
	offset = canvas.getBoundingClientRect()
	mouse0[0] = (event.clientX - offset.x) * canvas.width / canvas.clientWidth
	mouse0[1] = (event.clientY - offset.y) * canvas.height / canvas.clientHeight
	mouse[0] = (mouse0[0] - canvas.width * 0.5) / scaling_factor
	mouse[1] = (mouse0[1] - canvas.height * 0.5) / scaling_factor
	
def onTouchMove(event):
	global mouse, mouse0
	offset = event.target.getBoundingClientRect()
	mouse0[0] = (event.touches.item(0).clientX - offset.x) * canvas.width / canvas.clientWidth
	mouse0[1] = (event.touches.item(0).clientY - offset.y) * canvas.height / canvas.clientHeight
	mouse[0] = (mouse0[0] - canvas.width * 0.5) / scaling_factor
	mouse[1] = (mouse0[1] - canvas.height * 0.5) / scaling_factor

def onMouseDown(event):
	global mousedown, xs
	mousedown = 1
	xs = solve_LQR(x, param)

def onMouseUp(event):
	global mousedown, selected_obj, xs
	mousedown = 0
	selected_obj = -1
	xs = solve_LQR(x, param)


document.addEventListener('mousemove', create_proxy(onMouseMove)) #for standard mouse
document.addEventListener('touchmove', create_proxy(onTouchMove)) #for mobile interfaces

document.addEventListener('mousedown', create_proxy(onMouseDown)) #for standard mouse
#document.addEventListener('pointerdown', create_proxy(onMouseDown)) #for mobile interfaces
document.addEventListener('touchstart', create_proxy(onMouseDown)) #for mobile interfaces

document.addEventListener('mouseup', create_proxy(onMouseUp)) #for standard mouse
#document.addEventListener('pointerup', create_proxy(onMouseUp)) #for mobile interfaces
document.addEventListener('touchend', create_proxy(onMouseUp)) #for mobile interfaces


#########################################################################################

canvas = document.getElementById('canvas')
ctx = canvas.getContext('2d')

def clear_screen():
	ctx.setTransform(1, 0, 0, 1, 0, 0) # Reset transformation to identity
	ctx.fillStyle = 'white'
	ctx.fillRect(0, 0, canvas.width, canvas.height)


def draw_Gaussian(id, param, color, color2):
	global selected_obj
	ctx.setTransform(scaling_factor, 0, 0, scaling_factor, canvas.width*0.5, canvas.height*0.5) # Reset transformation
	ctx.translate(param.Mu[0, id], param.Mu[1, id])
	if id == 0:
		s, U = np.linalg.eig(np.linalg.inv(Q1[:2, :2]+np.eye(2)*1e-5))
	else:
		s, U = np.linalg.eig(np.linalg.inv(Q2[:2, :2]+np.eye(2)*1e-5))
	al = np.linspace(-np.pi, np.pi, 50)
	D = np.diag(s)*100
	R = np.real(U @ np.sqrt(D+0j))
	msh = (R @ np.array([np.cos(al),np.sin(al)])).T #+ param.Mu[:2,id]
	# Draw object
	obj = Path2D.new()
	obj.moveTo(msh[0,0], msh[0,1])
	for i in range(msh.shape[0]-1):
		obj.lineTo(msh[i+1,0], msh[i+1,1])
	obj.closePath()
	ctx.strokeStyle = color2
	ctx.stroke(obj)
	ctx.fillStyle = color
	ctx.fill(obj)
	
	obj = Path2D.new()
	obj.arc(0, 0, 6.0, 0, 2*np.pi)
	ctx.fillStyle = color2 
	ctx.fill(obj)

	if ctx.isPointInPath(obj, mouse0[0], mouse0[1]) and mousedown==1:
		selected_obj = id


def draw_lqr_path(xs, param, color):
	ctx.setTransform(scaling_factor, 0, 0, scaling_factor, canvas.width*0.5, canvas.height*0.5) # Reset transformation
	# Draw initial point
	ctx.fillStyle = color
	ctx.beginPath()
	ctx.arc(xs[0,0], xs[1,0], 5, 0, 2*np.pi)
	ctx.fill()
	# Draw path
	ctx.lineWidth = '3'
	ctx.strokeStyle = color
	ctx.beginPath()
	ctx.moveTo(xs[0,0], xs[1,0])
	for i in range(param.nbData-1):
		ctx.lineTo(xs[0,i+1], xs[1,i+1])
	ctx.stroke()


def draw_line(color):
	ctx.setTransform(scaling_factor, 0, 0, scaling_factor, canvas.width*0.5, canvas.height*0.5) # Reset transformation
	ctx.lineCap = 'round'
	ctx.lineJoin = 'round'
	ctx.lineWidth = '2'
	ctx.strokeStyle = color
	ctx.beginPath()
	ctx.moveTo(-50, -1000)
	ctx.lineTo(-50, 1000)
	ctx.stroke()


#########################################################################################

def errorHandler(e):
	msg = 'Error: ' + str(e)
	console.error(msg)
	el = document.getElementById('errors')
	el.innerText = msg
	#el.textContent = msg

#########################################################################################
x = np.array([0,0]) # Initial position
u = np.zeros(param.nbVarX)
Sx, Su = compute_transfer_matrices(param)
xs = solve_LQR(x, param)

async def main():
	global param, xs

	while True:
		
		if mousedown==1:
			xs = solve_LQR(x, param)

		# Rendering
		clear_screen()
		draw_line('#FF77DD')
		draw_Gaussian(0, param, '#FF3399', '#DD1177')
		draw_Gaussian(1, param, '#33FF99', '#11DD77')
		draw_lqr_path(xs, param, '#000000')

		# Object selection
		if selected_obj &gt;= 0:
			param.Mu[:2,selected_obj] = mouse
			param.Mu[0,selected_obj] = max(min(param.Mu[0,selected_obj],225), -225)
			param.Mu[1,selected_obj] = max(min(param.Mu[1,selected_obj],175), -175)

		await asyncio.sleep(0.0001)

pyscript.run_until_complete(main())

</py-script>
</div> <!--container-->
</body>
</html>
