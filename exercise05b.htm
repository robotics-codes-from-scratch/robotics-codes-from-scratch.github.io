<!doctype html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='description' content='Robotics codes from scratch (RCFS) is a collection of source codes to study and test learning and optimization problems in robotics through simple 2D examples.'>
<meta name='keywords' content='robotics codes, robotics tutorial, rcfs, robotics from scratch'>
<meta name='author' content='Sylvain Calinon'>
<link rel='icon' href='images/favicon.ico' sizes='any'>
<link rel='icon' href='images/favicon.svg' type='image/svg+xml'>

<title>Robotics codes from scratch</title>
<link rel='canonical' href='https://robotics-codes-from-scratch.github.io/'>

<link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css' integrity='sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi' crossorigin='anonymous'>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.9.1/font/bootstrap-icons.css">

<link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Permanent+Marker|Raleway&display=swap'>


<script defer src='https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js' integrity='sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3' crossorigin='anonymous'></script>


<link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css' integrity='sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X' crossorigin='anonymous'>
<script defer src='https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js' integrity='sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz' crossorigin='anonymous'></script>
<script defer src='https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js' integrity='sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05' crossorigin='anonymous'></script>
<script>
let macros = {
	'\\tp': '\\text{\\tiny{#1}}',
	'\\trsp' : '\\top',
	'\\psin' : '\\dagger',
	'\\eqref': '\\href{###1}{(\\text{#1})}',
	'\\ref': '\\href{###1}{\\text{#1}}',
	'\\label': '\\htmlId{#1}{}'
};
document.addEventListener('DOMContentLoaded', function() {
	renderMathInElement(document.body, {
		// customised options
		trust: (context) => ['\\htmlId', '\\href'].includes(context.command),
		macros: macros,
		// • auto-render specific keys, e.g.:
		delimiters: [
			{left: '$$', right: '$$', display: true},
			{left: '$', right: '$', display: false},
			{left: '\\(', right: '\\)', display: false},
			{left: '\\begin{equation}', right: '\\end{equation}', display: true},
			{left: '\\begin{equation*}', right: '\\end{equation*}', display: true},
			{left: '\\begin{align}', right: '\\end{align}', display: true},
			{left: '\\begin{align*}', right: '\\end{align*}', display: true},
			{left: '\\begin{alignat}', right: '\\end{alignat}', display: true},
			{left: '\\begin{gather}', right: '\\end{gather}', display: true},
			{left: '\\begin{CD}', right: '\\end{CD}', display: true},
			{left: '\\[', right: '\\]', display: true}
		],
		// • rendering keys, e.g.:
		throwOnError : false
	});
});
</script>
	
<!-- <script defer src='https://hypothes.is/embed.js' async></script> --> <!-- pyscript.css is incompatible with hypothes.is/embed.js-->



<script defer src='https://pyscript.net/latest/pyscript.min.js'></script>
	
<py-config type='toml'>
	packages = ['numpy']
</py-config>
		
<link rel='stylesheet' href='https://pyscript.net/latest/pyscript.css'> <!-- pyscript.css is incompatible with hypothes.is/embed.js-->
	
<link rel='stylesheet' href='css/sidebars.css'> <!-- main navigation menu -->
<link rel='stylesheet' href='css/main-template.css'>

</head>

<body>

<nav class='navbar fixed-top' aria-label='Light offcanvas navbar' style='width: 50px;'>
<div class='container-fluid'>
<button class='navbar-toggler' type='button' data-bs-toggle='offcanvas' data-bs-target='#offcanvasNavbarLight' aria-controls='offcanvasNavbarLight'> 
<span class='navbar-toggler-icon' style='cursor: pointer;'></span>
</button>
<!--<a class='navbar-brand' href='#'><h4>Movement primitives</h4></a>-->    
  
  <div class='offcanvas offcanvas-start' tabindex='-1' id='offcanvasNavbarLight' aria-labelledby='offcanvasNavbarLightLabel' style='width: 500px;'>
    <div class='offcanvas-header'><!--style='height: 50px;'-->
      <a class='navbar-brand' href='index.htm'><h4 class='offcanvas-title' id='offcanvasNavbarLightLabel'><i class='bi bi-robot'></i> <i class='bi bi-code-slash'></i> RCFS</h4></a>
      <button type='button' class='btn-close' data-bs-dismiss='offcanvas' aria-label='Close'></button>
    </div>
    
    <div class='offcanvas-body'>
	<ul class='list-unstyled ps-0'>
	  
	  <!--<li><a href='index.htm' class='link-dark d-inline-flex text-decoration-none rounded'>Home</a></li>-->
	  
	  <li class='border-top my-1'></li>
	  
	  <li class='mb-1'>
		<button class='btn btn-toggle d-inline-flex align-items-center rounded border-0 collapsed' data-bs-toggle='collapse' data-bs-target='#sandboxes-collapse' aria-expanded='true'>Sandboxes</button>
		<div class='collapse show' id='sandboxes-collapse'>
		  <ul class='btn-toggle-nav list-unstyled fw-normal pb-1 small'>
		  	<li><a href='sandbox_FK.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
			<div class='p-1 mb-0'>Forward kinematics (FK)</div></a></li>
		    <li><a href='sandbox_IK.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
			<div class='p-1 mb-0'>Inverse kinematics (IK)</div></a></li>
			<li><a href='sandbox_bimanual.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
			<div class='p-1 mb-0'>Bimanual robot</div></a></li>
			<li><a href='sandbox_humanoid.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
			<div class='p-1 mb-0'>Humanoid robot (CoM and coordination matrix)</div></a></li>
		    <li><a href='sandbox_iLQR.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0'>Iterative linear quadratic regulator (iLQR)</div></a></li>
		    <li><a href='sandbox_iLQR_car.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0'>iLQR for car</div></a></li>
		    <li><a href='sandbox_iLQR_bicopter.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0'>iLQR for bicopter</div></a></li>
		  </ul>
		</div>
	  </li>
	  
	  <li class='border-top my-1'></li>
	  
	  <li class='mb-1'>
		<button class='btn btn-toggle d-inline-flex align-items-center rounded border-0 collapsed' data-bs-toggle='collapse' data-bs-target='#exercises-collapse' aria-expanded='true'>Exercises</button>
		<div class='collapse show' id='exercises-collapse'>
		  <ul class='btn-toggle-nav list-unstyled fw-normal pb-1 small'>
		    <li><a href='exercise01.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
			<div class='p-1 mb-0 bg-dark text-white font-monospace'>01</div>
			<div class='p-1 mb-0'>Linear algebra in Python</div></a></li>
		    <li><a href='exercise02.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0 bg-dark text-white font-monospace'>02</div>
			<div class='p-1 mb-0'>Movement primitives and Newton's method</div></a></li>
			<li><a href='exercise03.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0 bg-dark text-white font-monospace'>03</div>
			<div class='p-1 mb-0'>Gaussian Distributions</div></a></li>
			<li><a href='exercise04a.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0 bg-dark text-white font-monospace'>4a</div>
			<div class='p-1 mb-0'>Forward kinematics</div></a></li>
			<li><a href='exercise04b.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0 bg-dark text-white font-monospace'>4b</div>
			<div class='p-1 mb-0'>Inverse kinematics and nullspace control</div></a></li>
			<li><a href='exercise05a.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0 bg-dark text-white font-monospace'>5a</div>
			<div class='p-1 mb-0'>Forward dynamics</div></a></li>
			<li><a href='exercise05b.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0 bg-dark text-white font-monospace'>5b</div>
			<div class='p-1 mb-0'>Inverse dynamics and impedance control</div></a></li>
			<li><a href='exercise06a.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0 bg-dark text-white font-monospace'>6a</div>
			<div class='p-1 mb-0'>Planning with linear quadratic regulator</div></a></li>
			<li><a href='exercise06b.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0 bg-dark text-white font-monospace'>6b</div>
			<div class='p-1 mb-0'>Planning in joint space with LQR</div></a></li>
			<li><a href='exercise07.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0 bg-dark text-white font-monospace'>07</div>
			<div class='p-1 mb-0'>Iterative linear quadratic regulator (iLQR)</div></a></li>
			<li><a href='exercise08.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0 bg-dark text-white font-monospace'>08</div>
			<div class='p-1 mb-0'>Exploration with ergodic control</div></a></li>
		  </ul>
		</div>
	  </li>
	  
	</ul>
    </div> <!--offcanvas-body-->
    
  </div> <!--offcanvas-->
</div> <!--container-fluid-->
</nav>

<!-- <iframe enable-annotation></iframe> -->

<div class='container-fluid'>


<script>
function clearMsgs() {
  const el = document.getElementById('errors');
  el.innerText = '';
  //console.log('event!');
}
function clearMsgsOutput() {
  const el = document.getElementById('output');
  el.innerText = '';
  //console.log('event!');
}
const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b','#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
</script>

<div class='row'>
<div class='col-sm-1'></div>
<div class='col-sm-7'>

<h1>Exercise 5.b<br>Inverse dynamics and impedance control</h1>

<p>Inverse dynamics is the problem of computing the joint torques of a robot given its joint positions, velocities and accelerations: $\bm{\tau} = \bm{M}(\bm{q})\bm{\ddot{q}}+ \bm{C}(\bm{q},\bm{\dot{q}}) + \bm{g}(\bm{q})$.</p>
<p>These are physical models that allow us to control the motion of a robot. You can read about inverse dynamics in Section 6 of the <a href='doc/rcfs.pdf' target='_blank'>RCFS documentation</a>.</p>
<p>The goal of this exercise is to understand the terms in the inverse dynamics formulation and to control the robot to reach a desired position using <b>joint space impedance control</b>.</p>
<p>The function <code>inverse_dynamics(q, dq, ddq, param)</code> implements the inverse dynamics model for a planar manipulator. Its outputs are joint torques.</p> 
<p>The function <code>controlCommand(state, param)</code> takes the current state of the robot $[\bm{q}, \bm{\dot{q}}]$ as input and outputs joint torque commands that are sent to the robot.
<p>

<ul class='list-group list-group-numbered'>
	<li class='list-group-item'>
		Set $\bm{q}$, $\bm{\dot{q}}$ and $\bm{\ddot{q}}$ so that $ \bm{\tau} = \bm{g}(\bm{q})$. Perturb the robot with the mouse and observe the result of the perturbation.
	</li>
	<li class='list-group-item'>
		Set $\bm{q}$, $\bm{\dot{q}}$ and $\bm{\ddot{q}}$ so that $ \bm{\tau} = \bm{C}(\bm{q},\bm{\dot{q}}) + \bm{g}(\bm{q})$. Perturb the robot with the mouse and observe the result of the perturbation.
	</li>
	<li class='list-group-item'>
		We would like the robot to reach an upright position <code>q_target = np.array([np.pi/2, 0])</code> and stay there with zero velocity <code>dq_target = np.array([0, 0])</code>.
		Set $\bm{q}$, $\bm{\dot{q}}$ and $\bm{\ddot{q}}$ such that we implement the following impedance controller to achieve our goal: $\bm{\tau} = \bm{M}(\bm{q})(\bm{K}_p(\bm{q}^d - \bm{q}) + \bm{K}_v(\bm{\dot{q}}^d - \bm{\dot{q}})) + \bm{C}(\bm{q},\bm{\dot{q}}) + \bm{g}(\bm{q})$. 
		You should see that it stabilizes around the upright position. To check how stable is your controller, try to perturb the robot with the mouse. 
		Modify the values of stiffness and damping to see the effect of perturbations on the impedance controller.
	</li>
</ul><br>

<ul class='nav nav-tabs' id='myTab' role='tablist'>
	<li class='nav-item' role='presentation'>
	  <button class='nav-link active' id='question5-tab' data-bs-toggle='tab' data-bs-target='#question5-tab-pane' type='button' role='tab' aria-controls='question5-tab-pane' aria-selected='true'>Questions</button>
	</li>
	<li class='nav-item' role='presentation'>	  <button class='nav-link' id='answer1-tab' data-bs-toggle='tab' data-bs-target='#answer1-tab-pane' type='button' role='tab' aria-controls='answer1-tab-pane' aria-selected='false'>Answer 1</button>
	</li>
	<li class='nav-item' role='presentation'>	  <button class='nav-link' id='answer2-tab' data-bs-toggle='tab' data-bs-target='#answer2-tab-pane' type='button' role='tab' aria-controls='answer2-tab-pane' aria-selected='false'>Answer 2</button>
	</li>
	<li class='nav-item' role='presentation'>	  <button class='nav-link' id='answer3-tab' data-bs-toggle='tab' data-bs-target='#answer3-tab-pane' type='button' role='tab' aria-controls='answer3-tab-pane' aria-selected='false'>Answer 3</button>
	</li>
  </ul>
  <div class='tab-content' id='myTabContent'>
	<div class='tab-pane fade show active' id='question5-tab-pane' role='tabpanel' aria-labelledby='question5-tab' tabindex='0'>
		<py-repl std-out='output' std-err='errors'>
q_target = np.array([np.pi/2, 0])
dq_target = np.array([0, 0])
Kp = 10
Kv = 1
def controlCommand(state, param=param):
  # Question 1: Gravity Compensation Term (g(q))
  q = np.zeros(param.nbVarX)   # Implement here
  dq = np.zeros(param.nbVarX)  # Implement here
  ddq = np.zeros(param.nbVarX) # Implement here
  u = inverse_dynamics(q, dq, ddq, param=param)

  # Question 2: Gravity compensation and coriolis terms (c(q,dq) + g(q))
  q = np.zeros(param.nbVarX)   # Implement here
  dq = np.zeros(param.nbVarX)  # Implement here
  ddq = np.zeros(param.nbVarX) # Implement here
  u = inverse_dynamics(q, dq, ddq, param=param)

  # Question 3: Joint impedance control for reaching upright position
  q = np.zeros(param.nbVarX)   # Implement here
  dq = np.zeros(param.nbVarX)  # Implement here
  ddq = np.zeros(param.nbVarX) # Implement here
  u = inverse_dynamics(q, dq, ddq, param=param) # implement here

  return u

print(state)
		</py-repl>
	</div>
	<div class='tab-pane fade' id='answer1-tab-pane' role='tabpanel' aria-labelledby='answer1-tab' tabindex='0'>
		<py-repl std-out='output' std-err='errors'>
def controlCommand(state, param=param):
  # Question 1: Gravity Compensation Term (g(q))
  q = state[:param.nbVarX]
  dq = np.zeros(param.nbVarX)
  ddq = np.zeros(param.nbVarX)
  u = inverse_dynamics(q, dq, ddq, param=param)
  return u

print(state)
		</py-repl>
	</div>
	<div class='tab-pane fade' id='answer2-tab-pane' role='tabpanel' aria-labelledby='answer2-tab' tabindex='0'>
		<py-repl std-out='output' std-err='errors'>
def controlCommand(state, param=param):
  # Question 2: Gravity compensation and coriolis terms (c(q,dq) + g(q))
  q = state[:param.nbVarX]
  dq = state[param.nbVarX:]
  ddq = np.zeros(param.nbVarX)
  u = inverse_dynamics(q, dq, ddq, param=param)
  return u

print(state)
		</py-repl>
	</div>
	
	<div class='tab-pane fade' id='answer3-tab-pane' role='tabpanel' aria-labelledby='answer3-tab' tabindex='0'>
		<py-repl std-out='output' std-err='errors'>
q_target = np.array([np.pi/2, 0])
dq_target = np.array([0, 0])
Kp = 10
Kv = 1
def controlCommand(state, param=param):
  # Question 3: Joint impedance control for reaching upright position
  q = state[:param.nbVarX]
  dq = state[param.nbVarX:]
  ddq = Kp * (q_target - q) + Kv * (dq_target - dq)
  u = inverse_dynamics(q, dq, ddq, param=param)
  return u

print(state)
		</py-repl>
	</div>
  </div> 

<br><br>

<!-- <p id='repl-out' style='font-size: 70%; color: #777777;'>(press shift+enter or click on the green run button to run the code)</p>
<p id='repl-err' style='font-size: 70%; color: #880000;'></p> -->

</div> <!--sm-7-->

<div class='col-sm-4'>
	<div class='sticky-sm-top' style='padding: 2rem 1rem 1rem 1rem;'>
	<hr>
	<div class='row justify-content-between'>
	<div class='col-auto'><button class='btn btn-light btn-sm' disabled>Output</button></div>
	<div class='col-auto'><button class='btn btn-outline-secondary btn-sm float-right' onclick='clearMsgsOutput()'>Clear</button></div>
	</div>
	<div id='output'></div>
	<hr>
	<div class='row justify-content-between'>
	<div class='col-auto'><button class='btn btn-light btn-sm' disabled>Error</button></div>
	<div class='col-auto'><button class='btn btn-outline-secondary btn-sm float-right' onclick='clearMsgs()'>Clear</button></div>
	</div>
	<div id='errors'></div>
	<hr>
	<canvas id='canvas' style='width:100%;' width='900px' height='1000px'></canvas>
	</div>
</div> <!--sm-4-->

</div> <!--row-->

<py-script>
from pyodide.ffi import create_proxy
from js import Path2D, document, console
import numpy as np
import asyncio

def inverse_dynamics(q, dq, ddq, param):
	l = np.reshape(param.l, [1,param.nbVarX])
	m = np.reshape(param.l_m, [1,param.nbVarX])
	T = np.tril(np.ones([param.nbVarX, param.nbVarX]))
	Tm = np.multiply(np.triu(np.ones([m.shape[1], m.shape[1]])), np.repeat(m, m.shape[1],0)) 

	## Computation in matrix form of G,M, and C
	#G =-np.reshape(np.sum(Tm, 1), [param.nbVarX, 1]) * l.T * np.cos(T @ np.reshape(q, [param.nbVarX, 1])) * param.gravity
	#G = T.T @ G
	#M = (l.T * l) * np.cos(np.reshape(T @ q, [param.nbVarX, 1]) - T @ q) * (Tm**.5 @ ((Tm**.5).T))
	#M = T.T @ M @ T 
	#C = -(l.T * l) * np.sin(np.reshape(T @ q, [param.nbVarX, 1]) - T @ q) * (Tm**.5 @ ((Tm**.5).T))

	# Elementwise computation of G, M, and C
	G = np.zeros([param.nbVarX, 1])
	M = np.zeros([param.nbVarX, param.nbVarX]) 
	C =  np.zeros([param.nbVarX, param.nbVarX])
	for k in range(param.nbVarX):
		G[k,0] = -sum(m[0,k:]) * param.gravity * l[0,k] * np.cos(T[k,:] @ q)
		for i in range(param.nbVarX):
			S = sum(m[0,k:param.nbVarX] * np.heaviside(np.array(range(k, param.nbVarX)) - i, 1))
			M[k,i] = l[0,k] * l[0,i] * np.cos(T[k,:] @ q - T[i,:] @ q) * S
			C[k,i] = -l[0,k] * l[0,i] * np.sin(T[k,:] @ q - T[i,:] @ q) * S

	G = T.T @ G
	M = T.T @ M @ T
	param.inertia_matrix = M
	return M @ ddq - T.T @ C @ (T @ dq)**2 - T @ dq * param.damping - G[:,0] 


# Forward kinematics for end-effector (in robot coordinate system)
def fdyn(x,u, param):	
	l = np.reshape(param.l, [1,param.nbVarX])
	m = np.reshape(param.l_m, [1,param.nbVarX])
	T = np.tril(np.ones([param.nbVarX, param.nbVarX]))
	Tm = np.multiply(np.triu(np.ones([m.shape[1], m.shape[1]])), np.repeat(m, m.shape[1],0)) 

	## Computation in matrix form of G,M, and C
	#G =-np.reshape(np.sum(Tm, 1), [param.nbVarX, 1]) * l.T * np.cos(T @ np.reshape(x[0:param.nbVarX], [param.nbVarX, 1])) * param.gravity
	#G = T.T @ G
	#M = (l.T * l) * np.cos(np.reshape(T @ x[:param.nbVarX], [param.nbVarX, 1]) - T @ x[:param.nbVarX]) * (Tm**.5 @ ((Tm**.5).T))
	#M = T.T @ M @ T 
	#C = -(l.T * l) * np.sin(np.reshape(T @ x[:param.nbVarX], [param.nbVarX, 1]) - T @ x[:param.nbVarX]) * (Tm**.5 @ ((Tm**.5).T))

	# Elementwise computation of G, M, and C
	G = np.zeros([param.nbVarX, 1])
	M = np.zeros([param.nbVarX, param.nbVarX])
	C =  np.zeros([param.nbVarX, param.nbVarX])
	for k in range(param.nbVarX):
		G[k,0] = -sum(m[0,k:]) * param.gravity * l[0,k] * np.cos(T[k,:] @ x[:param.nbVarX])
		for i in range(param.nbVarX):
			S = sum(m[0,k:param.nbVarX] * np.heaviside(np.array(range(k, param.nbVarX)) - i, 1))
			M[k,i] = l[0,k] * l[0,i] * np.cos(T[k,:] @ x[:param.nbVarX] - T[i,:] @ x[:param.nbVarX]) * S
			C[k,i] = -l[0,k] * l[0,i] * np.sin(T[k,:] @ x[:param.nbVarX] - T[i,:] @ x[:param.nbVarX]) * S

	G = T.T @ G
	M = T.T @ M @ T
	param.inertia_matrix = M
	# Compute acceleration
	tau = np.reshape(u, [param.nbVarX, 1])
	inv_M = np.linalg.inv(M)
	ddq = inv_M @ (tau + G + T.T @ C @ (T @ np.reshape(x[param.nbVarX:],[param.nbVarX, 1]))**2 - \
		T @ np.reshape(x[param.nbVarX:],[param.nbVarX, 1])*param.damping)
	ddq = ddq[:, 0] 
	# compute the next step
	dq = np.clip(x[param.nbVarX:] + ddq * param.dt , -10., 10.)
	q  = x[:param.nbVarX] + x[param.nbVarX:] * param.dt + 0.5 * ddq * (param.dt**2) 
	xt = np.append(q, dq)
	return xt


# Forward kinematics for all joints (in robot coordinate system)
def fkin0(x, param): 
	L = np.tril(np.ones([param.nbVarX, param.nbVarX]))
	f = np.vstack([
		L @ np.diag(param.l) @ np.cos(L @ x),
		L @ np.diag(param.l) @ np.sin(L @ x)
	])
	f = np.hstack([np.zeros([2,1]), f])
	return f

## Parameters
# ===============================

param = lambda: None # Lazy way to define an empty class in python
param.nbVarX = 2 # State space dimension (x1,x2,x3)
param.l = [2, 2] # Robot links lengths
param.l_m = [1, 1] # Link masses
param.damping = 8. # Damping
param.gravity = 9.81 # Gravity
param.dt = 5e-2 # Time step length
param.noise_scale = 0.


#########################################################################################

# Mouse events
mouse0 = np.zeros(2)
mousedown = 0
hover_joint = -1
move_joint= -1
hover0 = np.zeros(2)

def onMouseMove(event):
	global mouse, mouse0, hover0, x
	offset = canvas.getBoundingClientRect()
	mouse0[0] = (event.clientX - offset.x) * canvas.width / canvas.clientWidth
	mouse0[1] = (event.clientY - offset.y) * canvas.height / canvas.clientHeight
	if move_joint >= 0:
		x[move_joint] -= 1E-2 * np.sum(hover0 - mouse0)
		hover0 = np.copy(mouse0)
		
def onTouchMove(event):
	global mouse, mouse0, hover0, x
	offset = event.target.getBoundingClientRect()
	mouse0[0] = (event.touches.item(0).clientX - offset.x) * canvas.width / canvas.clientWidth
	mouse0[1] = (event.touches.item(0).clientY - offset.y) * canvas.height / canvas.clientHeight
	if move_joint >= 0:
		x[move_joint] -= 1E-2 * np.sum(hover0 - mouse0)
		hover0 = np.copy(mouse0)
	
def onMouseDown(event):
	global mousedown, move_joint, hover0
	mousedown = 1
	if hover_joint >= 0:
		move_joint = hover_joint
		hover0 = np.copy(mouse0)

def onMouseUp(event):
	global mousedown, move_joint
	mousedown = 0
	move_joint = -1

def onWheel(event):
	global x
	if hover_joint >= 0:
		x[hover_joint] -= 0.2 * (event.deltaY/106)

document.addEventListener('mousemove', create_proxy(onMouseMove)) #for standard mouse
document.addEventListener('touchmove', create_proxy(onTouchMove)) #for mobile interfaces

document.addEventListener('mousedown', create_proxy(onMouseDown)) #for standard mouse
#document.addEventListener('pointerdown', create_proxy(onMouseDown)) #for mobile interfaces 
document.addEventListener('touchstart', create_proxy(onMouseDown)) #for mobile interfaces 

document.addEventListener('mouseup', create_proxy(onMouseUp)) #for standard mouse
#document.addEventListener('pointerup', create_proxy(onMouseUp)) #for mobile interfaces 
document.addEventListener('touchend', create_proxy(onMouseUp)) #for mobile interfaces 

document.addEventListener('wheel', create_proxy(onWheel)) #for standard mouse


#########################################################################################

canvas = document.getElementById('canvas')
ctx = canvas.getContext('2d')

def clear_screen():
	ctx.setTransform(1, 0, 0, 1, 0, 0)
	ctx.fillStyle = 'white'
	ctx.fillRect(0, 0, canvas.width, canvas.height)

	
def draw_ground():
	ctx.setTransform(1, 0, 0, -1, canvas.width*0.5, canvas.height*0.9)
	ctx.translate(0, -40)	
	ctx.lineCap = 'round'
	ctx.lineJoin = 'round'
	ctx.lineWidth = '5'
	ctx.strokeStyle = '#CCCCCC'
	ctx.beginPath()
	ctx.moveTo(-400, 0)
	ctx.lineTo(400, 0)
	ctx.stroke()


def draw_robot(x, color):
	global hover_joint
	ctx.setTransform(1, 0, 0, -1, canvas.width*0.5, canvas.height*0.5)
	
	f = fkin0(x, param)*100
	
	# Draw base
	ctx.translate(f[0,0], f[1,0])
	ctx.lineWidth = '4'
	ctx.strokeStyle = 'white'
	ctx.fillStyle = color
	ctx.beginPath()
	ctx.arc(0, 0, 40, 0, np.pi)
	ctx.rect(-40, 0, 80, -40)
	ctx.fill()
	ctx.strokeStyle = color
	for i in range(5):
		ctx.beginPath()
		ctx.moveTo(-30+i*15, -40)
		ctx.lineTo(-40+i*15, -60)
		ctx.stroke()
		
	# Draw links
	ctx.lineCap = 'round'
	ctx.lineJoin = 'round'
	for i in range(param.nbVarX):
		# Draw links outlines
		ctx.lineWidth = '46'
		ctx.strokeStyle = 'white'
		ctx.beginPath()
		ctx.lineTo(f[0,i], f[1,i])
		ctx.lineTo(f[0,i+1], f[1,i+1])
		ctx.stroke()
		# Draw links
		ctx.lineWidth = '38'
		ctx.strokeStyle = color
		ctx.beginPath()
		ctx.lineTo(f[0,i], f[1,i])
		ctx.lineTo(f[0,i+1], f[1,i+1])
		ctx.stroke()
		
	# Draw articulations
	obj = Path2D.new()
	obj.arc(0, 0, 12, 0, 2*np.pi)
	ctx.lineWidth = '4'
	ctx.strokeStyle = 'white'
	for i in range(param.nbVarX+1):
		ctx.translate(f[0,i], f[1,i])
		ctx.stroke(obj)
		if ctx.isPointInPath(obj, mouse0[0], mouse0[1]):
			hover_joint = i
		ctx.translate(-f[0,i], -f[1,i])


def draw_tip(f, color):
	ctx.setTransform(1, 0, 0, -1, canvas.width*0.5, canvas.height*0.9)
	# Draw object
	obj = Path2D.new()
	obj.arc(0, 0, 16, 0, 2*np.pi)
	ctx.translate(f[0], f[1])
	ctx.fillStyle = color
	ctx.fill(obj)


def controlCommand(state, param=param):
	u = inverse_dynamics(q=state[:param.nbVarX], dq=np.zeros(param.nbVarX), ddq=np.zeros(param.nbVarX), param=param) # Gravity compensation
	return u

#########################################################################################
	
def errorHandler(e):
	msg = 'Error: ' + str(e)
	console.error(msg)
	el = document.getElementById('errors')
	el.innerText = msg
	#el.textContent = msg
	
#########################################################################################
x = np.array([np.pi/3, np.pi/4]) # Initial robot state
x_target = np.array([np.pi/2, np.pi/5])
state = np.append(x, np.zeros(param.nbVarX))
u = np.zeros(param.nbVarX)

async def main():
	global hover_joint, x, state
	
	while True:
		try:
			u = controlCommand(state+np.random.randn(param.nbVarX*2)*param.noise_scale)
		except Exception as e:
			errorHandler(e)
			u = np.zeros(param.nbVarX)
			
		state = fdyn(state, u, param)	
		x = state[:param.nbVarX]
		# Reinit hovering variables
		hover_joint = -1
		
		# Rendering
		clear_screen()
	#	draw_ground()
		draw_robot(x, '#AAAAAA')
		#draw_tip(f, '#FF3399')

		await asyncio.sleep(0.01)

pyscript.run_until_complete(main())

</py-script>

</div> <!--container-->
</body>
</html>

