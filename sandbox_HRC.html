<!DOCTYPE html>

<html lang="en">
<head>

<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="RCFS" name="description"/>
<meta content="robotics codes, robotics tutorial, rcfs, robotics from scratch" name="keywords"/>
<meta content="Sylvain Calinon" name="author"/>
<title>RCFS</title>
<link href="static_images/favicon.ico" rel="icon" sizes="any"/>
<link href="static_images/favicon.svg" rel="icon" type="image/svg+xml"/>

<link href="css/bootstrap.min.css" rel="stylesheet"/>
<link href="css/bootstrap-icons-1.10.4/font/bootstrap-icons.css" rel="stylesheet"/>
<link href="css/permanent_marker.css" rel="stylesheet"/>
<link href="css/sidebars.css" rel="stylesheet"/>
<script src="js/jquery-3.6.4.min.js"></script>
<script src="js/bootstrap.bundle.min.js"></script>

<script defer="" src="https://pyscript.net/latest/pyscript.min.js"></script>
<!--<script defer src='js/pyscript.js'></script>-->
<py-config type="toml">

				packages = ['numpy']
			
</py-config>
<link href="https://pyscript.net/latest/pyscript.css" rel="stylesheet"/> <!-- pyscript.css is incompatible with hypothes.is/embed.js-->

<link href="css/main-template.css" rel="stylesheet"/>

<script src="js/glslrenderer.js" type="text/javascript"></script>
<script id="fragment-shader" type="shader">
uniform float u_smoothing_ratio; // Smoothing factor for softmax composition of SDF shapes 
uniform float u_disc_radius; // Disc radius
uniform float u_disc_pos_x; // Disc position x
uniform float u_disc_pos_y; // Disc position y
uniform float u_box_size_x; // Box width
uniform float u_box_size_y; // Box height
uniform float u_box_offset_x; // Box position x wrt the disc
uniform float u_box_offset_y; // Box position y wrt the disc
uniform float u_dist_target; // Distance to target

//uniform vec2 u_disc_pos; // Disc position
//uniform vec2 u_box_size; // Box width and height
//uniform vec2 u_box_offset; // Box position wrt the disc

vec3 sdgCircle(vec2 p, float r) 
{
    float l = length(p);
    return vec3(l-r, p/l);
}

// .x = f(p)
// .y = ∂f(p)/∂x
// .z = ∂f(p)/∂y
// .yz = ∇f(p) with ‖∇f(p)‖ = 1
vec3 sdgBox(vec2 p, vec2 b, float ra)
{
    vec2 w = abs(p)-(b-ra);
    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);
    
    float g = max(w.x,w.y);
	vec2  q = max(w,0.0);
    float l = length(q);
    
    return vec3(   (g>0.0)?l-ra: g-ra,
                s*((g>0.0)?q/l : ((w.x>w.y)?vec2(1,0):vec2(0,1))));
}

float opSmoothUnion(float d1, float d2, float k) {
    float h = clamp(0.5 + 0.5 * (d2-d1)/k, 0.0, 1.0);
    return mix(d2, d1, h) - k * h * (1.0 - h); 
}
//h = np.max([k - np.abs(d1-d2), 0])
//d = np.min([d1, d2]) - (h**2)*0.25/k
    

float sdCircle(vec2 p, float r) {
    return length(p) - r;
}

float sdBox(vec2 p, vec2 b, float r)
{
    vec2 d = abs(p) - (b*0.5 - r);
    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
	vec2 p = (-1.0*iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;
	
    // sdf(p) and gradient(sdf(p))
	//vec3 dg = sdgCircle(p, u_disc_radius);
    //float d = dg.x;
    
    vec2 u_disc_pos = vec2(u_disc_pos_x, u_disc_pos_y);
    vec2 u_box_size = vec2(u_box_size_x, u_box_size_y);
    vec2 u_box_offset = vec2(u_box_offset_x, u_box_offset_y);
    //float d = sdCircle(p-u_disc_pos, u_disc_radius);
    //float d = sdBox(p-u_disc_pos-u_box_offset, u_box_size, 0.0);
    float d = opSmoothUnion(sdCircle(p-u_disc_pos, u_disc_radius), sdBox(p-u_disc_pos-u_box_offset, u_box_size, 0.0), u_smoothing_ratio);

//    vec2 g = dg.yz;
    
    // central differences based gradient, for comparison
    vec2 g = vec2(dFdx(d), dFdy(d)) / (2.0 / iResolution.y);
    
	// coloring
    vec3 col = (d>u_dist_target) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);
    col *= 1.0 + vec3(0.5*g,0.0);
  //col = vec3(0.5+0.5*g,1.0);
    col *= 1.0 - 0.5*exp(-16.0*abs(d));
	col *= 0.9 + 0.1*cos(150.0*d);
	col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );
 
//    // interaction
//    if( iMouse.z>0.001 )
//    {
//        d = sdgCircle(m,ra).x;
//        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));
//        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));
//    }
	fragColor = vec4(col,1.0);
}
</script>

</head>

<body><nav aria-label="Light offcanvas navbar" class="navbar fixed-top" style="width: 50px;">
<div class="container-fluid">
<button aria-controls="offcanvasNavbarLight" class="navbar-toggler" data-bs-target="#offcanvasNavbarLight" data-bs-toggle="offcanvas" type="button">
<span class="navbar-toggler-icon" style="cursor: pointer;"></span>
</button>
<div aria-labelledby="offcanvasNavbarLightLabel" class="offcanvas offcanvas-start" id="offcanvasNavbarLight" style="width: 500px;" tabindex="-1">
<div class="offcanvas-header"><!--style='height: 50px;'-->
<a class="navbar-brand" href="index.html"><h4 class="offcanvas-title" id="offcanvasNavbarLightLabel"> <i class="bi bi-code-slash"></i> RCFS</h4></a>
<button aria-label="Close" class="btn-close" data-bs-dismiss="offcanvas" type="button"></button>
</div>
<div class="offcanvas-body">
<!--Menu goes here-->
<ul class="list-unstyled ps-0">
<li class="border-top my-1"></li>
<li class="mb-1">
<button aria-expanded="true" class="btn btn-toggle d-inline-flex align-items-center rounded border-0 collapsed" data-bs-target="#general-collapse" data-bs-toggle="collapse">General information</button>
<div class="collapse show" id="general-collapse">
<!--<li><a href='index.html' class='link-dark d-inline-flex text-decoration-none rounded'>Home</a></li>-->
<ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small">
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="about.html">
<div class="p-1 mb-0">About</div></a></li>
</ul>
</div>
</li>
<li class="border-top my-1"></li>
<li class="mb-1">
<button aria-expanded="false" class="btn btn-toggle d-inline-flex align-items-center rounded border-0 collapsed" data-bs-target="#sandboxes2d-collapse" data-bs-toggle="collapse">2D sandboxes</button>
<div class="collapse" id="sandboxes2d-collapse">
<ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small">
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="sandbox_FK.html">
<div class="p-1 mb-0">Forward kinematics (FK)</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="sandbox_IK.html">
<div class="p-1 mb-0">Inverse kinematics (IK)</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="sandbox_bimanual.html">
<div class="p-1 mb-0">Bimanual robot</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="sandbox_humanoid.html">
<div class="p-1 mb-0">Humanoid robot (CoM and coordination matrix)</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="sandbox_iLQR.html">
<div class="p-1 mb-0">Iterative linear quadratic regulator (iLQR)</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="sandbox_iLQR_car.html">
<div class="p-1 mb-0">iLQR for car</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="sandbox_iLQR_bicopter.html">
<div class="p-1 mb-0">iLQR for bicopter</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="sandbox_impedance.html">
<div class="p-1 mb-0">Impedance control</div></a></li>
</ul>
</div>
</li>
<li class="border-top my-1"></li>
<li class="mb-1">
<button aria-expanded="false" class="btn btn-toggle d-inline-flex align-items-center rounded border-0 collapsed" data-bs-target="#sandboxes3d-collapse" data-bs-toggle="collapse">3D sandboxes</button>
<div class="collapse" id="sandboxes3d-collapse">
<ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small">
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="sandbox3d_IK.html">
<div class="p-1 mb-0">Inverse kinematics (IK)</div></a></li>
</ul>
</div>
</li>
<li class="border-top my-1"></li>
<li class="mb-1">
<button aria-expanded="false" class="btn btn-toggle d-inline-flex align-items-center rounded border-0 collapsed" data-bs-target="#exercises-collapse" data-bs-toggle="collapse">Coding exercises</button>
<div class="collapse" id="exercises-collapse">
<ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small">
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise01.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">01</div>
<div class="p-1 mb-0">Linear algebra in Python</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise02.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">02</div>
<div class="p-1 mb-0">Movement primitives and Newton's method</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise03.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">03</div>
<div class="p-1 mb-0">Gaussian Distributions</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise04a.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">4a</div>
<div class="p-1 mb-0">Forward kinematics</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise04b.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">4b</div>
<div class="p-1 mb-0">Inverse kinematics and nullspace control</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise05a.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">5a</div>
<div class="p-1 mb-0">Forward dynamics</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise05b.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">5b</div>
<div class="p-1 mb-0">Inverse dynamics and impedance control</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise06a.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">6a</div>
<div class="p-1 mb-0">Planning with linear quadratic regulator</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise06b.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">6b</div>
<div class="p-1 mb-0">Planning in joint space with LQR</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise07.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">07</div>
<div class="p-1 mb-0">Iterative linear quadratic regulator (iLQR)</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise08.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">08</div>
<div class="p-1 mb-0">Exploration with ergodic control</div></a></li>
<li><a class="link-dark d-inline-flex text-decoration-none rounded" href="exercise09.html">
<div class="p-1 mb-0 bg-dark text-white font-monospace">09</div>
<div class="p-1 mb-0">Orientation with Riemannian manifold</div></a></li>
</ul>
</div>
</li>
<li class="border-top my-1"></li>
<li class="mb-1">
<button aria-expanded="false" class="btn btn-toggle d-inline-flex align-items-center rounded border-0 collapsed" data-bs-target="#doc-collapse" data-bs-toggle="collapse">Online course</button>
<div class="collapse" id="doc-collapse">
<ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small" id="menu_container">
<li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="toc.html" style="font-weight:bold;">Table of contents</a></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="S1.html" style="font-weight:bold;">1 Introduction</a></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="S2.html" style="font-weight:bold;">2 Newton’s method for minimization</a><div><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S2.html#sec:GaussNewton"><span class="p-1 mb-0">2.1 Gauss–Newton algorithm</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S2.html#sec:LS"><span class="p-1 mb-0">2.2 Least squares</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S2.html#sec:LSconstraints"><span class="p-1 mb-0">2.3 Least squares with constraints</span></a></li></ul></div></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="S3.html" style="font-weight:bold;">3 Forward kinematics (FK) for a planar robot manipulator</a></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="S4.html" style="font-weight:bold;">4 Inverse kinematics (IK) for a planar robot manipulator</a><div><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S4.html#sec:IKnum"><span class="p-1 mb-0">4.1 Numerical estimation of the Jacobian</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S4.html#sec:IK_nullspace"><span class="p-1 mb-0">4.2 Inverse kinematics (IK) with task prioritization</span></a></li></ul></div></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="S5.html" style="font-weight:bold;">5 Encoding with basis functions</a><div><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S5.html#SS1"><span class="p-1 mb-0">5.1 Univariate trajectories</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S5.html#SS2"><span class="p-1 mb-0">5.2 Multivariate trajectories</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S5.html#SS3"><span class="p-1 mb-0">5.3 Multidimensional inputs</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S5.html#SS4"><span class="p-1 mb-0">5.4 Derivatives</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S5.html#SS5"><span class="p-1 mb-0">5.5 Concatenated basis functions</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S5.html#SS6"><span class="p-1 mb-0">5.6 Batch computation of basis functions coefficients</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S5.html#SS7"><span class="p-1 mb-0">5.7 Recursive computation of basis functions coefficients</span></a></li></ul></div></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="S6.html" style="font-weight:bold;">6 Linear quadratic tracking (LQT)</a><div><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S6.html#SS1"><span class="p-1 mb-0">6.1 LQT with smoothness cost</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S6.html#SS2"><span class="p-1 mb-0">6.2 LQT with control primitives</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S6.html#sec:LQRrecursive"><span class="p-1 mb-0">6.3 LQR with a recursive formulation</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S6.html#sec:augmState"><span class="p-1 mb-0">6.4 LQT with a recursive formulation and an augmented state space</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S6.html#sec:LQRLS"><span class="p-1 mb-0">6.5 Least squares formulation of recursive LQR</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S6.html#sec:DMPLQT"><span class="p-1 mb-0">6.6 Dynamical movement primitives (DMP) reformulated as LQT with control primitives</span></a></li></ul></div></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html" style="font-weight:bold;">7 iLQR optimization</a><div><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html#sec:iLQRbatch"><span class="p-1 mb-0">7.1 Batch formulation of iLQR</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html#sec:iLQRrecursive"><span class="p-1 mb-0">7.2 Recursive formulation of iLQR</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html#sec:iLQRLS"><span class="p-1 mb-0">7.3 Least squares formulation of recursive iLQR</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html#SS4"><span class="p-1 mb-0">7.4 Updates by considering step sizes</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html#SS5"><span class="p-1 mb-0">7.5 iLQR with quadratic cost on f(x_{t})</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html#SS6"><span class="p-1 mb-0">7.6 iLQR with control primitives</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html#SS7"><span class="p-1 mb-0">7.7 iLQR for spacetime optimization</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html#SS8"><span class="p-1 mb-0">7.8 iLQR with offdiagonal elements in the precision matrix</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html#SS9"><span class="p-1 mb-0">7.9 Car steering</span></a></li><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S7.html#SS10"><span class="p-1 mb-0">7.10 Bicopter</span></a></li></ul></div></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="S8.html" style="font-weight:bold;">8 Forward dynamics (FD) for a planar robot manipulator</a><div><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="link-dark d-inline-flex text-decoration-none rounded" href="S8.html#SS1"><span class="p-1 mb-0">8.1 Robot manipulator with dynamics equation</span></a></li></ul></div></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="bib.html" style="font-weight:bold;">References</a></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="A1.html" style="font-weight:bold;">A System dynamics at trajectory level</a></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="A2.html" style="font-weight:bold;">B Derivation of motion equation for a planar robot</a></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="A3.html" style="font-weight:bold;">C Linear systems used in the bimanual tennis serve example</a></li><li class="mb-1 generated-menu-item"><a class="link-dark d-inline-flex text-decoration-none rounded" href="A4.html" style="font-weight:bold;">D Equivalence between LQT and LQR with augmented state space</a></li></ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</nav>
<div class="container-fluid">
<div class="row">
<div class="col-sm-1"></div>
<div class="col-sm-7">
<br/><br/>
<script>
function clearMsgs() {
  const el = document.getElementById('repl-err');
  el.innerText = '';
  //console.log('event!');
}
</script>
<ul class="nav nav-tabs" id="myTab" role="tablist">
<li class="nav-item" role="presentation"> <button aria-controls="HRC-tab-pane" aria-selected="true" class="nav-link" data-bs-target="#HRC-tab-pane" data-bs-toggle="tab" id="HRC-tab" role="tab" type="button">Human-robot collaboration</button>
</li>
</ul>
<div class="tab-content" id="myTabContent">
<div aria-labelledby="HRC-tab" class="tab-pane fade show active" id="HRC-tab-pane" role="tabpanel" tabindex="0">
<py-repl std-err="errors" std-out="output">
x = np.array([-np.pi/4, -np.pi/2, np.pi/4, 0, 0, 0]) # Initial robot pose

dist_target = 20.0 # Targeted distance to maintain
f_target = np.array([-200.0, -400.0, 0]) # SDF location in task space 
sdf_disc_radius = 80.0 # Disc radius
sdf_box_size = np.array([160.0, 100.0]) # Box width and height
sdf_box_offset = np.array([60.0, -60.0]) # Box position wrt the disc
sdf_smoothing_ratio = 0.1 # Smoothing factor for softmax composition of SDF shapes 

KP = np.diag([4E-2, 0E-2, 0E3]) # Task space stiffness (position and orientation)
KP0 = np.copy(KP)
KV = np.diag([1E-3, 1E-3, 1E1]) # Task space damping (position and orientation)

def controlCommand(x, param):
    global KP
    ug = inverse_dynamics(x, np.zeros(param.nbVarX), param) # Torques for gravity and Coriolis force compensation
    f = fkin(x[:param.nbVarX], param) # Forward kinematics
    J = Jkin(x[:param.nbVarX], param) # Corresponding Jacobian matrix
    df = J @ x[param.nbVarX:] # End-effector velocity
    dist, grad = sdf(f) # Signed distance function and corresponding gradient
    R = np.array([[grad[0], -grad[1]], [grad[1], grad[0]]]) # Local coordinate system (rotation matrix)
    KP[:2,:2] = R @ KP0[:2,:2] @ R.T # Adapt stiffness to local coordinate system
    grad[:2] = grad[:2] * (dist - dist_target) # Residual vector
    u = J.T @ (KP @ grad - KV @ df) + ug # Impedance controller in task space
    return u
</py-repl>
</div>
</div>
<p id="repl-out" style="font-size: 70%; color: #777777;">(click on the green run button to run the code; the robot can be perturbed using the mouse)</p>
<p id="repl-err" style="font-size: 70%; color: #880000;"></p>

</div> <!--sm-7-->
<div class="col-sm-4">
<div class="sticky-sm-top">
<div style='position: relative; width: 600px; height: 600px;'>
    <canvas id='canvas_glsl' width='600' height='600' style='position: absolute; top: 0; left: 0;'></canvas>
    <canvas id='canvas' width='600' height='600' style='position: absolute; top: 0; left: 0;'></canvas>
</div>
<p id="framerate"></p>
</div>
</div> <!--sm-4-->
</div> <!--row-->
<py-script>
from pyodide.ffi import create_proxy, to_js
from js import document, Path2D, GlslRenderer #console 
import numpy as np
import asyncio

# SDF for circle
def sdf_circle(f, p, r):
	return np.linalg.norm(p-f) - r 

# SDF for box
def sdf_box(f, p, sz):
    dtmp = np.abs(f-p) - sz * 0.5
    d = np.linalg.norm(np.maximum(dtmp, [0, 0])) + np.min([np.max([dtmp[0], dtmp[1]]), 0])
    return d

def smooth_union(d1, d2, k):
    '''
    Smooth union (see https://www.shadertoy.com/view/lt3BW2)
    Note: will only be correct on the outside, see https://iquilezles.org/articles/interiordistance/
    '''
    #h = np.max([k - np.abs(d1-d2), 0])
    #d = np.min([d1, d2]) - (h**2)*0.25/k
    h = np.clip(0.5 + 0.5 * (d2-d1)/k, 0.0, 1.0)
    d = d2 * (1.0-h) + d1 * h - k * h * (1.0-h)
    return d

#float h = clamp(0.5 + 0.5 * (d2-d1)/k, 0.0, 1.0);
#return mix(d2, d1, h) - k * h * (1.0 - h); 
    
def compute_distance(f):
    p1 = f_target[:2]
    p2 = f_target[:2] + sdf_box_offset
    dist = np.zeros(f.shape[1])
    for t in range(f.shape[1]):
        d1 = sdf_circle(f[:2,t], p1, sdf_disc_radius)
        d2 = sdf_box(f[:2,t], p2, sdf_box_size)
        dist[t] = smooth_union(d1, d2, sdf_smoothing_ratio) # Smoothing union with softmax composition of SDF shapes 
    return dist

# SDF
def sdf(f):
    '''
    Compound shape 1
    '''
    dist = compute_distance(f[:,None])
    #Numerical gradient estimate
    eps = 1E-6
    X = np.tile(f[:2].reshape((-1,1)), [1,2])
    F1 = compute_distance(X)
    F2 = compute_distance(X+np.eye(2)*eps)
    grad = np.zeros(3) 
    grad[:2] = -(F2-F1) / eps
    grad[:2] = grad[:2] / (np.linalg.norm(grad[:2]) + 1E-8) # Position residual
    f_target[2] = np.arctan2(grad[1], grad[0])
    grad[2] = logmap(f_target[2], f[2]) # Orientation residual
    return dist, grad

# Logarithmic map for S^1 manifold
def logmap(f, f0):
	diff = np.imag(np.log(np.exp(f0*1j).conj().T * np.exp(f*1j).T)).conj() # Orientation residual
	return diff

# Forward kinematics for end-effector (in robot coordinate system)
def fkin(x, param):
	L = np.tril(np.ones([param.nbVarX, param.nbVarX]))
	f = np.stack([
		param.l @ np.cos(L @ x),
		param.l @ np.sin(L @ x),
		np.mod(np.sum(x,0)+np.pi, 2*np.pi) - np.pi
	])
	return f

# Forward kinematics for all joints (in robot coordinate system)
def fkin0(x, param):
	L = np.tril(np.ones([param.nbVarX, param.nbVarX]))
	f = np.vstack([
		L @ np.diag(param.l) @ np.cos(L @ x),
		L @ np.diag(param.l) @ np.sin(L @ x)
	])
	f = np.hstack([np.zeros([2,1]), f])
	return f

# Jacobian with analytical computation (for single time step)
def Jkin(x, param):
	L = np.tril(np.ones([param.nbVarX, param.nbVarX]))
	J = np.vstack([
		-np.sin(L @ x).T @ np.diag(param.l) @ L,
		 np.cos(L @ x).T @ np.diag(param.l) @ L,
		 np.ones([1,param.nbVarX])
	])
	return J

def computeGCML(x, param):
	# Auxiliary matrices
	l = np.reshape(param.l/param.drawScale, [1, param.nbVarX])
	L = np.tril(np.ones([param.nbVarX, param.nbVarX]))
	m = np.reshape(param.m, [1, param.nbVarX])
	Lm = np.triu(np.ones([m.shape[1], m.shape[1]])) * np.repeat(m, m.shape[1],0)

#	# Elementwise computation of G, C, and M
#    G = np.zeros(param.nbVarX)
#    M = np.zeros([param.nbVarX, param.nbVarX])
#    C =  np.zeros([param.nbVarX, param.nbVarX])
#    for k in range(param.nbVarX):
#        G[k] = -sum(m[0,k:]) * param.gravity * l[0,k] * np.cos(L[k,:] @ x[:param.nbVarX])
#        for i in range(param.nbVarX):
#            S = sum(m[0,k:param.nbVarX] * np.heaviside(np.array(range(k, param.nbVarX)) - i, 1))
#            M[k,i] = l[0,k] * l[0,i] * np.cos(L[k,:] @ x[:param.nbVarX] - L[i,:] @ x[:param.nbVarX]) * S
#            C[k,i] = -l[0,k] * l[0,i] * np.sin(L[k,:] @ x[:param.nbVarX] - L[i,:] @ x[:param.nbVarX]) * S
	
	# Computation in matrix form of G, C, and M
	G = -np.sum(Lm,1) * param.l * np.cos(L @ x[:param.nbVarX]) * param.gravity
	C = -(l.T * l) * np.sin(np.reshape(L @ x[:param.nbVarX], [param.nbVarX,1]) - L @ x[:param.nbVarX]) * (Lm**.5 @ ((Lm**.5).T))
	M = (l.T * l) * np.cos(np.reshape(L @ x[:param.nbVarX], [param.nbVarX,1]) - L @ x[:param.nbVarX]) * (Lm**.5 @ ((Lm**.5).T))

	G = L.T @ G
	C = L.T @ C
	M = L.T @ M @ L
	
	return G,C,M,L

def inverse_dynamics(x, ddx, param):
	G,C,M,L = computeGCML(x, param)
#	u = M @ ddx - G - C @ (L @ x[param.nbVarX:])**2 + x[param.nbVarX:] * param.damping # With gravity, Coriolis and viscous friction compensation models
	u = M @ ddx - G - C @ (L @ x[param.nbVarX:])**2 # With gravity and Coriolis models 
	return u

def fdyn(x, u, param):
	G,C,M,L = computeGCML(x, param)
	ddx = np.linalg.inv(M) @ (u + G + C @ (L @ x[param.nbVarX:])**2 - x[param.nbVarX:] * param.damping)
	return ddx

def controlCommand(x, param):
	u = inverse_dynamics(x, np.zeros(param.nbVarX), param) # Torques for gravity and Coriolis force compensation
#	u = np.zeros(param.nbVarX)
	return u

def externalPerturbation(x, param):
	u = np.zeros(param.nbVarX)
	if move_joint >= 0:
		f = fkin(x[:move_joint+1], param2)
		J = Jkin(x[:move_joint+1], param2)
#		pinvJ = np.linalg.inv(J.T @ J + np.eye(param2.nbVarX) * 1E-4) @ J.T # Damped pseudoinverse
		u[:move_joint+1] = J[:2,:].T @ (mouse - f[:2]) * 5E-3 # Torque commands
#		u[:move_joint+1] = pinvJ @ (mouse - f) * 1E1 # Torque commands
#		u[:move_joint] = J[:,:move_joint].T @ (mouse - f) * 1E-1 # Torque commands
	return u
	
## Parameters
# ===============================
param = lambda: None # Lazy way to define an empty class in python
param.nbVarX = 3 # State space dimension
param.drawScale = 200.0
param.l = np.ones(param.nbVarX) * param.drawScale # Robot links lengths
param.m = np.ones(param.nbVarX) # Robot links masses
param.dt = 1E-2 # Time step length
param.damping = 20.0 # Viscous friction
param.gravity = 9.81 # Gravity

param2 = lambda: None # Lazy way to define an empty class in python

#########################################################################################

# Mouse events
mouse0 = np.zeros(2)
mouse = np.zeros(2)
mousedown = 0
hover_joint = -1
move_joint= -1

def onMouseMove(event):
	global mouse, mouse0
	offset = canvas.getBoundingClientRect()
	mouse0[0] = (event.clientX - offset.x) * canvas.width / canvas.clientWidth
	mouse0[1] = (event.clientY - offset.y) * canvas.height / canvas.clientHeight
	mouse[0] = (mouse0[0] - canvas.width * 0.5)
	mouse[1] = -(mouse0[1] - canvas.height * 0.1)

def onTouchMove(event):
	global mouse, mouse0
	offset = event.target.getBoundingClientRect()
	mouse0[0] = (event.touches.item(0).clientX - offset.x) * canvas.width / canvas.clientWidth
	mouse0[1] = (event.touches.item(0).clientY - offset.y) * canvas.height / canvas.clientHeight
	mouse[0] = (mouse0[0] - canvas.width * 0.5)
	mouse[1] = -(mouse0[1] - canvas.height * 0.1)

def onMouseDown(event):
	global mousedown, move_joint
	mousedown = 1
	if hover_joint >= 0:
		f0 = fkin0(x[:param.nbVarX], param)
		param2.l = np.append(param.l[:hover_joint], np.linalg.norm(f0[:,hover_joint] - mouse))
		param2.nbVarX = hover_joint+1
		move_joint = hover_joint

def onMouseUp(event):
	global mousedown, move_joint
	mousedown = 0
	move_joint = -1

def onWheel(event):
	global x
	if hover_joint >= 0:
		x[hover_joint] -= 0.2 * (event.deltaY/106)

document.addEventListener('mousemove', create_proxy(onMouseMove)) #for standard mouse
document.addEventListener('touchmove', create_proxy(onTouchMove)) #for mobile interfaces

document.addEventListener('mousedown', create_proxy(onMouseDown)) #for standard mouse
#document.addEventListener('pointerdown', create_proxy(onMouseDown)) #for mobile interfaces
document.addEventListener('touchstart', create_proxy(onMouseDown)) #for mobile interfaces

document.addEventListener('mouseup', create_proxy(onMouseUp)) #for standard mouse
#document.addEventListener('pointerup', create_proxy(onMouseUp)) #for mobile interfaces
document.addEventListener('touchend', create_proxy(onMouseUp)) #for mobile interfaces

document.addEventListener('wheel', create_proxy(onWheel)) #for standard mouse

#########################################################################################

canvas = document.getElementById('canvas')
ctx = canvas.getContext('2d')

def clear_screen():
	ctx.setTransform(1, 0, 0, 1, 0, 0)
	ctx.clearRect(0, 0, canvas.width, canvas.height);

def draw_robot(x, color):
	global hover_joint
	ctx.setTransform(1, 0, 0, -1, canvas.width*0.5, canvas.height*0.1)

	f = fkin0(x, param) 

	# Draw base
	ctx.translate(f[0,0], f[1,0])
	ctx.lineWidth = '4'
	ctx.strokeStyle = 'white'
	ctx.fillStyle = color
	ctx.beginPath()
	ctx.arc(0, 0, 40, 0, np.pi)
	ctx.rect(-40, 0, 80, -40)
	ctx.fill()
	ctx.strokeStyle = color
	for i in range(5):
		ctx.beginPath()
		ctx.moveTo(-30+i*15, -40)
		ctx.lineTo(-40+i*15, -60)
		ctx.stroke()

	# Draw links and articulations
	obj_articulation = Path2D.new()
	obj_articulation.arc(0, 0, 12, 0, 2*np.pi)
	ctx.lineCap = 'round'
	ctx.lineJoin = 'round'
	for i in range(param.nbVarX):
		if i < param.nbVarX:
			# Draw links outlines
			ctx.lineWidth = '46'
			ctx.strokeStyle = 'white'
			ctx.beginPath()
			ctx.lineTo(f[0,i], f[1,i])
			ctx.lineTo(f[0,i+1], f[1,i+1])
			ctx.stroke()
			# Draw links
			obj = Path2D.new()
			obj.lineTo(f[0,i], f[1,i])
			obj.lineTo(f[0,i+1], f[1,i+1])
			ctx.lineWidth = '38'
			ctx.strokeStyle = color
			ctx.stroke(obj)
			if ctx.isPointInStroke(obj, mouse0[0], mouse0[1]) and move_joint < 0:
				#console.log(i)
				hover_joint = i

		# Draw articulations
		ctx.lineWidth = '4'
		ctx.strokeStyle = 'white'
		ctx.translate(f[0,i], f[1,i])
		ctx.stroke(obj_articulation)
		ctx.translate(-f[0,i], -f[1,i])

def draw_selected_point(f, color):
	ctx.setTransform(1, 0, 0, -1, canvas.width*0.5, canvas.height*0.1)
	# Draw object
	obj = Path2D.new()
	obj.arc(0, 0, 6, 0, 2*np.pi)
	ctx.translate(f[0], f[1])
	ctx.fillStyle = color
	ctx.fill(obj)

def draw_disc(f, r, color):
	ctx.setTransform(1, 0, 0, -1, canvas.width*0.5, canvas.height*0.1)
	ctx.translate(f[0], f[1])
	obj = Path2D.new()
	obj.arc(0, 0, r, 0, 2.0*np.pi)
	ctx.fillStyle = color
	ctx.fill(obj)

def draw_box(f, sz, color):
	ctx.setTransform(1, 0, 0, -1, canvas.width*0.5, canvas.height*0.1)
	ctx.translate(f[0], f[1])
	ctx.fillStyle = color
	obj = Path2D.new()
	obj.rect(-sz[0]/2, -sz[1]/2, sz[0], sz[1])
	ctx.fill(obj)
	
def draw_Gaussian(Mu, Sigma, color, color2):
	ctx.setTransform(1, 0, 0, -1, canvas.width*0.5, canvas.height*0.1) 
	ctx.translate(Mu[0], Mu[1])
	s, U = np.linalg.eig(Sigma)
	al = np.linspace(-np.pi, np.pi, 50)
	D = np.diag(s) * 100
	R = np.real(U @ np.sqrt(D))
	msh = R @ np.array([np.cos(al),np.sin(al)])
	# Draw Gaussian
	obj = Path2D.new()
	obj.moveTo(msh[0,0], msh[1,0])
	for i in range(msh.shape[1]-1):
		obj.lineTo(msh[0,i+1], msh[1,i+1])
	obj.closePath()
	ctx.strokeStyle = color2
	ctx.stroke(obj)
	ctx.fillStyle = color
	ctx.fill(obj)
	obj = Path2D.new()
	obj.arc(0, 0, 3.0, 0, 2.0*np.pi)
	ctx.fillStyle = color2 
	ctx.fill(obj)

#########################################################################################

def errorHandler(e):
	msg = 'Error: ' + str(e)
	console.error(msg)
	el = document.getElementById('repl-err')
	el.innerText = msg
	#el.textContent = msg

def setAllUniforms():
	renderer.setUniform('u_smoothing_ratio', sdf_smoothing_ratio)
	renderer.setUniform('u_disc_radius', sdf_disc_radius*2.0/canvas.width)
	renderer.setUniform('u_disc_pos_x', f_target[0]*2.0/canvas.width)
	renderer.setUniform('u_disc_pos_y', f_target[1]*2.0/canvas.width+0.8)
	renderer.setUniform('u_box_size_x', sdf_box_size[0]*2.0/canvas.width)
	renderer.setUniform('u_box_size_y', sdf_box_size[1]*2.0/canvas.width)
	renderer.setUniform('u_box_offset_x', sdf_box_offset[0]*2.0/canvas.width)
	renderer.setUniform('u_box_offset_y', sdf_box_offset[1]*2.0/canvas.width)
	renderer.setUniform('u_dist_target', dist_target*2.0/canvas.width)

#########################################################################################
#x = np.zeros(2*param.nbVarX) # Initial robot state (position and velocity)
x = np.array([-np.pi/3.7, -np.pi/2.2, np.pi/4.1, 0, 0, 0]) # Initial robot state (position and velocity)
x_target = np.array([-np.pi/4, -np.pi/2, np.pi/4, 0, 0, 0]) # Target in joint space
KP = np.diag([4E-2, 4E-2, 4E2]) # Joint space stiffness matrix
KV = np.diag([1E1, 1E1, 1E1]) # Joint space damping matrix

dist_target = 0.1 # Targeted distance to maintain
f_target = np.array([-200.0, -400.0, 0]) # SDF location in task space 

sdf_smoothing_ratio = 0.1 # Smoothing factor for softmax composition of SDF shapes 
sdf_disc_radius = 80.0 # Disc radius
sdf_box_size = np.array([160.0, 100.0]) # Box width and height
sdf_box_offset = np.array([60.0, -60.0]) # Box position wrt the disc

# GLSL rendering
renderer = GlslRenderer.new(document.querySelector("#canvas_glsl"))
setAllUniforms()
#renderer.setUniform('u_disc_pos', f_target[0], f_target[1])
#renderer.setUniform('u_box_size', sdf_box_size[0], sdf_box_size[1])
#renderer.setUniform('u_box_offset', sdf_box_offset[0], sdf_box_offset[1])
renderer.setup(
    document.querySelector("#fragment-shader").text,
)
renderer.setFramerateTarget(document.querySelector("#framerate"))

async def main():
	global hover_joint, x

	while True:
		try:
			u = controlCommand(x, param) + externalPerturbation(x, param) # Torque commands
			ddx = fdyn(x, u, param) # Compute accelerations
			x += np.append(x[param.nbVarX:] + 0.5 * ddx * param.dt, ddx) * param.dt # Update state
		except Exception as e:
			errorHandler(e)
			u = np.zeros(param.nbVarX)
		
		# Reinit hovering variables
		hover_joint = -1
		
		# Rendering
		clear_screen()
		
		draw_disc(f_target[:2], sdf_disc_radius, '#33FF99')
		draw_box(f_target[:2]+sdf_box_offset, sdf_box_size, '#33FF99')
		
		draw_robot(x[:param.nbVarX], '#AAAAAA')
		if move_joint >= 0:
			f = fkin(x[:move_joint+1], param2)
			draw_selected_point(f, '#777777')
		
		f = fkin(x[:param.nbVarX], param)
		draw_Gaussian(f, np.linalg.inv(KP[:2,:2] * 1E2 + np.eye(2)*1E-2), '#FF3399', '#DD1177') # Draw stiffness ellipsoid
		
		#renderer.setUniform('u_radius', f[0]/canvas.width)
		setAllUniforms()

		await asyncio.sleep(0.00001)

pyscript.run_until_complete(main())
</py-script>
</div> <!--container-->

</body>
</html>
