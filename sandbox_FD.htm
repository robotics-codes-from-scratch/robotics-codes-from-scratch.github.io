<!doctype html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='description' content='Robotics codes from scratch (RCFS) is a collection of source codes to study and test learning and optimization problems in robotics through simple 2D examples.'>
<meta name='keywords' content='robotics codes, robotics tutorial, rcfs, robotics from scratch'>
<meta name='author' content='Sylvain Calinon'>
<link rel='icon' href='images/favicon.ico' sizes='any'>
<link rel='icon' href='images/favicon.svg' type='image/svg+xml'>

<title>Robotics codes from scratch</title>
<link rel='canonical' href='https://robotics-codes-from-scratch.github.io/'>

<link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css' integrity='sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi' crossorigin='anonymous'>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.9.1/font/bootstrap-icons.css">

<link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Permanent+Marker|Raleway'>


<script defer src='https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js' integrity='sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3' crossorigin='anonymous'></script>


<!--<script src='https://cdn.jsdelivr.net/npm/chart.js'></script>-->

<!-- <script defer src='https://hypothes.is/embed.js' async></script> --> <!-- pyscript.css is incompatible with hypothes.is/embed.js-->



<script defer src='https://pyscript.net/latest/pyscript.min.js'></script>
	
<py-config type='toml'>
	packages = ['numpy']
</py-config>
		
<link rel='stylesheet' href='https://pyscript.net/latest/pyscript.css'> <!-- pyscript.css is incompatible with hypothes.is/embed.js-->
	
<link rel='stylesheet' href='css/sidebars.css'> <!-- main navigation menu -->
<link rel='stylesheet' href='css/main-template.css'>

</head>

<body>

<nav class='navbar fixed-top' aria-label='Light offcanvas navbar' style='width: 50px;'>
<div class='container-fluid'>
<button class='navbar-toggler' type='button' data-bs-toggle='offcanvas' data-bs-target='#offcanvasNavbarLight' aria-controls='offcanvasNavbarLight'> 
<span class='navbar-toggler-icon' style='cursor: pointer;'></span>
</button>
<!--<a class='navbar-brand' href='#'><h4>Movement primitives</h4></a>-->    
  
  <div class='offcanvas offcanvas-start' tabindex='-1' id='offcanvasNavbarLight' aria-labelledby='offcanvasNavbarLightLabel' style='width: 500px;'>
    <div class='offcanvas-header'><!--style='height: 50px;'-->
      <a class='navbar-brand' href='index.htm'><h4 class='offcanvas-title' id='offcanvasNavbarLightLabel'><i class='bi bi-robot'></i> <i class='bi bi-code-slash'></i> RCFS</h4></a>
      <button type='button' class='btn-close' data-bs-dismiss='offcanvas' aria-label='Close'></button>
    </div>
    
    <div class='offcanvas-body'>
	<ul class='list-unstyled ps-0'>
	  
	  <!--<li><a href='index.htm' class='link-dark d-inline-flex text-decoration-none rounded'>Home</a></li>-->
	  
	  <li class='border-top my-1'></li>
	  
	  <li class='mb-1'>
		<button class='btn btn-toggle d-inline-flex align-items-center rounded border-0 collapsed' data-bs-toggle='collapse' data-bs-target='#sandboxes-collapse' aria-expanded='true'>Sandboxes</button>
		<div class='collapse show' id='sandboxes-collapse'>
		  <ul class='btn-toggle-nav list-unstyled fw-normal pb-1 small'>
		  	<li><a href='sandbox_FK.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
			<div class='p-1 mb-0'>Forward kinematics (FK)</div></a></li>
		    <li><a href='sandbox_IK.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
			<div class='p-1 mb-0'>Inverse kinematics (IK)</div></a></li>
			<li><a href='sandbox_bimanual.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
			<div class='p-1 mb-0'>Bimanual robot</div></a></li>
			<li><a href='sandbox_humanoid.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
			<div class='p-1 mb-0'>Humanoid robot (CoM and coordination matrix)</div></a></li>
		    <li><a href='sandbox_iLQR.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0'>Iterative linear quadratic regulator (iLQR)</div></a></li>
		  </ul>
		</div>
	  </li>
	  
	  <li class='border-top my-1'></li>
	  
	  <li class='mb-1'>
		<button class='btn btn-toggle d-inline-flex align-items-center rounded border-0 collapsed' data-bs-toggle='collapse' data-bs-target='#exercises-collapse' aria-expanded='true'>Exercises</button>
		<div class='collapse show' id='exercises-collapse'>
		  <ul class='btn-toggle-nav list-unstyled fw-normal pb-1 small'>
		    <li><a href='exercise01.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
			<div class='p-1 mb-0 bg-dark text-white font-monospace'>01</div>
			<div class='p-1 mb-0'>Linear algebra in Python</div></a></li>
		    <li><a href='exercise02.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0 bg-dark text-white font-monospace'>02</div>
			<div class='p-1 mb-0'>Movement primitives and Newton's method</div></a></li>
			<li><a href='exercise03.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0 bg-dark text-white font-monospace'>03</div>
			<div class='p-1 mb-0'>Gaussian Distributions</div></a></li>
			<li><a href='exercise04a.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0 bg-dark text-white font-monospace'>4a</div>
			<div class='p-1 mb-0'>Forward kinematics</div></a></li>
			<li><a href='exercise04b.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0 bg-dark text-white font-monospace'>4b</div>
			<div class='p-1 mb-0'>Inverse kinematics and nullspace control</div></a></li>
			<li><a href='exercise05a.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0 bg-dark text-white font-monospace'>5a</div>
			<div class='p-1 mb-0'>Forward dynamics</div></a></li>
			<li><a href='exercise05b.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0 bg-dark text-white font-monospace'>5b</div>
			<div class='p-1 mb-0'>Inverse dynamics and impedance control</div></a></li>
			<li><a href='exercise06a.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0 bg-dark text-white font-monospace'>6a</div>
			<div class='p-1 mb-0'>Planning with linear quadratic regulator</div></a></li>
			<li><a href='exercise06b.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0 bg-dark text-white font-monospace'>6b</div>
			<div class='p-1 mb-0'>Planning in joint space with LQR</div></a></li>
			<li><a href='exercise07.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0 bg-dark text-white font-monospace'>07</div>
			<div class='p-1 mb-0'>Iterative linear quadratic regulator (iLQR)</div></a></li>
			<li><a href='exercise08.htm' class='link-dark d-inline-flex text-decoration-none rounded'>
		    <div class='p-1 mb-0 bg-dark text-white font-monospace'>08</div>
			<div class='p-1 mb-0'>Exploration with ergodic control</div></a></li>
		  </ul>
		</div>
	  </li>
	  
	</ul>
    </div> <!--offcanvas-body-->
    
  </div> <!--offcanvas-->
</div> <!--container-fluid-->
</nav>

<!-- <iframe enable-annotation></iframe> -->

<div class='container-fluid'>


<div class='row'>
<div class='col-sm-1'></div>
<div class='col-sm-7'>

<br><br>

<script>
function clearMsgs() {
  const el = document.getElementById('repl-err');
  el.innerText = '';
  //console.log('event!');
}
</script>

<div onkeydown='clearMsgs()' onclick='clearMsgs()'>
<py-repl std-out='repl-out' std-err='repl-err'>
param.dt = 1E-1 # Time step length
param.nbVarX = 2 # State space dimension
param.l = np.ones(param.nbVarX) * 600 / param.nbVarX # Robot links lengths
param.m = np.ones(param.nbVarX) # Robot links masses
param.damping = 15 # Damping parameter
param.gravity = 9.81 # Gravity
x = np.zeros(2*param.nbVarX) # Initial robot state (position and velocity)
u = np.zeros(param.nbVarX) # Input commands (torque commands)
</py-repl> <!--output='repl-out' std-out='repl-out'-->
</div>
<p id='repl-out' style='font-size: 70%; color: #777777;'>(press shift+enter or click on the green run button to run the code; objects and joints can be moved with the mouse)</p>
<p id='repl-err' style='font-size: 70%; color: #880000;'></p>

</div> <!--sm-7-->

<div class='col-sm-4'>
<div class='sticky-sm-top'>
<canvas id='canvas' style='width:100%;' width='900px' height='700px'></canvas>
</div>
</div> <!--sm-4-->

</div> <!--row-->

<py-script>
from pyodide.ffi import create_proxy
from js import Path2D, document, console
import numpy as np
import asyncio

# Forward kinematics for end-effector (in robot coordinate system)
def fkin(x, param):
	L = np.tril(np.ones([param.nbVarX, param.nbVarX]))
	f = [param.l @ np.cos(L @ x), param.l @ np.sin(L @ x)] 
	return f
	
# Forward kinematics for all joints (in robot coordinate system)
def fkin0(x, param): 
	L = np.tril(np.ones([param.nbVarX, param.nbVarX]))
	f = np.vstack([
		L @ np.diag(param.l) @ np.cos(L @ x),
		L @ np.diag(param.l) @ np.sin(L @ x)
	])
	f = np.hstack([np.zeros([2,1]), f])
	return f

# Jacobian with analytical computation (for single time step)
def Jkin(x, param):
	L = np.tril(np.ones([param.nbVarX, param.nbVarX]))
	J = np.vstack([
		-np.sin(L @ x).T @ np.diag(param.l) @ L,
		 np.cos(L @ x).T @ np.diag(param.l) @ L
	])
	return J

def fdyn(x, u, param):
	# Auxiliary matrices
	l = np.reshape(param.l/100, [1, param.nbVarX])
	L = np.tril(np.ones([param.nbVarX, param.nbVarX]))
	m = np.reshape(param.m, [1, param.nbVarX])
	Lm = np.triu(np.ones([m.shape[1], m.shape[1]])) * np.repeat(m, m.shape[1],0)
	
#	# Elementwise computation of G, M, and C
#    G = np.zeros(param.nbVarX)
#    M = np.zeros([param.nbVarX, param.nbVarX])
#    C =  np.zeros([param.nbVarX, param.nbVarX])
#    for k in range(param.nbVarX):
#        G[k] = -sum(m[0,k:]) * param.gravity * l[0,k] * np.cos(L[k,:] @ x[:param.nbVarX])
#        for i in range(param.nbVarX):
#            S = sum(m[0,k:param.nbVarX] * np.heaviside(np.array(range(k, param.nbVarX)) - i, 1))
#            M[k,i] = l[0,k] * l[0,i] * np.cos(L[k,:] @ x[:param.nbVarX] - L[i,:] @ x[:param.nbVarX]) * S
#            C[k,i] = -l[0,k] * l[0,i] * np.sin(L[k,:] @ x[:param.nbVarX] - L[i,:] @ x[:param.nbVarX]) * S
	# Computation in matrix form of G, M, and C
	G = -np.sum(Lm,1) * param.l/100 * np.cos(L @ x[:param.nbVarX]) * param.gravity
	C = -(l.T * l) * np.sin(L @ x[:param.nbVarX] - L @ x[:param.nbVarX]) * (Lm**.5 @ ((Lm**.5).T)) 
	M = (l.T * l) * np.cos(L @ x[:param.nbVarX] - L @ x[:param.nbVarX]) * (Lm**.5 @ ((Lm**.5).T))
	
	G = L.T @ G
	C = L.T @ C
	M = L.T @ M @ L 
	# Compute acceleration
	ddx = np.linalg.inv(M) @ (u + G + C @ (L @ x[param.nbVarX:])**2) - x[param.nbVarX:] * param.damping
	return ddx


## Parameters
# ===============================

param = lambda: None # Lazy way to define an empty class in python
param.dt = 1E-1 # Time step length
param.nbVarX = 2 # State space dimension
param.l = np.ones(param.nbVarX) * 600 / param.nbVarX # Robot links lengths
param.m = np.ones(param.nbVarX) # Robot links masses
#param.l = np.array([200, 200]) # Robot links lengths
#param.m = np.array([1E0, 1E0]) # Robot links masses
param.damping = 15 # Damping parameter
param.gravity = 9.81 # Gravity

param2 = lambda: None # Lazy way to define an empty class in python

#########################################################################################

# Mouse events
mouse0 = np.zeros(2)
mouse = np.zeros(2)
mousedown = 0
hover_joint = -1
move_joint= -1
hover0 = np.zeros(2)

def onMouseMove(event):
	global mouse, mouse0, hover0, x
	offset = canvas.getBoundingClientRect()
	mouse0[0] = (event.clientX - offset.x) * canvas.width / canvas.clientWidth
	mouse0[1] = (event.clientY - offset.y) * canvas.height / canvas.clientHeight
	mouse[0] = (mouse0[0] - canvas.width * 0.5) 
	mouse[1] = -(mouse0[1] - canvas.height * 0.1) 
#	if move_joint >= 0:
#		x[move_joint] -= 1E-2 * np.sum(hover0 - mouse0)
#		hover0 = np.copy(mouse0)
		
def onTouchMove(event):
	global mouse, mouse0, hover0, x
	offset = event.target.getBoundingClientRect()
	mouse0[0] = (event.touches.item(0).clientX - offset.x) * canvas.width / canvas.clientWidth
	mouse0[1] = (event.touches.item(0).clientY - offset.y) * canvas.height / canvas.clientHeight
	mouse[0] = (mouse0[0] - canvas.width * 0.5) 
	mouse[1] = -(mouse0[1] - canvas.height * 0.1)
#	if move_joint >= 0:
#		x[move_joint] -= 1E-2 * np.sum(hover0 - mouse0)
#		hover0 = np.copy(mouse0)
	
def onMouseDown(event):
	global mousedown, move_joint, hover0, param2
	mousedown = 1
	if hover_joint >= 0:
		f0 = fkin0(x[:param.nbVarX], param)
		param2.l = np.append(param.l[:hover_joint], np.linalg.norm(f0[:,hover_joint] - mouse))
		param2.nbVarX = hover_joint+1
		move_joint = hover_joint
#		if param2.l[-1] > 40:
#			move_joint = hover_joint
#			hover0 = np.copy(mouse0)

def onMouseUp(event):
	global mousedown, move_joint
	mousedown = 0
	move_joint = -1

def onWheel(event):
	global x
	if hover_joint >= 0:
		x[hover_joint] -= 0.2 * (event.deltaY/106)

document.addEventListener('mousemove', create_proxy(onMouseMove)) #for standard mouse
document.addEventListener('touchmove', create_proxy(onTouchMove)) #for mobile interfaces

document.addEventListener('mousedown', create_proxy(onMouseDown)) #for standard mouse
#document.addEventListener('pointerdown', create_proxy(onMouseDown)) #for mobile interfaces 
document.addEventListener('touchstart', create_proxy(onMouseDown)) #for mobile interfaces 

document.addEventListener('mouseup', create_proxy(onMouseUp)) #for standard mouse
#document.addEventListener('pointerup', create_proxy(onMouseUp)) #for mobile interfaces 
document.addEventListener('touchend', create_proxy(onMouseUp)) #for mobile interfaces 

document.addEventListener('wheel', create_proxy(onWheel)) #for standard mouse


#########################################################################################

canvas = document.getElementById('canvas')
ctx = canvas.getContext('2d')

def clear_screen():
	ctx.setTransform(1, 0, 0, 1, 0, 0)
	ctx.fillStyle = 'white'
	ctx.fillRect(0, 0, canvas.width, canvas.height)


def draw_robot(x, color):
	global hover_joint
	ctx.setTransform(1, 0, 0, -1, canvas.width*0.5, canvas.height*0.1)
	
	f = fkin0(x, param)
	
	# Draw base
	ctx.translate(f[0,0], f[1,0])
	ctx.lineWidth = '4'
	ctx.strokeStyle = 'white'
	ctx.fillStyle = color
	ctx.beginPath()
	ctx.arc(0, 0, 40, 0, np.pi)
	ctx.rect(-40, 0, 80, -40)
	ctx.fill()
	ctx.strokeStyle = color
	for i in range(5):
		ctx.beginPath()
		ctx.moveTo(-30+i*15, -40)
		ctx.lineTo(-40+i*15, -60)
		ctx.stroke()
		
	# Draw links and articulations
	obj_articulation = Path2D.new()
	obj_articulation.arc(0, 0, 12, 0, 2*np.pi)
	ctx.lineCap = 'round'
	ctx.lineJoin = 'round'
	for i in range(param.nbVarX):
		if i < param.nbVarX:
			# Draw links outlines
			ctx.lineWidth = '46'
			ctx.strokeStyle = 'white'
			ctx.beginPath()
			ctx.lineTo(f[0,i], f[1,i])
			ctx.lineTo(f[0,i+1], f[1,i+1])
			ctx.stroke()
			# Draw links
			obj = Path2D.new()
			obj.lineTo(f[0,i], f[1,i])
			obj.lineTo(f[0,i+1], f[1,i+1])
			ctx.lineWidth = '38'
			ctx.strokeStyle = color
			ctx.stroke(obj)
			if ctx.isPointInStroke(obj, mouse0[0], mouse0[1]) and move_joint < 0:
				console.log(i)
				hover_joint = i
		
		# Draw articulations
		ctx.lineWidth = '4'
		ctx.strokeStyle = 'white'
		ctx.translate(f[0,i], f[1,i])
		ctx.stroke(obj_articulation)
#		if ctx.isPointInPath(obj_articulation, mouse0[0], mouse0[1]) and move_joint < 0:
#			hover_joint = i
		ctx.translate(-f[0,i], -f[1,i])
	

def draw_selected_point(f, color):
	ctx.setTransform(1, 0, 0, -1, canvas.width*0.5, canvas.height*0.1)
	# Draw object
	obj = Path2D.new()
	obj.arc(0, 0, 6, 0, 2*np.pi)
	ctx.translate(f[0], f[1])
	ctx.fillStyle = color
	ctx.fill(obj)


def controlCommand(x, param):
	u = np.zeros(param.nbVarX)
	if move_joint >= 0:
		f = fkin(x[:move_joint+1], param2)
		J = Jkin(x[:move_joint+1], param2)
#		u[:move_joint+1] = np.linalg.pinv(J) @ (mouse - f) * 5 
#		pinvJ = np.linalg.inv(J.T @ J + np.eye(param2.nbVarX) * 1E4) @ J.T # Damped pseudoinverse
		u[:move_joint+1] += J.T @ (mouse - f) * 1E-2 # Torque commands
	return u

#########################################################################################
 
def errorHandler(e):
	msg = 'Error: ' + str(e)
	console.error(msg)
	el = document.getElementById('repl-err')
	el.innerText = msg
	#el.textContent = msg
	
#########################################################################################
x = np.zeros(2*param.nbVarX) # Initial robot state (position and velocity)
#u = np.zeros(param.nbVarX) # Input commands (torque commands)

async def main():
	global hover_joint, x
	
	while True:
	#	try:
	#		u = controlCommand(x, param)
	#	except Exception as e:
	#		errorHandler(e)
	#		#u = np.zeros(param.nbVarX)
	#		def controlCommand(x, param):
	#			u = np.zeros(param.nbVarX)
	#			return u
		
		u = controlCommand(x, param) # Torque commands
		ddx = fdyn(x, u, param) # Compute accelerations
	#	x += np.append(x[param.nbVarX:], ddx) * param.dt # Update state
		x += np.append(x[param.nbVarX:] + 0.5 * ddx * param.dt, ddx) * param.dt # Update state
		
		# Reinit hovering variables
		hover_joint = -1
		
		# Rendering
		clear_screen()
		draw_robot(x[:param.nbVarX], '#AAAAAA')
		if move_joint >= 0:
			f = fkin(x[:move_joint+1], param2)
			draw_selected_point(f, '#777777')

		await asyncio.sleep(0.001)

pyscript.run_until_complete(main())

</py-script>

</div> <!--container-->
</body>
</html>

